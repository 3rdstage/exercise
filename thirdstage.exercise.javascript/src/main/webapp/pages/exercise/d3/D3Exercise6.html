<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>D3.js Exercise</title>
<script type="text/javascript" src="../../../scripts/jquery/js/jquery-1.8.0.min.js"></script>
<script type='text/javascript' src='../../../scripts/d3/d3.v2.min.js'></script>

	<style type="text/css">
		div .axis path, div .axis line{
			fill:none;
			stroke:black;
			shape-rendering:crispEdges;
		}
		
		div .axis text{
			font-family:sans-serif;
			font-size:11px;
		}
	</style>
	
	<script>
	function scatterChart(spec){
		var that = {};
		
		//@todo add issue firing when some properties such as canvas is not specified.
		//@todo add ratio (width versus height) property and releated methods.
		
		var canvas = spec.canvas;
		var width = spec.width || 800;
		var height = spec.height || 600;
		var paddingTop = spec.paddingTop || spec.padding || 50;
		var paddingRight = spec.paddingRight || spec.padding || 50;
		var paddingBottom = spec.paddingBottom || spec.padding || 50;
		var paddingLeft = spec.paddingLeft || spec.padding || 50;
		var minX = spec.minX || 0;
		var maxX = spec.maxX || 1000;
		var minY = spec.minY || 0;
		var maxY = spec.maxY || 500;
		var data = spec.data;
		var pointSize = spec.pointSize || 2;
		var flowSpeed = spec.flowSpeed || 50; // speed in millisecond per pixcel in screen

		
		var xScale = d3.scale.linear().domain([minX, maxX]).range([paddingLeft, width - paddingRight]);
		var yScale = d3.scale.linear().domain([minY, maxY]).range([height - paddingBottom, paddingTop]);
		
		var xAxis = d3.svg.axis().scale(xScale).orient("bottom");
		var yAxis = d3.svg.axis().scale(yScale).orient("left");
		
		var svg = null;
		var _points = null;
		var _isFlowing = false;
		var _pointSeq = 0;  //@todo point seq should be able to wrapped to avoid to become too large above the limit of the variable size;
		var _unstartedPoints = null;
		var _startedPoints = null;

		
		that.draw = function(){
			svg = d3.select(canvas)
				.append("svg")
				.attr("width", width)
				.attr("height", height);
			
			_points = svg.selectAll("circle")
			
			_points.data(data, function(d){ return _pointSeq++;})
				.enter()
				.append("circle")
				.attr("cx", function(d){ return xScale(d[0]);})
				.attr("cy", function(d){ return yScale(d[1]);})
				.attr("r", pointSize);
			
			svg.append("g")
				.classed("axis", true)
				.attr("transform", "translate(0, " + (height - paddingBottom) + ")")
				.call(xAxis);
		
			svg.append("g")
				.classed("axis", true)
				.attr("transform", "translate(" + paddingLeft + ", 0)")
				.call(yAxis);
		
			svg.selectAll(".axis line, .axis path")
				.style("fill", "none")
				.style("stroke", "black")
				.style("shape-rendering", "crispEdges");
			
			return that;
		}
		
		
		that.flow = function(){
			//@todo _points.transition() doesn't work. why ?
			
			svg.selectAll("circle").transition()
				.attrTween("cx", function(){
					var x = Number(d3.select(this).attr("cx"));
					return d3.interpolateNumber(x, width - paddingRight);
				})
				.duration(function(d){
					var t = flowSpeed * (maxX - minX - d[0]);
					return t;

				})
				.ease("linear")
				.each("end", function(){
					d3.select(this).remove();
				});
			
			_isFlowing = true;
			return that; 
		}
		
		that.stopFlow = function(){
			
			//if(!_isFlowing) return;
			
			_points.transtion()
				.duration(0);
			
			return that;
		}
		
		that.addData = function(dataAdded){
			
			var addedPoints = _points.data(dataAdded, function(d){ return _pointSeq++;})
				.enter()
				.append("circle")
				.attr("cx", function(d){ return xScale(d[0]);})
				.attr("cy", function(d){ return yScale(d[1]);})
				.attr("r", pointSize);		
			
			if(_isFlowing){

				addedPoints.transition()
					.attrTween("cx", function(){
						var x = Number(d3.select(this).attr("cx"));
						return d3.interpolateNumber(x, width - paddingRight);
					})
					.duration(function(d){
						var t = flowSpeed * (maxX - minX - d[0]);
						return t;
					})
					.ease("linear")
					.each("end", function(){
						d3.select(this).remove();
					});				
			}
			
			return that;
		}

		return that;
	}
	</script>
</head>
<body>

	<div id="div2"></div>
	<script type='text/javascript'>
		var dim2 = [800, 600];
		var os2 = [50, 50, 50, 50];
		var ll2 = [0, 0];
		var ur2 = [400, 300];
		var r2 = 5;

		var data2 = [];
		var x2 = 0, y2 = 0, n2 = 10;
		for(var i = 0; i < n2; i++){
			x2 = Math.round(Math.random()*30);
			y2 = Math.round(Math.random()*ur2[1]);
			data2.push([x2, y2]);
		}
		
		var chart2 = scatterChart({
			canvas : "#div2",
			width : dim2[0],
			height : dim2[1],
			paddingTop : os2[0],
			paddingRight : os2[1],
			paddingBottom : os2[2],
			paddingLeft : os2[3],
			minX : ll2[0],
			maxX : ur2[0],
			minY : ll2[1],
			maxY : ur2[1],
			data : data2,
			pointSize : r2
		});

		//chart2.draw();
		chart2.draw().flow();
		
		var timerId = self.setInterval(function(){
			var data = [];
			for(var i = 0; i < n2; i++){
				data.push([Math.round(Math.random()*30), Math.round(Math.random()*ur2[1])]);
			}
			chart2.addData(data);
		}, 1000);
		
		$("#button2a").click(function(ev){
			ev.stopPropagation();
			chart2.stopFlow();
		});
		
		$("#button2c").click(function(ev){
			ev.stopPropagation();
			self.clearInterval(timerId);
		});

			
	</script>

	<hr align="left" width="800"/>
	
	<div id="div2">
	
	</div>
	<div id="div2Control">
		<form>
			<button id="button2a" type="button" class="submit">Stop Flow</button>
			<button id="button2b" type="button" class="submit">Animate 2</button>
			<button id="button2c" type="button" class="submit">Stop Add</button>
		</form>	
	</div>
		
	
	

</body>
</html>