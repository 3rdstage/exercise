class XMLGregorianCalendarImpl
!!!5405723.java!!!	XMLGregorianCalendarImpl(in lexicalRepresentation : String)
			
	// compute format string for this lexical representation.
	String format = null;
	String lexRep = lexicalRepresentation;
	final int NOT_FOUND = -1;
	int lexRepLength = lexRep.length();
	
	
	// current parser needs a format string,
	// use following heuristics to figure out what xml schema date/time
	// datatype this lexical string could represent.
	if (lexRep.indexOf('T') != NOT_FOUND) {
	    // found Date Time separater, must be xsd:DateTime
	    format = "%Y-%M-%DT%h:%m:%s" + "%z";
	} else if (lexRepLength >= 3 && lexRep.charAt(2) == ':') {
	    // found ":", must be xsd:Time
	    format = "%h:%m:%s" +"%z";
	} else if (lexRep.startsWith("--")) {
	    // check for GDay || GMonth || GMonthDay
	    if (lexRepLength >= 3 && lexRep.charAt(2) == '-') {
		// GDAY
		// Fix 4971612: invalid SCCS macro substitution in data string
		format = "---%D" + "%z";
	    } else if (lexRepLength >= 6 &&
		       lexRep.charAt(5) == '-' && lexRep.charAt(4) == '-') {
		// GMonth
		// Fix 4971612: invalid SCCS macro substitution in data string
		format = "--%M--%z";
	    } else {
		// GMonthDay or invalid lexicalRepresentation
		format = "--%M-%D" + "%z";
	    }
	} else {
	    // check for Date || GYear | GYearMonth
	    int countSeparator = 0;

	    // start at index 1 to skip potential negative sign for year.
	    
	    
	    int timezoneOffset = lexRep.indexOf(':');
	    if (timezoneOffset != NOT_FOUND) {

		// found timezone, strip it off for distinguishing
		// between Date, GYear and GYearMonth so possible
		// negative sign in timezone is not mistaken as
		// a separator.
		lexRepLength -= 6;
	    }
	    
	    for (int i=1; i < lexRepLength; i++) {
		if (lexRep.charAt(i) == '-') {
			countSeparator++;
		}
	    }
	    if (countSeparator == 0) {
		// GYear
		format = "%Y" + "%z";
	    } else if (countSeparator == 1) {
		// GYearMonth
		format = "%Y-%M" + "%z";
	    } else {
		// Date or invalid lexicalRepresentation
		// Fix 4971612: invalid SCCS macro substitution in data string
		format = "%Y-%M-%D" + "%z";
	    }
	}
	Parser p = new Parser(format, lexRep);
	p.parse();
	
		// check for validity
		if (!isValid()) {
			throw new IllegalArgumentException(
                DatatypeMessageFormatter.formatMessage(null,"InvalidXGCRepresentation", new Object[]{lexicalRepresentation})
				//"\"" + lexicalRepresentation + "\" is not a valid representation of an XML Gregorian Calendar value."
			);
	    }
!!!5405851.java!!!	XMLGregorianCalendarImpl()
    	
        // field initializers already do the correct initialization.
!!!5405979.java!!!	XMLGregorianCalendarImpl(inout year : BigInteger, in month : int, in day : int, in hour : int, in minute : int, in second : int, inout fractionalSecond : BigDecimal, in timezone : int)
        	
		setYear(year);
        setMonth(month);
        setDay(day);
        setTime(hour, minute, second, fractionalSecond);
		setTimezone(timezone);
		
		// check for validity
		if (!isValid()) {
			
            throw new IllegalArgumentException(
                DatatypeMessageFormatter.formatMessage(null, 
                    "InvalidXGCValue-fractional", 
                    new Object[] { year, new Integer(month), new Integer(day), 
                    new Integer(hour), new Integer(minute), new Integer(second),
                    fractionalSecond, new Integer(timezone)})
			);
                    
			/**
                String yearString = "null";
                if (year != null) {
                    yearString = year.toString();
                }
                String fractionalSecondString = "null";
                if (fractionalSecond != null) {
                    fractionalSecondString = fractionalSecond.toString();
                }
             
                throw new IllegalArgumentException(
                    "year = " + yearString
                    + ", month = " + month
                    + ", day = " + day
                    + ", hour = " + hour
                    + ", minute = " + minute
                    + ", second = " + second
                    + ", fractionalSecond = " + fractionalSecondString
                    + ", timezone = " + timezone
                    + ", is not a valid representation of an XML Gregorian Calendar value."
                );
                */
            
		}
		
!!!5406107.java!!!	XMLGregorianCalendarImpl(in year : int, in month : int, in day : int, in hour : int, in minute : int, in second : int, in millisecond : int, in timezone : int)
        	
		setYear(year);
        setMonth(month);
        setDay(day);
        setTime(hour, minute, second);
		setTimezone(timezone);
		setMillisecond(millisecond);

		if (!isValid()) {		
            
            throw new IllegalArgumentException(
                DatatypeMessageFormatter.formatMessage(null, 
                "InvalidXGCValue-milli", 
                new Object[] { new Integer(year), new Integer(month), new Integer(day), 
                new Integer(hour), new Integer(minute), new Integer(second), 
                new Integer(millisecond), new Integer(timezone)})                
			);
                /*
                throw new IllegalArgumentException(
                    "year = " + year
                    + ", month = " + month
                    + ", day = " + day
                    + ", hour = " + hour
                    + ", minute = " + minute
                    + ", second = " + second
                    + ", millisecond = " + millisecond
                    + ", timezone = " + timezone
                    + ", is not a valid representation of an XML Gregorian Calendar value."
                    );
                 */
            
		}
!!!5406235.java!!!	XMLGregorianCalendarImpl(inout cal : GregorianCalendar)
    	
	int year = cal.get(Calendar.YEAR);
	if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {
		year = -year;
	}
	this.setYear(year);
	
	// Calendar.MONTH is zero based, XSD Date datatype's month field starts
		// with JANUARY as 1.
	this.setMonth(cal.get(Calendar.MONTH) + 1);
	this.setDay(cal.get(Calendar.DAY_OF_MONTH));
	this.setTime(
		cal.get(Calendar.HOUR_OF_DAY),
		cal.get(Calendar.MINUTE), 
		cal.get(Calendar.SECOND),
		cal.get(Calendar.MILLISECOND));
	
	// Calendar ZONE_OFFSET and DST_OFFSET fields are in milliseconds.
	int offsetInMinutes = (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / (60 * 1000);
	this.setTimezone(offsetInMinutes);
!!!5406363.java!!!	createDateTime(inout year : BigInteger, in month : int, in day : int, in hours : int, in minutes : int, in seconds : int, inout fractionalSecond : BigDecimal, in timezone : int) : XMLGregorianCalendar
	
	return new XMLGregorianCalendarImpl(
		year,
		month, 
		day, 
		hours,
		minutes,
		seconds, 
		fractionalSecond,
		timezone);
!!!5406491.java!!!	createDateTime(in year : int, in month : int, in day : int, in hour : int, in minute : int, in second : int) : XMLGregorianCalendar
        	
        return new XMLGregorianCalendarImpl(
            year,
            month,
            day,
            hour,
            minute,
            second,
            DatatypeConstants.FIELD_UNDEFINED,  //millisecond
        	DatatypeConstants.FIELD_UNDEFINED //timezone
        );
!!!5406619.java!!!	createDateTime(in year : int, in month : int, in day : int, in hours : int, in minutes : int, in seconds : int, in milliseconds : int, in timezone : int) : XMLGregorianCalendar
        	
        return new XMLGregorianCalendarImpl(
            year,
            month,
            day,
            hours,
            minutes,
            seconds,
            milliseconds,
            timezone);
!!!5406747.java!!!	createDate(in year : int, in month : int, in day : int, in timezone : int) : XMLGregorianCalendar
        	
        return new XMLGregorianCalendarImpl(
            year,
            month,
            day,
            DatatypeConstants.FIELD_UNDEFINED, // hour
            DatatypeConstants.FIELD_UNDEFINED, // minute
            DatatypeConstants.FIELD_UNDEFINED, // second
	    	DatatypeConstants.FIELD_UNDEFINED, // millisecond
            timezone);
!!!5406875.java!!!	createTime(in hours : int, in minutes : int, in seconds : int, in timezone : int) : XMLGregorianCalendar
			
		return new XMLGregorianCalendarImpl(
			DatatypeConstants.FIELD_UNDEFINED, // Year
			DatatypeConstants.FIELD_UNDEFINED, // Month
			DatatypeConstants.FIELD_UNDEFINED, // Day
			hours,
			minutes,
			seconds, 
			DatatypeConstants.FIELD_UNDEFINED, //Millisecond
			timezone);
!!!5407003.java!!!	createTime(in hours : int, in minutes : int, in seconds : int, inout fractionalSecond : BigDecimal, in timezone : int) : XMLGregorianCalendar
        	
        return new XMLGregorianCalendarImpl(
            null,            // Year
            DatatypeConstants.FIELD_UNDEFINED, // month
            DatatypeConstants.FIELD_UNDEFINED, // day
            hours,
            minutes,
            seconds,
            fractionalSecond,
            timezone);
!!!5407131.java!!!	createTime(in hours : int, in minutes : int, in seconds : int, in milliseconds : int, in timezone : int) : XMLGregorianCalendar
        	
        return new XMLGregorianCalendarImpl(
            DatatypeConstants.FIELD_UNDEFINED, // year
            DatatypeConstants.FIELD_UNDEFINED, // month
            DatatypeConstants.FIELD_UNDEFINED, // day
            hours,
            minutes,
            seconds,
	    milliseconds,
            timezone);
!!!5407259.java!!!	getEon() : BigInteger
	   return eon;
!!!5407387.java!!!	getYear() : int
	   return year;
!!!5407515.java!!!	getEonAndYear() : BigInteger
    	
		// both are defined
		if (year != DatatypeConstants.FIELD_UNDEFINED
			&& eon != null) {
    			
			return eon.add(BigInteger.valueOf((long) year));
		}

		// only year is defined
		if (year != DatatypeConstants.FIELD_UNDEFINED
			&& eon == null) {
    			
			return BigInteger.valueOf((long) year);
		}

    	// neither are defined
    	// or only eon is defined which is not valid without a year 
		return null;
!!!5407643.java!!!	getMonth() : int
    	return month;
!!!5407771.java!!!	getDay() : int
	return day;
!!!5407899.java!!!	getTimezone() : int
	return timezone;
!!!5408027.java!!!	getHour() : int
	return hour;
!!!5408155.java!!!	getMinute() : int
	return minute;
!!!5408283.java!!!	getSecond() : int
	   return second;
!!!5408411.java!!!	getSeconds() : BigDecimal
    	
	if (second == DatatypeConstants.FIELD_UNDEFINED) {
	    return DECIMAL_ZERO;
	} 
	BigDecimal result = BigDecimal.valueOf((long)second);
	if (fractionalSecond != null){
	    return result.add(fractionalSecond);
	} else {
	    return result;
	}
!!!5408539.java!!!	getMillisecond() : int
        if (fractionalSecond == null) {
            return DatatypeConstants.FIELD_UNDEFINED;
        } else {
            // TODO: Non-optimal solution for now.
            // Efficient implementation would only store as BigDecimal
            // when needed and millisecond otherwise.
            return fractionalSecond.movePointRight(3).intValue();
        }
!!!5408667.java!!!	getFractionalSecond() : BigDecimal
	   return fractionalSecond;
!!!5408795.java!!!	setYear(inout year : BigInteger) : void
	if (year == null) {
	    this.eon = null;
	    this.year = DatatypeConstants.FIELD_UNDEFINED;
	} else {
	    BigInteger temp = year.remainder(BILLION);
	    this.year = temp.intValue();
	    setEon(year.subtract(temp));
	}
!!!5408923.java!!!	setYear(in year : int) : void
 
	if (year == DatatypeConstants.FIELD_UNDEFINED) {
	    this.year = DatatypeConstants.FIELD_UNDEFINED;
	    this.eon = null;
	} else if (Math.abs(year) < BILLION.intValue()) {
	    this.year = year;
	    this.eon = null;
	} else {
	    BigInteger theYear = BigInteger.valueOf((long) year);
	    BigInteger remainder = theYear.remainder(BILLION);
	    this.year = remainder.intValue();
	    setEon(theYear.subtract(remainder));
	}
!!!5409051.java!!!	setEon(inout eon : BigInteger) : void
        if (eon != null && eon.compareTo(BigInteger.ZERO) == 0) {
            // Treat ZERO as field being undefined.
            this.eon = null;
        } else {
            this.eon = eon;
        }
!!!5409179.java!!!	setMonth(in month : int) : void
 
	checkFieldValueConstraint(MONTH, month);
	this.month = month;
!!!5409307.java!!!	setDay(in day : int) : void
  
	checkFieldValueConstraint(DAY, day);
	this.day = day;
!!!5409435.java!!!	setTimezone(in offset : int) : void
	checkFieldValueConstraint(TIMEZONE, offset);
	this.timezone = offset;
!!!5409563.java!!!	setTime(in hour : int, in minute : int, in second : int) : void
	setTime(hour, minute, second, null);
!!!5409691.java!!!	checkFieldValueConstraint(in field : int, in value : int) : void
	if ((value < MIN_FIELD_VALUE[field] && value != DatatypeConstants.FIELD_UNDEFINED) ||
	    value > MAX_FIELD_VALUE[field]) {
         /**
            throw new IllegalArgumentException("invalid value " + value +
					       " for " + FIELD_NAME[field] +
					       " field");
             */
        throw new IllegalArgumentException(
            DatatypeMessageFormatter.formatMessage(null, "InvalidFieldValue", new Object[]{ new Integer(value), FIELD_NAME[field]})
        );
	}
!!!5409819.java!!!	setHour(in hour : int) : void
	checkFieldValueConstraint(HOUR, hour);
	this.hour = hour;
!!!5409947.java!!!	setMinute(in minute : int) : void
	checkFieldValueConstraint(MINUTE, minute);
	this.minute = minute;
!!!5410075.java!!!	setSecond(in second : int) : void
	checkFieldValueConstraint(SECOND, second);
	this.second  = second;
!!!5410203.java!!!	setTime(in hour : int, in minute : int, in second : int, inout fractional : BigDecimal) : void
	setHour(hour);
        setMinute(minute);
        setSecond(second);
        setFractionalSecond(fractional);
!!!5410331.java!!!	setTime(in hour : int, in minute : int, in second : int, in millisecond : int) : void
        setHour(hour);
        setMinute(minute);
        setSecond(second);
        setMillisecond(millisecond);
!!!5410459.java!!!	compare(inout rhs : XMLGregorianCalendar) : int
        	
		XMLGregorianCalendar lhs = this;

	int result = DatatypeConstants.INDETERMINATE;
        XMLGregorianCalendarImpl P = (XMLGregorianCalendarImpl) lhs;
        XMLGregorianCalendarImpl Q = (XMLGregorianCalendarImpl) rhs;

        if (P.getTimezone() == Q.getTimezone()) {
	    // Optimization: 
	    // both instances are in same timezone or
	    // both are FIELD_UNDEFINED. 
	    // Avoid costly normalization of timezone to 'Z' time.
	    return internalCompare(P, Q);

	} else if (P.getTimezone() != DatatypeConstants.FIELD_UNDEFINED &&
		   Q.getTimezone() != DatatypeConstants.FIELD_UNDEFINED) {

	    // Both instances have different timezones.
	    // Normalize to UTC time and compare.
	    P = (XMLGregorianCalendarImpl) P.normalize();
	    Q = (XMLGregorianCalendarImpl) Q.normalize();
	    return internalCompare(P, Q);
	} else if (P.getTimezone() != DatatypeConstants.FIELD_UNDEFINED) {
	    
	    if (P.getTimezone() != 0) {
		P = (XMLGregorianCalendarImpl) P.normalize();
	    }
	    
	    // C. step 1
	    XMLGregorianCalendar MinQ = Q.normalizeToTimezone(DatatypeConstants.MIN_TIMEZONE_OFFSET);
	    result = internalCompare(P, MinQ);
	    if (result == DatatypeConstants.LESSER) {
		return result;
	    } 

	    // C. step 2
	    XMLGregorianCalendar MaxQ = Q.normalizeToTimezone(DatatypeConstants.MAX_TIMEZONE_OFFSET);
	    result = internalCompare(P, MaxQ);
	    if (result == DatatypeConstants.GREATER) {
		return result;
	    } else {
		// C. step 3
		return DatatypeConstants.INDETERMINATE;
	    }
	} else { // Q.getTimezone() != DatatypeConstants.FIELD_UNDEFINED
	    // P has no timezone and Q does.
	    if (Q.getTimezone() != 0 ) { 
			Q = (XMLGregorianCalendarImpl) Q.normalizeToTimezone(Q.getTimezone());
	    }
	    
	    // D. step 1
	    XMLGregorianCalendar MaxP = P.normalizeToTimezone(DatatypeConstants.MAX_TIMEZONE_OFFSET);
	    result = internalCompare(MaxP, Q);
	    if (result == DatatypeConstants.LESSER) {
		return result;
	    } 

	    // D. step 2
	    XMLGregorianCalendar MinP = P.normalizeToTimezone(DatatypeConstants.MIN_TIMEZONE_OFFSET);
	    result = internalCompare(MinP, Q);
	    if (result == DatatypeConstants.GREATER) {
		return result;
	    } else {
		// D. step 3
		return DatatypeConstants.INDETERMINATE;
	    }
        }
!!!5410587.java!!!	normalize() : XMLGregorianCalendar

        XMLGregorianCalendar normalized = normalizeToTimezone(timezone);
        
        // if timezone was undefined, leave it undefined
        if (getTimezone() == DatatypeConstants.FIELD_UNDEFINED) {
            normalized.setTimezone(DatatypeConstants.FIELD_UNDEFINED);
        }
        
        // if milliseconds was undefined, leave it undefined
        if (getMillisecond() == DatatypeConstants.FIELD_UNDEFINED) {
            normalized.setMillisecond(DatatypeConstants.FIELD_UNDEFINED);
        }
        
        return normalized;
!!!5410715.java!!!	normalizeToTimezone(in timezone : int) : XMLGregorianCalendar

	int minutes = timezone;    	
	XMLGregorianCalendar result = (XMLGregorianCalendar) this.clone();
	
	// normalizing to UTC time negates the timezone offset before 
	// addition.
	minutes = -minutes;
	Duration d = new DurationImpl(minutes >= 0, // isPositive
				  0, //years
				  0, //months
				  0, //days
				  0, //hours
				  minutes < 0 ? -minutes : minutes, // absolute
				  0  //seconds
				  );
	result.add(d);

	// set to zulu UTC time.
	result.setTimezone(0);
	return result;
!!!5410843.java!!!	internalCompare(inout P : XMLGregorianCalendar, inout Q : XMLGregorianCalendar) : int

	int result;

	// compare Year.
	if (P.getEon() == Q.getEon()) {
	    
	    // Eon field is only equal when null.
	    // optimized case for comparing year not requiring eon field.
	    result = compareField(P.getYear(), Q.getYear());
	    if (result != DatatypeConstants.EQUAL) {
		return result;
	    }
	} else {
	    result = compareField(P.getEonAndYear(), Q.getEonAndYear());
	    if (result != DatatypeConstants.EQUAL) {
		return result;
	    }
	}

	result = compareField(P.getMonth(), Q.getMonth());
	if (result != DatatypeConstants.EQUAL) {
	    return result;
	}

	result = compareField(P.getDay(), Q.getDay());
	if (result != DatatypeConstants.EQUAL) {
	    return result;
	}

	result = compareField(P.getHour(), Q.getHour());
	if (result != DatatypeConstants.EQUAL) {
	    return result;
	}
	
	result = compareField(P.getMinute(), Q.getMinute());
	if (result != DatatypeConstants.EQUAL) {
		return result;
	}
	result = compareField(P.getSecond(), Q.getSecond());
	if (result != DatatypeConstants.EQUAL) {
		return result;
	}
	
	result = compareField(P.getFractionalSecond(), Q.getFractionalSecond());
	return result;
!!!5410971.java!!!	compareField(in Pfield : int, in Qfield : int) : int
	if (Pfield == Qfield) {

	    //fields are either equal in value or both undefined.
	    // Step B. 1.1 AND optimized result of performing 1.1-1.4.
	    return DatatypeConstants.EQUAL;
	} else {
	    if (Pfield == DatatypeConstants.FIELD_UNDEFINED || Qfield == DatatypeConstants.FIELD_UNDEFINED) {
		// Step B. 1.2
		return DatatypeConstants.INDETERMINATE;
	    } else {
		// Step B. 1.3-4.
		return (Pfield < Qfield ? DatatypeConstants.LESSER : DatatypeConstants.GREATER);
	    }
	}
!!!5411099.java!!!	compareField(inout Pfield : BigInteger, inout Qfield : BigInteger) : int
	if (Pfield == null) {
	    return (Qfield == null ? DatatypeConstants.EQUAL : DatatypeConstants.INDETERMINATE);
	}
	if (Qfield == null) {
	    return DatatypeConstants.INDETERMINATE;
	}
	return Pfield.compareTo(Qfield);
!!!5411227.java!!!	compareField(inout Pfield : BigDecimal, inout Qfield : BigDecimal) : int
	// optimization. especially when both arguments are null.
	if (Pfield == Qfield) {
	    return DatatypeConstants.EQUAL;
	}

	if (Pfield == null) {
	    Pfield = DECIMAL_ZERO;
	}

	if (Qfield == null) {
	    Qfield = DECIMAL_ZERO;
	}
	
	return Pfield.compareTo(Qfield);
!!!5411355.java!!!	equals(inout obj : Object) : boolean
	   boolean result = false;
	   if (obj instanceof XMLGregorianCalendar) {
	       result = compare((XMLGregorianCalendar) obj) == DatatypeConstants.EQUAL;
	   }
	   return result;
!!!5411483.java!!!	hashCode() : int

	// Following two dates compare to EQUALS since in different timezones.
	// 2000-01-15T12:00:00-05:00 == 2000-01-15T13:00:00-04:00 	
	//
	// Must ensure both instances generate same hashcode by normalizing 
	// this to UTC timezone.
	int timezone = getTimezone();
	if (timezone == DatatypeConstants.FIELD_UNDEFINED){
	    timezone = 0;
	}
	XMLGregorianCalendar gc = this;
	if (timezone != 0) {
	    gc = this.normalizeToTimezone(getTimezone());
	}
	return gc.getYear() + gc.getMonth() + gc.getDay() + 
	    gc.getHour() + gc.getMinute() + gc.getSecond();
!!!5411611.java!!!	parse(in lexicalRepresentation : String) : XMLGregorianCalendar
    	
		return new XMLGregorianCalendarImpl(lexicalRepresentation);
!!!5411739.java!!!	toXMLFormat() : String
    	
	QName typekind = getXMLSchemaType();
	
	String formatString = null;
	if (typekind == DatatypeConstants.DATETIME) {
	    formatString = "%Y-%M-%DT%h:%m:%s"+ "%z";
	} else if (typekind == DatatypeConstants.DATE) {
	    // Fix 4971612: invalid SCCS macro substitution in data string
	    formatString = "%Y-%M-%D" +"%z";
	} else if (typekind == DatatypeConstants.TIME) {
	    formatString = "%h:%m:%s"+ "%z";
	} else if (typekind == DatatypeConstants.GMONTH) {
	    formatString = "--%M--%z";
	} else if (typekind == DatatypeConstants.GDAY) {
	    // Fix 4971612: invalid SCCS macro substitution in data string
	    formatString = "---%D" + "%z";
	} else if (typekind == DatatypeConstants.GYEAR) {
	    formatString = "%Y" + "%z";
	} else if (typekind == DatatypeConstants.GYEARMONTH) {
	    // Fix 4971612: invalid SCCS macro substitution in data string
	    formatString = "%Y-%M" + "%z";
	} else if (typekind == DatatypeConstants.GMONTHDAY) {
	    // Fix 4971612: invalid SCCS macro substitution in data string
	    formatString = "--%M-%D" +"%z";
	}
	return format(formatString);
!!!5411867.java!!!	getXMLSchemaType() : QName
    	
    	// DATETIME
    	if (year != DatatypeConstants.FIELD_UNDEFINED
    		&& month != DatatypeConstants.FIELD_UNDEFINED
			&& day != DatatypeConstants.FIELD_UNDEFINED
			&& hour != DatatypeConstants.FIELD_UNDEFINED
			&& minute != DatatypeConstants.FIELD_UNDEFINED
			&& second != DatatypeConstants.FIELD_UNDEFINED) {
    		return DatatypeConstants.DATETIME;
    	}

    	// DATE
    	if (year != DatatypeConstants.FIELD_UNDEFINED
    		&& month != DatatypeConstants.FIELD_UNDEFINED
			&& day != DatatypeConstants.FIELD_UNDEFINED
			&& hour == DatatypeConstants.FIELD_UNDEFINED
			&& minute == DatatypeConstants.FIELD_UNDEFINED
			&& second == DatatypeConstants.FIELD_UNDEFINED) {
    		return DatatypeConstants.DATE;
    	}

    	// TIME
    	if (year == DatatypeConstants.FIELD_UNDEFINED
    		&& month == DatatypeConstants.FIELD_UNDEFINED
			&& day == DatatypeConstants.FIELD_UNDEFINED
			&& hour != DatatypeConstants.FIELD_UNDEFINED
			&& minute != DatatypeConstants.FIELD_UNDEFINED
			&& second != DatatypeConstants.FIELD_UNDEFINED) {
    		return DatatypeConstants.TIME;
    	}


    	// GYEARMONTH
    	if (year != DatatypeConstants.FIELD_UNDEFINED
    		&& month != DatatypeConstants.FIELD_UNDEFINED
			&& day == DatatypeConstants.FIELD_UNDEFINED
			&& hour == DatatypeConstants.FIELD_UNDEFINED
			&& minute == DatatypeConstants.FIELD_UNDEFINED
			&& second == DatatypeConstants.FIELD_UNDEFINED) {
    		return DatatypeConstants.GYEARMONTH;
    	}

    	// GMONTHDAY
    	if (year == DatatypeConstants.FIELD_UNDEFINED
    		&& month != DatatypeConstants.FIELD_UNDEFINED
			&& day != DatatypeConstants.FIELD_UNDEFINED
			&& hour == DatatypeConstants.FIELD_UNDEFINED
			&& minute == DatatypeConstants.FIELD_UNDEFINED
			&& second == DatatypeConstants.FIELD_UNDEFINED) {
    		return DatatypeConstants.GMONTHDAY;
    	}

    	// GYEAR
    	if (year != DatatypeConstants.FIELD_UNDEFINED
    		&& month == DatatypeConstants.FIELD_UNDEFINED
			&& day == DatatypeConstants.FIELD_UNDEFINED
			&& hour == DatatypeConstants.FIELD_UNDEFINED
			&& minute == DatatypeConstants.FIELD_UNDEFINED
			&& second == DatatypeConstants.FIELD_UNDEFINED) {
    		return DatatypeConstants.GYEAR;
    	}

    	// GMONTH
    	if (year == DatatypeConstants.FIELD_UNDEFINED
    		&& month != DatatypeConstants.FIELD_UNDEFINED
			&& day == DatatypeConstants.FIELD_UNDEFINED
			&& hour == DatatypeConstants.FIELD_UNDEFINED
			&& minute == DatatypeConstants.FIELD_UNDEFINED
			&& second == DatatypeConstants.FIELD_UNDEFINED) {
    		return DatatypeConstants.GMONTH;
    	}

    	// GDAY
    	if (year == DatatypeConstants.FIELD_UNDEFINED
    		&& month == DatatypeConstants.FIELD_UNDEFINED
			&& day != DatatypeConstants.FIELD_UNDEFINED
			&& hour == DatatypeConstants.FIELD_UNDEFINED
			&& minute == DatatypeConstants.FIELD_UNDEFINED
			&& second == DatatypeConstants.FIELD_UNDEFINED) {
    		return DatatypeConstants.GDAY;
    	}

    	// unknown
		throw new IllegalStateException(
			this.getClass().getName()
			+ "#getXMLSchemaType() :"
            + DatatypeMessageFormatter.formatMessage(null, "InvalidXGCFields", null)
		);
!!!5411995.java!!!	isValid() : boolean
	// since setters do not allow for invalid values, 
	// (except for exceptional case of year field of zero),
	// no need to check for anything except for constraints
	// between fields. 

	//check if days in month is valid. Can be dependent on leap year.
	if (getMonth() == DatatypeConstants.FEBRUARY) {
		// years could not be set
		int maxDays = DatatypeConstants.FIELD_UNDEFINED;
		BigInteger years = getEonAndYear();
		if (years != null) {
			maxDays = maximumDayInMonthFor(getEonAndYear(), DatatypeConstants.FEBRUARY);
		} else {
			// year is undefined, allow 29 days
			maxDays = 29;
		}
	    if (getDay() > maxDays) {
		return false;
	    }
	}

	// http://www.w3.org/2001/05/xmlschema-errata#e2-45
	if (getHour() == 24) {
	    if(getMinute() != 0) {
		return false;
	    } else if (getSecond() != 0) {
		return false;
	    }
	}

	// XML Schema 1.0 specification defines year value of zero as
	// invalid. Allow this class to set year field to zero
	// since XML Schema 1.0 errata states that lexical zero will 
	// be allowed in next version and treated as 1 B.C.E.
	if (eon == null) {
	    // optimize check.
	    if (year == 0) {
		return false;
	    }
	} else {
	    BigInteger yearField = getEonAndYear();
	    if (yearField != null) {
		int result = compareField(yearField, BigInteger.ZERO);
		if (result == DatatypeConstants.EQUAL) {
		    return false;
		}
	    }
	}
	return true;
!!!5412123.java!!!	add(inout duration : Duration) : void
    	
		/*
		 * Extracted from 
		 * http://www.w3.org/TR/xmlschema-2/#adding-durations-to-dateTimes 
		 * to ensure implemented properly. See spec for definitions of methods
		 * used in algorithm.
		 * 
		 * Given a dateTime S and a duration D, specifies how to compute a 
		 * dateTime E where E is the end of the time period with start S and 
		 * duration D i.e. E = S + D.
		 * 
		 * The following is the precise specification. 
		 * These steps must be followed in the same order. 
		 * If a field in D is not specified, it is treated as if it were zero.
		 * If a field in S is not specified, it is treated in the calculation 
		 * as if it were the minimum allowed value in that field, however, 
		 * after the calculation is concluded, the corresponding field in 
		 * E is removed (set to unspecified).
		 * 
		 * Months (may be modified additionally below)
	         *  temp := S[month] + D[month]
	         *  E[month] := modulo(temp, 1, 13)
	         *  carry := fQuotient(temp, 1, 13)
		 */
	 
		boolean fieldUndefined[] = {
			false,
			false,
			false, 
			false,
			false,
			false
		};
		
		int signum = duration.getSign();
		
		int startMonth = getMonth();
		if (startMonth == DatatypeConstants.FIELD_UNDEFINED) {
		    startMonth = MIN_FIELD_VALUE[MONTH];
		    fieldUndefined[MONTH] = true;
		}
		
		BigInteger dMonths = sanitize(duration.getField(DatatypeConstants.MONTHS), signum);
		BigInteger temp = BigInteger.valueOf((long) startMonth).add(dMonths);
		setMonth(temp.subtract(BigInteger.ONE).mod(TWELVE).intValue() + 1);
		BigInteger carry =
			new BigDecimal(temp.subtract(BigInteger.ONE)).divide(new BigDecimal(TWELVE), BigDecimal.ROUND_FLOOR).toBigInteger();

		 /* Years (may be modified additionally below)
		  *  E[year] := S[year] + D[year] + carry
		  */
		BigInteger startYear = getEonAndYear();
		if (startYear == null) {
		    fieldUndefined[YEAR] = true;
		    startYear = BigInteger.ZERO;
		}
		BigInteger dYears = sanitize(duration.getField(DatatypeConstants.YEARS), signum);
		BigInteger endYear = startYear.add(dYears).add(carry);
		setYear(endYear);

		/* Zone
	         *  E[zone] := S[zone]
		 * 
		 * no-op since adding to this, not to a new end point.
		 */
	
		 /* Seconds
		  *  temp := S[second] + D[second]
		  *  E[second] := modulo(temp, 60)
		  *  carry := fQuotient(temp, 60)
		  */
		BigDecimal startSeconds;
		if (getSecond() == DatatypeConstants.FIELD_UNDEFINED) {
		    fieldUndefined[SECOND] = true;
		    startSeconds = DECIMAL_ZERO;
		} else {
		    // seconds + fractionalSeconds
		    startSeconds = getSeconds();
		}

		// Duration seconds is SECONDS + FRACTIONALSECONDS.
		BigDecimal dSeconds = DurationImpl.sanitize((BigDecimal) duration.getField(DatatypeConstants.SECONDS), signum);
		BigDecimal tempBD = startSeconds.add(dSeconds);
	    BigDecimal fQuotient = 
		    new BigDecimal(new BigDecimal(tempBD.toBigInteger()).divide(DECIMAL_SIXTY, BigDecimal.ROUND_FLOOR).toBigInteger());
	    BigDecimal endSeconds = tempBD.subtract(fQuotient.multiply(DECIMAL_SIXTY));

		carry = fQuotient.toBigInteger();
		setSecond(endSeconds.intValue());
		BigDecimal tempFracSeconds = endSeconds.subtract(new BigDecimal(BigInteger.valueOf((long) getSecond())));
		if (tempFracSeconds.compareTo(DECIMAL_ZERO) < 0) {
		    setFractionalSecond(DECIMAL_ONE.add(tempFracSeconds));
		    if (getSecond() == 0) {
				setSecond(59);
				carry = carry.subtract(BigInteger.ONE);
		    } else {
				setSecond(getSecond() - 1);
		    }
		} else {
		    setFractionalSecond(tempFracSeconds);
		}
 
		/* Minutes
	         *  temp := S[minute] + D[minute] + carry
	         *  E[minute] := modulo(temp, 60)
	         *  carry := fQuotient(temp, 60)
		 */
		int startMinutes = getMinute();
		if (startMinutes == DatatypeConstants.FIELD_UNDEFINED) {
		    fieldUndefined[MINUTE] = true;
		    startMinutes = MIN_FIELD_VALUE[MINUTE];
		}
		BigInteger dMinutes = sanitize(duration.getField(DatatypeConstants.MINUTES), signum);
		
		temp = BigInteger.valueOf(startMinutes).add(dMinutes).add(carry);
		setMinute(temp.mod(SIXTY).intValue());
		carry = new BigDecimal(temp).divide(DECIMAL_SIXTY, BigDecimal.ROUND_FLOOR).toBigInteger();

		/* Hours
	         *  temp := S[hour] + D[hour] + carry
	         *  E[hour] := modulo(temp, 24)
	         *  carry := fQuotient(temp, 24)
		 */
		int startHours = getHour();
		if (startHours == DatatypeConstants.FIELD_UNDEFINED) {
		    fieldUndefined[HOUR] = true;
		    startHours = MIN_FIELD_VALUE[HOUR];
		}
		BigInteger dHours = sanitize(duration.getField(DatatypeConstants.HOURS), signum);
		
		temp = BigInteger.valueOf(startHours).add(dHours).add(carry);
		setHour(temp.mod(TWENTY_FOUR).intValue());
		carry = new BigDecimal(temp).divide(new BigDecimal(TWENTY_FOUR), BigDecimal.ROUND_FLOOR).toBigInteger();
	
		/* Days
	     *  if S[day] > maximumDayInMonthFor(E[year], E[month])
	     *       + tempDays := maximumDayInMonthFor(E[year], E[month])
	     *  else if S[day] < 1
	     *       + tempDays := 1
	     *  else
	     *       + tempDays := S[day]
	     *  E[day] := tempDays + D[day] + carry
	     *  START LOOP
	     *       + IF E[day] < 1
	     *             # E[day] := E[day] + 
	 	 *                 maximumDayInMonthFor(E[year], E[month] - 1)
	     *             # carry := -1
	     *       + ELSE IF E[day] > maximumDayInMonthFor(E[year], E[month])
	     *             # E[day] := 
	 	 *                    E[day] - maximumDayInMonthFor(E[year], E[month])
	     *             # carry := 1
	     *       + ELSE EXIT LOOP
	     *       + temp := E[month] + carry
	     *       + E[month] := modulo(temp, 1, 13)
	     *       + E[year] := E[year] + fQuotient(temp, 1, 13)
	     *       + GOTO START LOOP
		 */
		BigInteger tempDays;
		int startDay = getDay();
		if (startDay == DatatypeConstants.FIELD_UNDEFINED) {
		    fieldUndefined[DAY] = true;
		    startDay = MIN_FIELD_VALUE[DAY];
		}
		BigInteger dDays = sanitize(duration.getField(DatatypeConstants.DAYS), signum);
	    int maxDayInMonth = maximumDayInMonthFor(getEonAndYear(), getMonth());
		if (startDay > maxDayInMonth) {
	            tempDays =  BigInteger.valueOf(maxDayInMonth);
		} else if (startDay < 1) {
		    tempDays = BigInteger.ONE;
		} else {
		    tempDays = BigInteger.valueOf(startDay);
		}
		BigInteger endDays = tempDays.add(dDays).add(carry);
		int monthCarry;
		int intTemp;
		while (true) {
		    if (endDays.compareTo(BigInteger.ONE) < 0) {
		    	// calculate days in previous month, watch for month roll over
				BigInteger mdimf = null;
				if (month >= 2) {
					mdimf = BigInteger.valueOf(maximumDayInMonthFor(getEonAndYear(), getMonth() - 1));
				} else {
					// roll over to December of previous year
					mdimf = BigInteger.valueOf(maximumDayInMonthFor(getEonAndYear().subtract(BigInteger.valueOf((long) 1)), 12));
				}
				endDays = endDays.add(mdimf);
				monthCarry = -1;
		    } else if (endDays.compareTo(BigInteger.valueOf(maximumDayInMonthFor(getEonAndYear(), getMonth()))) > 0) {
				endDays = endDays.add(BigInteger.valueOf(-maximumDayInMonthFor(getEonAndYear(), getMonth())));
				monthCarry = 1;
		    } else {
		    	break;
		    } 

		    intTemp = getMonth() + monthCarry;
		    int endMonth = (intTemp - 1) % (13 - 1);
		    int quotient;
		    if (endMonth < 0) {
				endMonth = (13 - 1) + endMonth + 1;
				quotient = new BigDecimal(intTemp - 1).divide(new BigDecimal(TWELVE), BigDecimal.ROUND_UP).intValue();
		    } else {
				quotient = (intTemp - 1) / (13 - 1);
				endMonth += 1;
		    }
		    setMonth(endMonth);
		    if (quotient != 0)  {
				setYear(getEonAndYear().add(BigInteger.valueOf(quotient)));
	    	} 
		}
		setDay(endDays.intValue());
	
        // set fields that where undefined before this addition, back to undefined.
		for (int i = YEAR; i <= SECOND; i++) {
		    if (fieldUndefined[i]) {
				switch (i) {
				case YEAR:
				    setYear(DatatypeConstants.FIELD_UNDEFINED);
				    break;
				case MONTH:
				    setMonth(DatatypeConstants.FIELD_UNDEFINED);
				    break;
				case DAY:
				    setDay(DatatypeConstants.FIELD_UNDEFINED);
				    break;
				case HOUR:
				    setHour(DatatypeConstants.FIELD_UNDEFINED);
				    break;
				case MINUTE:
				    setMinute(DatatypeConstants.FIELD_UNDEFINED);
				    break;
				case SECOND:
				    setSecond(DatatypeConstants.FIELD_UNDEFINED);
				    setFractionalSecond(null);
				    break;
				}
		    }
		}
!!!5412251.java!!!	maximumDayInMonthFor(inout year : BigInteger, in month : int) : int
	if (month != DatatypeConstants.FEBRUARY) {
	    return daysInMonth[month];
	} else {
	    if (year.mod(FOUR_HUNDRED).equals(BigInteger.ZERO) || 
		(!year.mod(HUNDRED).equals(BigInteger.ZERO) &&
		 year.mod(FOUR).equals(BigInteger.ZERO))) {
		// is a leap year.
		return 29;
	    } else {
		return daysInMonth[month];
	    }
	}
!!!5412379.java!!!	maximumDayInMonthFor(in year : int, in month : int) : int
	if (month != DatatypeConstants.FEBRUARY) {
	    return daysInMonth[month];
	} else {
	    if ( ((year %400) == 0) || 
		 ( ((year % 100) != 0) && ((year % 4) == 0))) {
		// is a leap year.
		return 29;
	    } else {
		return daysInMonth[DatatypeConstants.FEBRUARY];
	    }
	}
!!!5412507.java!!!	toGregorianCalendar() : GregorianCalendar

	GregorianCalendar result = null;
	final int DEFAULT_TIMEZONE_OFFSET = DatatypeConstants.FIELD_UNDEFINED;
	TimeZone tz = getTimeZone(DEFAULT_TIMEZONE_OFFSET);
	Locale locale = java.util.Locale.getDefault();

	result = new GregorianCalendar(tz, locale);
	result.clear();
	result.setGregorianChange(PURE_GREGORIAN_CHANGE);
	
	// if year( and eon) are undefined, leave default Calendar values
	BigInteger year = getEonAndYear();
	if (year != null) {
		result.set(Calendar.ERA, year.signum() == -1 ? GregorianCalendar.BC : GregorianCalendar.AD);
		result.set(Calendar.YEAR, year.abs().intValue());
	}
	
	// only set month if it is set
	if (month != DatatypeConstants.FIELD_UNDEFINED) { 
		// Calendar.MONTH is zero based while XMLGregorianCalendar month field is not.
		result.set(Calendar.MONTH, month  - 1);
	}
	
	// only set day if it is set
	if (day != DatatypeConstants.FIELD_UNDEFINED) {
		result.set(Calendar.DAY_OF_MONTH, day);
	}
	
	// only set hour if it is set
	if (hour != DatatypeConstants.FIELD_UNDEFINED) {
		result.set(Calendar.HOUR_OF_DAY, hour);
	}
	
	// only set minute if it is set
	if (minute != DatatypeConstants.FIELD_UNDEFINED) {
		result.set(Calendar.MINUTE, minute);
	}
	
	// only set second if it is set
	if (second != DatatypeConstants.FIELD_UNDEFINED) {
		result.set(Calendar.SECOND, second);
	}
	
	// only set millisend if it is set
	if (fractionalSecond != null) {
		result.set(Calendar.MILLISECOND, getMillisecond());
	}

	return result;
!!!5412635.java!!!	toGregorianCalendar(inout timezone : TimeZone, inout aLocale : Locale, inout defaults : XMLGregorianCalendar) : GregorianCalendar
	GregorianCalendar result = null;
	TimeZone tz = timezone;
	if (tz == null) {
	    int defaultZoneoffset = DatatypeConstants.FIELD_UNDEFINED;
	    if (defaults != null) {
	    	defaultZoneoffset = defaults.getTimezone();
	    }
	    tz = getTimeZone(defaultZoneoffset);
	}
	if (aLocale == null) {
	    aLocale = java.util.Locale.getDefault();
	}
	result = new GregorianCalendar(tz, aLocale);
	result.clear();
	result.setGregorianChange(PURE_GREGORIAN_CHANGE);

	// if year( and eon) are undefined, leave default Calendar values
	BigInteger year = getEonAndYear();
	if (year != null) {
		result.set(Calendar.ERA, year.signum() == -1 ? GregorianCalendar.BC : GregorianCalendar.AD);
		result.set(Calendar.YEAR, year.abs().intValue());
	} else {
		// use default if set
		BigInteger defaultYear = (defaults != null) ? defaults.getEonAndYear() : null;
		if (defaultYear != null) {
			result.set(Calendar.ERA, defaultYear.signum() == -1 ? GregorianCalendar.BC : GregorianCalendar.AD);
			result.set(Calendar.YEAR, defaultYear.abs().intValue());
		}
	}
	
	// only set month if it is set
	if (month != DatatypeConstants.FIELD_UNDEFINED) { 
		// Calendar.MONTH is zero based while XMLGregorianCalendar month field is not.
		result.set(Calendar.MONTH, month  - 1);
	} else {
		// use default if set
		int defaultMonth = (defaults != null) ? defaults.getMonth() : DatatypeConstants.FIELD_UNDEFINED;
		if (defaultMonth != DatatypeConstants.FIELD_UNDEFINED) { 
			// Calendar.MONTH is zero based while XMLGregorianCalendar month field is not.
			result.set(Calendar.MONTH, defaultMonth  - 1);
		}
	}
		
	// only set day if it is set
	if (day != DatatypeConstants.FIELD_UNDEFINED) {
		result.set(Calendar.DAY_OF_MONTH, day);
	} else {
		// use default if set
		int defaultDay = (defaults != null) ? defaults.getDay() : DatatypeConstants.FIELD_UNDEFINED;
		if (defaultDay != DatatypeConstants.FIELD_UNDEFINED) { 
			result.set(Calendar.DAY_OF_MONTH, defaultDay);
		}
	}
	
	// only set hour if it is set
	if (hour != DatatypeConstants.FIELD_UNDEFINED) {
		result.set(Calendar.HOUR_OF_DAY, hour);
	} else {
		// use default if set
		int defaultHour = (defaults != null) ? defaults.getHour() : DatatypeConstants.FIELD_UNDEFINED;
		if (defaultHour != DatatypeConstants.FIELD_UNDEFINED) { 
			result.set(Calendar.HOUR_OF_DAY, defaultHour);
		}
	}
	
	// only set minute if it is set
	if (minute != DatatypeConstants.FIELD_UNDEFINED) {
		result.set(Calendar.MINUTE, minute);
	} else {
		// use default if set
		int defaultMinute = (defaults != null) ? defaults.getMinute() : DatatypeConstants.FIELD_UNDEFINED;
		if (defaultMinute != DatatypeConstants.FIELD_UNDEFINED) { 
			result.set(Calendar.MINUTE, defaultMinute);
		}
	}
	
	// only set second if it is set
	if (second != DatatypeConstants.FIELD_UNDEFINED) {
		result.set(Calendar.SECOND, second);
	} else {
		// use default if set
		int defaultSecond = (defaults != null) ? defaults.getSecond() : DatatypeConstants.FIELD_UNDEFINED;
		if (defaultSecond != DatatypeConstants.FIELD_UNDEFINED) { 
			result.set(Calendar.SECOND, defaultSecond);
		}
	}
	
	// only set millisend if it is set
	if (fractionalSecond != null) {
		result.set(Calendar.MILLISECOND, getMillisecond());
	} else {
		// use default if set
		BigDecimal defaultFractionalSecond = (defaults != null) ? defaults.getFractionalSecond() : null;
		if (defaultFractionalSecond != null) { 
			result.set(Calendar.MILLISECOND, defaults.getMillisecond());
		}
	}

	return result;
!!!5412763.java!!!	getTimeZone(in defaultZoneoffset : int) : TimeZone
	TimeZone result = null;
	int zoneoffset = getTimezone();

	if (zoneoffset == DatatypeConstants.FIELD_UNDEFINED) {
	    zoneoffset = defaultZoneoffset;
	}
	if (zoneoffset == DatatypeConstants.FIELD_UNDEFINED) {
	    result = TimeZone.getDefault();
	} else {
	    // zoneoffset is in minutes. Convert to custom timezone id format.
	    char sign = zoneoffset < 0 ? '-' : '+';
	    if (sign == '-') {
		zoneoffset = -zoneoffset;
	    }
	    int hour = zoneoffset / 60;
	    int minutes = zoneoffset - (hour * 60);
		
	    // Javadoc for java.util.TimeZone documents max length
	    // for customTimezoneId is 8 when optional ':' is not used.
	    // Format is 
	    // "GMT" ('-'|''+') (digit digit?) (digit digit)?
	    //                   hour          minutes
	    StringBuffer customTimezoneId = new StringBuffer(8);
	    customTimezoneId.append("GMT");
	    customTimezoneId.append(sign);
	    customTimezoneId.append(hour);
	    if (minutes != 0) {
		customTimezoneId.append(minutes);
	    }
	    result = TimeZone.getTimeZone(customTimezoneId.toString());
	}
	return result;
!!!5412891.java!!!	clone() : Object
        // Both this.eon and this.fractionalSecond are instances
        // of immutable classes, so they do not need to be cloned.
       return new XMLGregorianCalendarImpl(getEonAndYear(),
                        this.month, this.day, 
			this.hour, this.minute, this.second,
			this.fractionalSecond,
			this.timezone);
!!!5413019.java!!!	clear() : void
	eon = null;
	year = DatatypeConstants.FIELD_UNDEFINED;
	month = DatatypeConstants.FIELD_UNDEFINED;
	day = DatatypeConstants.FIELD_UNDEFINED;
	timezone = DatatypeConstants.FIELD_UNDEFINED;  // in minutes
	hour = DatatypeConstants.FIELD_UNDEFINED;
	minute = DatatypeConstants.FIELD_UNDEFINED;
	second = DatatypeConstants.FIELD_UNDEFINED;
	fractionalSecond = null;
!!!5413147.java!!!	setMillisecond(in millisecond : int) : void
	if (millisecond == DatatypeConstants.FIELD_UNDEFINED) {
	    fractionalSecond = null;
	} else {
	    checkFieldValueConstraint(MILLISECOND, millisecond);
	    fractionalSecond = new BigDecimal((long) millisecond).movePointLeft(3);
	} 
!!!5413275.java!!!	setFractionalSecond(inout fractional : BigDecimal) : void
	if (fractional != null) {
	    if ((fractional.compareTo(DECIMAL_ZERO) < 0) ||
		(fractional.compareTo(DECIMAL_ONE) > 0)) {
		throw new IllegalArgumentException(DatatypeMessageFormatter.formatMessage(null, 
            "InvalidFractional", new Object[]{fractional}));
	    }            	                             
	}
	this.fractionalSecond = fractional;
!!!5414427.java!!!	isDigit(in ch : char) : boolean
        return '0' <= ch && ch <= '9';
!!!5414555.java!!!	format(in format : String) : String
        StringBuffer buf = new StringBuffer();
        int fidx=0,flen=format.length();
        
        while(fidx<flen) {
            char fch = format.charAt(fidx++);
            if(fch!='%') {// not a meta char
                buf.append(fch);
                continue;
            }
            
            switch(format.charAt(fidx++)) {
            case 'Y':
                printNumber(buf,getEonAndYear(), 4);
                break;
            case 'M':
                printNumber(buf,getMonth(),2);
                break;
            case 'D':
                printNumber(buf,getDay(),2);
                break;
            case 'h':
                printNumber(buf,getHour(),2);
                break;
            case 'm':
                printNumber(buf,getMinute(),2);
                break;
            case 's':
                printNumber(buf,getSecond(),2);
		if (getFractionalSecond() != null) {
		    String frac = getFractionalSecond().toString();
		    //skip leading zero.
		    buf.append(frac.substring(1, frac.length()));
		} 
                break;
            case 'z':
		int offset = getTimezone();
                if(offset == 0) {
		    buf.append('Z');
		} else if (offset != DatatypeConstants.FIELD_UNDEFINED) {
		    if(offset<0) {
			buf.append('-');
			offset *= -1; 
		    } else {
			buf.append('+');
		    }
		    printNumber(buf,offset/60,2);
                    buf.append(':');
                    printNumber(buf,offset%60,2);
                }
                break;
            default:
                throw new InternalError();  // impossible
            }
        }
        
        return buf.toString();
!!!5414683.java!!!	printNumber(inout out : StringBuffer, in number : int, in nDigits : int) : void
        String s = String.valueOf(number);
        for( int i=s.length(); i<nDigits; i++ )
            out.append('0');
        out.append(s);
!!!5414811.java!!!	printNumber(inout out : StringBuffer, inout number : BigInteger, in nDigits : int) : void
        String s = number.toString();
        for( int i=s.length(); i<nDigits; i++ )
            out.append('0');
        out.append(s);
!!!5414939.java!!!	sanitize(inout value : Number, in signum : int) : BigInteger
        if (signum == 0 || value == null) {
            return BigInteger.ZERO;
        }
        return (signum <  0)? ((BigInteger)value).negate() : (BigInteger)value;
!!!5415067.java!!!	reset() : void
        //PENDING : Implementation of reset method  
