class DefaultMBeanServerInterceptor
!!!3158939.java!!!	DefaultMBeanServerInterceptor(in domain : String, inout outer : MBeanServer, inout delegate : MBeanServerDelegate, inout instantiator : MBeanInstantiator)
        this(outer, delegate, instantiator, null, 
	     new RepositorySupport((domain==null?ServiceName.DOMAIN:domain))); 
!!!3159067.java!!!	DefaultMBeanServerInterceptor(inout outer : MBeanServer, inout delegate : MBeanServerDelegate, inout instantiator : MBeanInstantiator, inout metadata : MetaData, inout repository : Repository)
	if (outer == null) throw new 
	    IllegalArgumentException("outer MBeanServer cannot be null");
	if (delegate == null) throw new 
	    IllegalArgumentException("MBeanServerDelegate cannot be null");
	if (instantiator == null) throw new 
	    IllegalArgumentException("MBeanInstantiator cannot be null");
	if (metadata == null)
	    metadata = new MetaDataImpl(instantiator);
	if (repository == null) 
	    repository = new RepositorySupport(ServiceName.DOMAIN);

	this.server   = outer;
	this.delegate = delegate; 
	this.instantiator = instantiator;
	this.meta         = metadata;
	this.repository   = repository;
	this.domain       = repository.getDefaultDomain();
!!!3159195.java!!!	createMBean(in className : String, inout name : ObjectName) : ObjectInstance

	return createMBean(className, name, (Object[]) null, (String[]) null);

!!!3159323.java!!!	createMBean(in className : String, inout name : ObjectName, inout loaderName : ObjectName) : ObjectInstance

	return createMBean(className, name, loaderName, (Object[]) null,
			   (String[]) null);
!!!3159451.java!!!	createMBean(in className : String, inout name : ObjectName, inout params : Object, in signature : String) : ObjectInstance

	try {
	    return createMBean(className, name, null, true,
			       params, signature);
	} catch (InstanceNotFoundException e) {
	    /* Can only happen if loaderName doesn't exist, but we just
	       passed null, so we shouldn't get this exception.  */
	    throw new IllegalArgumentException("Unexpected exception: " + e);
	}
!!!3159579.java!!!	createMBean(in className : String, inout name : ObjectName, inout loaderName : ObjectName, inout params : Object, in signature : String) : ObjectInstance

	return createMBean(className, name, loaderName, false,
			   params, signature);
!!!3159707.java!!!	createMBean(in className : String, inout name : ObjectName, inout loaderName : ObjectName, inout withDefaultLoaderRepository : boolean, inout params : Object, in signature : String) : ObjectInstance

        ObjectName logicalName = name;
        Class theClass;

	if (className == null) {
	    final RuntimeException wrapped =
		new IllegalArgumentException("The class name cannot be null");
	    throw new RuntimeOperationsException(wrapped,
                      "Exception occured during MBean creation");
	}

	if (name != null) {
	    if (name.isPattern()) {
		final RuntimeException wrapped =
		    new IllegalArgumentException("Invalid name->" +
						 name.toString());
		final String msg = "Exception occurred during MBean creation";
		throw new RuntimeOperationsException(wrapped, msg);
	    }

	    name = nonDefaultDomain(name);
	}

	/* Permission check */
	checkMBeanPermission(className, null, null, "instantiate");
	checkMBeanPermission(className, null, name, "registerMBean");

	/* Load the appropriate class. */
	if (withDefaultLoaderRepository) {
	    if (isTraceOn()) {
		trace(dbgTag, "createMBean", "ClassName = " + className +
		      ",ObjectName = " + name);
	    }
	    theClass =
		instantiator.findClassWithDefaultLoaderRepository(className);
	} else if (loaderName == null) {
	    if (isTraceOn()) {
		trace(dbgTag, "createMBean", "ClassName = " + className +
		      ",ObjectName = " + name + " Loader name = null");
	    }

	    theClass = instantiator.findClass(className,
				  server.getClass().getClassLoader());
	} else {
	    loaderName = nonDefaultDomain(loaderName);

	    if (isTraceOn()) {
                trace(dbgTag, "createMBean", "ClassName = " + className +
		      ",ObjectName = " + name + ",Loader name = "+
		      loaderName.toString());
            }

	    theClass = instantiator.findClass(className, loaderName);
	}

	/* Permission check */
	checkMBeanTrustPermission(theClass);

	// Check that the MBean can be instantiated by the MBeanServer.
	instantiator.testCreation(theClass);

	// Check the JMX compliance of the class
	meta.testCompliance(theClass);

	Object moi= instantiator.instantiate(theClass, params,  signature,
					     server.getClass().getClassLoader());

	final String infoClassName;
	try {
	    infoClassName = meta.getMBeanClassName(moi);
	} catch (IntrospectionException e) {
	    throw new NotCompliantMBeanException(e.getMessage());
	} 

	return registerCreatedObject(infoClassName, moi, name);
!!!3159835.java!!!	registerMBean(inout object : Object, inout name : ObjectName) : ObjectInstance

	// ------------------------------
	// ------------------------------
        Class theClass = object.getClass();

        // Check the JMX compliance of the class
        meta.testCompliance(theClass);

	/* Permission check */
	final String infoClassName;
	try {
	    infoClassName = meta.getMBeanClassName(object);
	} catch (IntrospectionException e) {
	    throw new NotCompliantMBeanException(e.getMessage());
	} 

	checkMBeanPermission(infoClassName, null, name, "registerMBean");
	checkMBeanTrustPermission(theClass);

	return registerObject(infoClassName, object, name);
!!!3159963.java!!!	unregisterMBean(inout name : ObjectName) : void
        Object object;

        if (name == null) {
	    final RuntimeException wrapped =
		new IllegalArgumentException("Object name cannot be null");
            throw new RuntimeOperationsException(wrapped,
                      "Exception occured trying to unregister the MBean");
        }

	name = nonDefaultDomain(name);

	/* Permission check */
        Object instance = getMBean(name);
	String classname = null;
	try {
	    classname = meta.getMBeanClassName(instance);
	} catch (IntrospectionException e) {
	    classname = null;
	} catch (NotCompliantMBeanException e) {
	    classname = null;
	}
	checkMBeanPermission(classname, null, name, "unregisterMBean");

	/* We synchronize here to be sure that the preDeregister
	   method will be invoked exactly once, even if more than one
	   thread unregisters the MBean at the same time.  */
        synchronized(this) {
            object = repository.retrieve(name);
            if (object==null) {
                if (isTraceOn()) {
                    trace("unregisterMBean", name+": Found no object");
                }
                throw new InstanceNotFoundException(name.toString());
            }
            if (object instanceof MBeanRegistration) {
                meta.preDeregisterInvoker(object);
            }
            // Let the repository do the work.
            try {
		repository.remove(name);
            }
            catch (InstanceNotFoundException e) {
                throw e;
            }

	    /**
	     * Checks if the unregistered MBean is a ClassLoader
	     * If so, it removes the  MBean from the default loader repository.
	     */

            if (object instanceof ClassLoader
		&& object != server.getClass().getClassLoader()) {
		final ModifiableClassLoaderRepository clr =
		    instantiator.getClassLoaderRepository();
		if (clr != null) clr.removeClassLoader(name);
	    }
	}

	// ---------------------
	// Send deletion event
	// ---------------------
	if (isTraceOn()) {
	    trace("unregisterMBean", "Send delete notification of object "
		  + name.getCanonicalName());
	}
	sendNotification(MBeanServerNotification.UNREGISTRATION_NOTIFICATION,
			 name);

	if (object instanceof MBeanRegistration) {
	    meta.postDeregisterInvoker(object);
	}
!!!3160091.java!!!	getObjectInstance(inout name : ObjectName) : ObjectInstance

	name = nonDefaultDomain(name);
        Object obj = getMBean(name);
	final String className;
	try {
	    className = meta.getMBeanClassName(obj);
	} catch (IntrospectionException x) {
	    debugX("getObjectInstance",x);
	    throw new JMRuntimeException("Can't obtain class name for " +
					 name + ": " + x);
	} catch (NotCompliantMBeanException x) {
	    debugX("getObjectInstance",x);
	    throw new JMRuntimeException("Can't obtain class name for " +
					 name + ": " + x);
	}

	/* Permission check */
	checkMBeanPermission(className, null, name, "getObjectInstance");

	return new ObjectInstance(name, className);
!!!3160219.java!!!	queryMBeans(inout name : ObjectName, inout query : QueryExp) : Set
	/* Permission check */
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    // Check if the caller has the right to invoke 'queryMBeans'
	    //
	    checkMBeanPermission(null, null, null, "queryMBeans");

	    // Perform query without "query".
	    //
	    Set list = queryMBeansImpl(name, null);

	    // Check if the caller has the right to invoke 'queryMBeans'
	    // on each specific classname/objectname in the list.
	    //
	    Set allowedList = new HashSet(list.size());
	    for (Iterator i = list.iterator(); i.hasNext(); ) {
		try {
		    ObjectInstance oi = (ObjectInstance) i.next();
		    checkMBeanPermission(oi.getClassName(), null,
					 oi.getObjectName(), "queryMBeans");
		    allowedList.add(oi);
		} catch (SecurityException e) {
		    // OK: Do not add this ObjectInstance to the list
		}
	    }

	    // Apply query to allowed MBeans only.
	    //
            return filterListOfObjectInstances(allowedList, query);
	} else {
	    // Perform query.
	    //
	    return queryMBeansImpl(name, query);
	}
!!!3160347.java!!!	queryMBeansImpl(inout name : ObjectName, inout query : QueryExp) : Set
	// Query the MBeans on the repository
	//
        Set list = null;
        synchronized(this) {
            list = repository.query(name, query);
        }
        // The repository performs the filtering
	//
        if (queryByRepo) {
	    return list;
	} else {
            // The filtering will be performed by the MBeanServer
	    //
            return (filterListOfObjects(list, query));
        }
!!!3160475.java!!!	queryNames(inout name : ObjectName, inout query : QueryExp) : Set
	/* Permission check */
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    // Check if the caller has the right to invoke 'queryNames'
	    //
	    checkMBeanPermission(null, null, null, "queryNames");

	    // Perform query without "query".
	    //
	    Set list = queryMBeansImpl(name, null);

	    // Check if the caller has the right to invoke 'queryNames'
	    // on each specific classname/objectname in the list.
	    //
	    Set allowedList = new HashSet(list.size());
	    for (Iterator i = list.iterator(); i.hasNext(); ) {
		try {
		    ObjectInstance oi = (ObjectInstance) i.next();
		    checkMBeanPermission(oi.getClassName(), null,
					 oi.getObjectName(), "queryNames");
		    allowedList.add(oi);
		} catch (SecurityException e) {
		    // OK: Do not add this ObjectInstance to the list
		}
	    }

	    // Apply query to allowed MBeans only.
	    //
	    Set queryList = filterListOfObjectInstances(allowedList, query);
	    Set result = new HashSet(queryList.size());
	    for (Iterator i = queryList.iterator(); i.hasNext(); ) {
		ObjectInstance oi = (ObjectInstance) i.next();
		result.add(oi.getObjectName());
	    }
	    return result;
	} else {
	    // Perform query.
	    //
	    Set queryList = queryMBeansImpl(name, query);
	    Set result = new HashSet(queryList.size());
	    for (Iterator i = queryList.iterator(); i.hasNext(); ) {
		ObjectInstance oi = (ObjectInstance) i.next();
		result.add(oi.getObjectName());
	    }
	    return result;
	}
!!!3160603.java!!!	isRegistered(inout name : ObjectName) : boolean
        if (name == null) {
            throw new RuntimeOperationsException(
		     new IllegalArgumentException("Object name cannot be null"),
		     "Object name cannot be null");
        }

	name = nonDefaultDomain(name);

//  	/* Permission check */
//  	checkMBeanPermission(null, null, name, "isRegistered");

        synchronized(this) {
            return (repository.contains(name));
        }
!!!3160731.java!!!	getDomains() : String
	/* Permission check */
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    // Check if the caller has the right to invoke 'getDomains'
	    //
	    checkMBeanPermission(null, null, null, "getDomains");
	    
	    // Return domains
	    //
	    String[] domains = repository.getDomains();

	    // Check if the caller has the right to invoke 'getDomains'
	    // on each specific domain in the list.
	    //
	    ArrayList result = new ArrayList(domains.length);
	    for (int i = 0; i < domains.length; i++) {
		try {
		    ObjectName domain = new ObjectName(domains[i] + ":x=x");
		    checkMBeanPermission(null, null, domain, "getDomains");
		    result.add(domains[i]);
		} catch (MalformedObjectNameException e) {
		    // Should never occur... But let's log it just in case.
		    error("getDomains",
			  "Failed to check permission for domain=" + 
			  domains[i] + ". Error is: " + e);
		    debugX("getDomains",e);
		} catch (SecurityException e) {
		    // OK: Do not add this domain to the list
		}
	    }

	    // Make an array from result.
	    //
	    return (String[]) result.toArray(new String[result.size()]);
	} else {
	    return repository.getDomains();
	}
!!!3160859.java!!!	getMBeanCount() : Integer
        return (repository.getCount());
!!!3160987.java!!!	getAttribute(inout name : ObjectName, in attribute : String) : Object

        if (name == null) {
            throw new RuntimeOperationsException(new
		IllegalArgumentException("Object name cannot be null"),
                "Exception occured trying to invoke the getter on the MBean");
        }
        if (attribute == null) {
            throw new RuntimeOperationsException(new
		IllegalArgumentException("Attribute cannot be null"),
                "Exception occured trying to invoke the getter on the MBean");
        }

	name = nonDefaultDomain(name);
	
        if (isTraceOn()) {
            trace("getAttribute", "Attribute= " + attribute +
		  ", obj= " + name);
        }

	/* Permission check */
        Object instance = getMBean(name);
	String classname = null;
	try {
	    classname = meta.getMBeanClassName(instance);
	} catch (IntrospectionException e) {
	    classname = null;
	} catch (NotCompliantMBeanException e) {
	    classname = null;
	}
	checkMBeanPermission(classname, attribute, name, "getAttribute");

        return meta.getAttribute(instance, attribute);
!!!3161115.java!!!	getAttributes(inout name : ObjectName, in attributes : String) : AttributeList

        if (name == null) {
            throw new RuntimeOperationsException(new
		IllegalArgumentException("ObjectName name cannot be null"),
                "Exception occured trying to invoke the getter on the MBean");
        }

        if (attributes == null) {
            throw new RuntimeOperationsException(new
		IllegalArgumentException("Attributes cannot be null"),
                "Exception occured trying to invoke the getter on the MBean");
        }

	name = nonDefaultDomain(name);

        if (isTraceOn()) {
            trace("getAttributes", "Object= " + name);
        }

	Object instance = getMBean(name);
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    /* Permission check */
	    String classname = null;
	    try {
		classname = meta.getMBeanClassName(instance);
	    } catch (IntrospectionException e) {
		classname = null;
	    } catch (NotCompliantMBeanException e) {
		classname = null;
	    }

	    // Check if the caller has the right to invoke 'getAttribute'
	    //
	    checkMBeanPermission(classname, null, name, "getAttribute");

	    // Check if the caller has the right to invoke 'getAttribute'
	    // on each specific attribute
	    //
	    ArrayList allowedList = new ArrayList(attributes.length);
	    for (int i = 0; i < attributes.length; i++) {
		try {
		    checkMBeanPermission(classname, attributes[i],
					 name, "getAttribute");
		    allowedList.add(attributes[i]);
		} catch (SecurityException e) {
		    // OK: Do not add this attribute to the list
		}
	    }
	    String[] allowedAttributes =
		(String[]) allowedList.toArray(new String[0]);
	    return meta.getAttributes(instance, allowedAttributes);
	} else {
	    return meta.getAttributes(instance, attributes);
	}
!!!3161243.java!!!	setAttribute(inout name : ObjectName, inout attribute : Attribute) : void

        if (name == null) {
            throw new RuntimeOperationsException(new
		IllegalArgumentException("ObjectName name cannot be null"),
                "Exception occured trying to invoke the setter on the MBean");
        }

        if (attribute == null) {
            throw new RuntimeOperationsException(new
		IllegalArgumentException("Attribute cannot be null"),
                "Exception occured trying to invoke the setter on the MBean");
        }

	name = nonDefaultDomain(name);

        if (isTraceOn()) {
            trace("setAttribute", "Object= " + name + ", attribute=" +
		  attribute.getName());
        }

	/* Permission check */
        Object instance = getMBean(name);
	String classname = null;
	try {
	    classname = meta.getMBeanClassName(instance);
	} catch (IntrospectionException e) {
	    classname = null;
	} catch (NotCompliantMBeanException e) {
	    classname = null;
	}
	checkMBeanPermission(classname, attribute.getName(),
			     name, "setAttribute");

        final Object o = meta.setAttribute(instance, attribute);
!!!3161371.java!!!	setAttributes(inout name : ObjectName, inout attributes : AttributeList) : AttributeList

        if (name == null) {
            throw new RuntimeOperationsException(new
		IllegalArgumentException("ObjectName name cannot be null"),
		"Exception occured trying to invoke the setter on the MBean");
        }

        if (attributes == null) {
            throw new RuntimeOperationsException(new
            IllegalArgumentException("AttributeList  cannot be null"),
	    "Exception occured trying to invoke the setter on the MBean");
        }

	name = nonDefaultDomain(name);

	Object instance = getMBean(name);
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    /* Permission check */
	    String classname = null;
	    try {
		classname = meta.getMBeanClassName(instance);
	    } catch (IntrospectionException e) {
		classname = null;
	    } catch (NotCompliantMBeanException e) {
		classname = null;
	    }

	    // Check if the caller has the right to invoke 'setAttribute'
	    //
	    checkMBeanPermission(classname, null, name, "setAttribute");

	    // Check if the caller has the right to invoke 'setAttribute'
	    // on each specific attribute
	    //
	    AttributeList allowedAttributes =
		new AttributeList(attributes.size());
	    for (Iterator i = attributes.iterator(); i.hasNext();) {
		try {
		    Attribute attribute = (Attribute) i.next();
		    checkMBeanPermission(classname, attribute.getName(),
					 name, "setAttribute");
		    allowedAttributes.add(attribute);
		} catch (SecurityException e) {
		    // OK: Do not add this attribute to the list
		}
	    }
	    return meta.setAttributes(instance, allowedAttributes);
	} else {
	    return meta.setAttributes(instance, attributes);
	}
!!!3161499.java!!!	invoke(inout name : ObjectName, in operationName : String, inout params : Object, in signature : String) : Object

	name = nonDefaultDomain(name);

	/* Permission check */
        Object instance = getMBean(name);
	String classname = null;
	try {
	    classname = meta.getMBeanClassName(instance);
	} catch (IntrospectionException e) {
	    classname = null;
	} catch (NotCompliantMBeanException e) {
	    classname = null;
	}
	checkMBeanPermission(classname, operationName, name, "invoke");

        return meta.invoke(instance, operationName, params, signature);
!!!3161627.java!!!	meta() : MetaData
	return meta;
!!!3161755.java!!!	makeObjectInstance(in className : String, inout object : Object, inout name : ObjectName) : ObjectInstance

	// if the MBean is a dynamic MBean ask its MBeanInfo for the
	// class name
	if (object instanceof DynamicMBean) {
	    try {
		className = meta.getMBeanClassName(object);
	    } catch (SecurityException x) {
		debugX("makeObjectInstance",x);
		throw x;
	    } catch (IntrospectionException x) {
		debugX("makeObjectInstance",x);
		throw new NotCompliantMBeanException(
			   "Can't obtain class name for " + name + ": " + x);
	    } catch (JMRuntimeException x) {
		debugX("makeObjectInstance",x);
		throw new NotCompliantMBeanException(
			   "Can't obtain class name for " + name + ": " + x);
	    }
	}

	if (className == null) {
	    throw new NotCompliantMBeanException(
			     "The class Name returned is null");
	}

        return(new ObjectInstance(nonDefaultDomain(name), className));
!!!3161883.java!!!	registerObject(in classname : String, inout object : Object, inout name : ObjectName) : ObjectInstance
      
        if (object == null) {
	    final RuntimeException wrapped =
		new IllegalArgumentException("Cannot add null object");
            throw new RuntimeOperationsException(wrapped,
                        "Exception occured trying to register the MBean");
        }

	name = nonDefaultDomain(name);

        if (isTraceOn()) {
            trace(dbgTag, "registerMBean", "ObjectName = " + name);
        }
	
	ObjectName logicalName = name;

        if (object instanceof MBeanRegistration) {
            logicalName = meta.preRegisterInvoker(object, name, server);
	    if (logicalName != name && logicalName != null) {
		logicalName =
		    ObjectName.getInstance(nonDefaultDomain(logicalName));
	    }
        }

	/* Permission check */
	checkMBeanPermission(classname, null, logicalName, "registerMBean");

	final ObjectInstance result;
        if (logicalName!=null) {
	    result = makeObjectInstance(classname, object, logicalName);
            internal_addObject(object, logicalName);
        } else {
            if (object instanceof MBeanRegistration ) {
                meta.postRegisterInvoker(object, false);
            }
	    final RuntimeException wrapped =
		new IllegalArgumentException("No object name specified");
            throw new RuntimeOperationsException(wrapped,
                        "Exception occured trying to register the MBean");
        }

        if (object instanceof MBeanRegistration)
            meta.postRegisterInvoker(object, true);

        /**
         * Checks if the newly registered MBean is a ClassLoader
	 * If so, tell the ClassLoaderRepository (CLR) about it.  We do
	 * this even if the object is a PrivateClassLoader.  In that
	 * case, the CLR remembers the loader for use when it is
	 * explicitly named (e.g. as the loader in createMBean) but
	 * does not add it to the list that is consulted by
	 * ClassLoaderRepository.loadClass.
         */
        if (object instanceof ClassLoader) {
	    final ModifiableClassLoaderRepository clr =
		instantiator.getClassLoaderRepository();
	    if (clr == null) {
		final RuntimeException wrapped =
		    new IllegalArgumentException(
		     "Dynamic addition of class loaders is not supported");
		throw new RuntimeOperationsException(wrapped,
	   "Exception occured trying to register the MBean as a class loader");
	    }
	    clr.addClassLoader(logicalName, (ClassLoader)object);
        }

	return result;
!!!3162011.java!!!	registerCreatedObject(in classname : String, inout object : Object, inout name : ObjectName) : ObjectInstance
	return registerObject(classname,object,name);
!!!3162139.java!!!	getMBean(inout name : ObjectName) : Object

        if (name == null) {
            throw new RuntimeOperationsException(new
		IllegalArgumentException("Object name cannot be null"),
			       "Exception occured trying to get an MBean");
        }
        Object obj = null;
        synchronized(this) {
            obj = repository.retrieve(name);
            if (obj == null) {
		if (isTraceOn()) {
		    trace("getMBean", name+": Found no object");
		}
		throw new InstanceNotFoundException(name.toString());
            }
        }
        return obj;
!!!3162267.java!!!	nonDefaultDomain(inout name : ObjectName) : ObjectName
	if (name == null || name.getDomain().length() > 0)
	    return name;

	/* The ObjectName looks like ":a=b", and that's what its
	   toString() will return in this implementation.  So
	   we can just stick the default domain in front of it
	   to get a non-default-domain name.  We depend on the
	   fact that toString() works like that and that it
	   leaves wildcards in place (so we can detect an error
	   if one is supplied where it shouldn't be).  */
	final String completeName = domain + name;

	try {
	    return new ObjectName(completeName);
	} catch (MalformedObjectNameException e) {
	    final String msg =
		"Unexpected default domain problem: " + completeName + ": " +
		e;
	    throw new IllegalArgumentException(msg);
	}
!!!3162395.java!!!	getDefaultDomain() : String
        return domain;
!!!3162523.java!!!	addNotificationListener(inout name : ObjectName, inout listener : NotificationListener, inout filter : NotificationFilter, inout handback : Object) : void

	// ------------------------------
	// ------------------------------
        if (isTraceOn()) {
            trace("addNotificationListener", "obj= " + name);
        }

	/* Permission check */
        Object instance = getMBean(name);
	String classname = null;
	try {
	    classname = meta.getMBeanClassName(instance);
	} catch (IntrospectionException e) {
	    classname = null;
	} catch (NotCompliantMBeanException e) {
	    classname = null;
	}
	checkMBeanPermission(classname, null, name, "addNotificationListener");

        NotificationBroadcaster broadcaster;

	if (!(instance instanceof NotificationBroadcaster)) {
            throw new RuntimeOperationsException(new
		IllegalArgumentException(name.getCanonicalName() ),
                "The MBean " + name.getCanonicalName() +
                " does not implement the NotificationBroadcaster interface");
        }
	broadcaster = (NotificationBroadcaster) instance;

        // ------------------
        // Check listener
        // ------------------
        if (listener == null) {
	    throw new RuntimeOperationsException(new
		IllegalArgumentException("Null listener"),"Null listener");
	}

	NotificationListener listenerWrapper =
	    getListenerWrapper(listener, name, instance, true);
	broadcaster.addNotificationListener(listenerWrapper, filter, handback);
!!!3162651.java!!!	addNotificationListener(inout name : ObjectName, inout listener : ObjectName, inout filter : NotificationFilter, inout handback : Object) : void

	// ------------------------------
	// ------------------------------

        // ----------------
        // Get listener object
        // ----------------
        Object instance = getMBean(listener);
        if (!(instance instanceof NotificationListener)) {
	    throw new RuntimeOperationsException(new
		IllegalArgumentException(listener.getCanonicalName()),
		"The MBean " + listener.getCanonicalName() +
		"does not implement the NotificationListener interface") ;
        }

        // ----------------
        // Add a listener on an MBean
        // ----------------
        if (isTraceOn()) {
            trace("addNotificationListener", "obj= " + name + " listener= " +
		  listener);
        }
        server.addNotificationListener(name,(NotificationListener) instance,
				       filter, handback) ;
!!!3162779.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : NotificationListener) : void
	removeNotificationListener(name, listener, null, null, true);
!!!3162907.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : NotificationListener, inout filter : NotificationFilter, inout handback : Object) : void
	removeNotificationListener(name, listener, filter, handback, false);
!!!3163035.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : ObjectName) : void
	NotificationListener instance = getListener(listener);

        if (isTraceOn()) {
            trace("removeNotificationListener", "obj= " + name +
		  " listener= " + listener);
        }
	server.removeNotificationListener(name, instance);
!!!3163163.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : ObjectName, inout filter : NotificationFilter, inout handback : Object) : void

	NotificationListener instance = getListener(listener);

        if (isTraceOn()) {
            trace("removeNotificationListener", "obj= " + name +
		  " listener= " + listener);
        }
	server.removeNotificationListener(name, instance, filter, handback);
!!!3163291.java!!!	getListener(inout listener : ObjectName) : NotificationListener
        // ----------------
        // Get listener object
        // ----------------
        final Object instance;
        try {
	    instance = getMBean(listener);
	} catch (InstanceNotFoundException e) {
	    throw new ListenerNotFoundException(e.getMessage()) ;
	}

        if (!(instance instanceof NotificationListener)) {
	    final RuntimeException exc =
		new IllegalArgumentException(listener.getCanonicalName());
	    final String msg =
		"MBean " + listener.getCanonicalName() + " does not " +
		"implement " + NotificationListener.class.getName();
            throw new RuntimeOperationsException(exc, msg);
        }
	return (NotificationListener) instance;
!!!3163419.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : NotificationListener, inout filter : NotificationFilter, inout handback : Object, inout removeAll : boolean) : void

        if (isTraceOn()) {
            trace("removeNotificationListener", "obj= " + name);
        }

	/* Permission check */
        Object instance = getMBean(name);
	String classname = null;
	try {
	    classname = meta.getMBeanClassName(instance);
	} catch (IntrospectionException e) {
	    classname = null;
	} catch (NotCompliantMBeanException e) {
	    classname = null;
	}
	checkMBeanPermission(classname, null, name,
			     "removeNotificationListener");

	/* We could simplify the code by assigning broadcaster after
	   assigning listenerWrapper, but that would change the error
	   behaviour when both the broadcaster and the listener are
	   erroneous.  */
        NotificationBroadcaster broadcaster = null;
	NotificationEmitter emitter = null;
	if (removeAll) {
	    if (!(instance instanceof NotificationBroadcaster)) {
		final RuntimeException exc =
		    new IllegalArgumentException(name.getCanonicalName());
		final String msg =
		    "MBean " + name.getCanonicalName() + " does not " +
		    "implement " + NotificationBroadcaster.class.getName();
		throw new RuntimeOperationsException(exc, msg);
	    }
	    broadcaster = (NotificationBroadcaster) instance;
	} else {
	    if (!(instance instanceof NotificationEmitter)) {
		final RuntimeException exc =
		    new IllegalArgumentException(name.getCanonicalName());
		final String msg =
		    "MBean " + name.getCanonicalName() + " does not " +
		    "implement " + NotificationEmitter.class.getName();
		throw new RuntimeOperationsException(exc, msg);
	    }
	    emitter = (NotificationEmitter) instance;
	}

	NotificationListener listenerWrapper =
	    getListenerWrapper(listener, name, instance, false);

        if (listenerWrapper == null)
            throw new ListenerNotFoundException("Unknown listener");

	if (removeAll)
	    broadcaster.removeNotificationListener(listenerWrapper);
	else {
	    emitter.removeNotificationListener(listenerWrapper,
					       filter,
					       handback);
	}
!!!3163547.java!!!	getMBeanInfo(inout name : ObjectName) : MBeanInfo

	// ------------------------------
	// ------------------------------

        Object moi = getMBean(name);
	final MBeanInfo mbi = meta.getMBeanInfo(moi);
	if (mbi == null)
	    throw new JMRuntimeException("MBean " + name +
					 "has no MBeanInfo");

	/* Permission check */
	checkMBeanPermission(mbi.getClassName(), null, name, "getMBeanInfo");

	return mbi;
!!!3163675.java!!!	isInstanceOf(inout name : ObjectName, in className : String) : boolean

	/* Permission check */
        Object instance = getMBean(name);
	String classname = null;
	try {
	    classname = meta.getMBeanClassName(instance);
	} catch (IntrospectionException e) {
	    classname = null;
	} catch (NotCompliantMBeanException e) {
	    classname = null;
	}
	checkMBeanPermission(classname, null, name, "isInstanceOf");

	try {
	    return meta.isInstanceOf(instance, className);
	} catch (ReflectionException e) {
	    debugX("isInstanceOf",e);
	    return false;
	}
!!!3163803.java!!!	getClassLoaderFor(inout mbeanName : ObjectName) : ClassLoader

	/* Permission check */
        Object instance = getMBean(mbeanName);
	String classname = null;
	try {
	    classname = meta.getMBeanClassName(instance);
	} catch (IntrospectionException e) {
	    classname = null;
	} catch (NotCompliantMBeanException e) {
	    classname = null;
	}
	checkMBeanPermission(classname, null, mbeanName, "getClassLoaderFor");

	return instance.getClass().getClassLoader();
!!!3163931.java!!!	getClassLoader(inout loaderName : ObjectName) : ClassLoader

	if (loaderName == null) {
	    checkMBeanPermission(null, null, null, "getClassLoader");
	    return server.getClass().getClassLoader();
	}

        Object instance = getMBean(loaderName);
	String classname = null;
	try {
	    classname = meta.getMBeanClassName(instance);
	} catch (IntrospectionException e) {
	    classname = null;
	} catch (NotCompliantMBeanException e) {
	    classname = null;
	}
	checkMBeanPermission(classname, null, loaderName, "getClassLoader");

	/* Check if the given MBean is a ClassLoader */
	if (!(instance instanceof ClassLoader))
	    throw new InstanceNotFoundException(loaderName.toString() +
                                                " is not a classloader");

	return (ClassLoader) instance;
!!!3164059.java!!!	internal_addObject(inout object : Object, inout logicalName : ObjectName) : void

	// ------------------------------
	// ------------------------------

        // Let the repository do the work.

        synchronized(this) {
            try {
                repository.addMBean(object, logicalName);
            }
            catch (InstanceAlreadyExistsException e) {
                if (object instanceof MBeanRegistration ) {
                    meta.postRegisterInvoker(object,false);
                }
                throw e;
            }
        }
        // ---------------------
        // Send create event
        // ---------------------
        if (isTraceOn()) {
            trace("addObject", "Send create notification of object " +
		  logicalName.getCanonicalName());
        }

        sendNotification(MBeanServerNotification.REGISTRATION_NOTIFICATION,
			 logicalName ) ;
!!!3164187.java!!!	sendNotification(in NotifType : String, inout name : ObjectName) : void

	// ------------------------------
	// ------------------------------

        // ---------------------
        // Create notification
        // ---------------------
	MBeanServerNotification notif = new
	    MBeanServerNotification(NotifType,_MBSDelegateObjectName,0,name);

	if (isTraceOn()) {
	    trace("sendNotification", NotifType + " " + name);
	}

	delegate.sendNotification(notif);
!!!3164315.java!!!	initialize(in domain : String, inout outer : MBeanServer, inout delegate : MBeanServerDelegate, inout inst : MBeanInstantiator, inout meta : MetaData, inout repos : Repository) : void

	// ------------------------------
	// ------------------------------

	if (!this.domain.equals(repository.getDefaultDomain()))
	    throw new IllegalArgumentException("Domain Name Mismatch");
        try {
            queryByRepo = repository.isFiltering();
        } catch (SecurityException e) {
	    throw e;
        } catch (Exception e) {
            queryByRepo = false;
        }
!!!3164443.java!!!	filterListOfObjects(inout list : Set, inout query : QueryExp) : Set
        Set result = new HashSet();

        // No query ...
        if (query == null ) {
            for (final Iterator i  = list.iterator(); i.hasNext(); ) {
                final NamedObject no = (NamedObject) i.next();
		final Object obj = no.getObject();
		String className = null;

		try {
		    className = meta.getMBeanClassName(obj);
		} catch (JMException x) {
		    if (isDebugOn()) {
			debug("filterListOfObjects",
			      "Can't obtain class name for " +
			      no.getName() + ": " + x);
			debugX("filterListOfObjects",x);
		    }
		}

		result.add(new ObjectInstance(no.getName(), className));
            }
        } else {
            // Access the filter
            for (final Iterator i  = list.iterator(); i.hasNext(); ) {
                final NamedObject no = (NamedObject) i.next();
                final Object obj = no.getObject();
                boolean res = false;
		MBeanServer oldServer = QueryEval.getMBeanServer();
		query.setMBeanServer(server);
                try {
                    res = query.apply(no.getName());
                } catch (Exception e) {
                    res = false;
                } finally {
		    /*
		     * query.setMBeanServer is probably
		     * QueryEval.setMBeanServer so put back the old
		     * value.  Since that method uses a ThreadLocal
		     * variable, this code is only needed for the
		     * unusual case where the user creates a custom
		     * QueryExp that calls a nested query on another
		     * MBeanServer.
		     */
		    query.setMBeanServer(oldServer);
		}
                if (res) {
		    // if the MBean is a dynamic MBean ask its MBeanInfo
		    // for the class name
		    String className = null;
		    try {
			className = meta.getMBeanClassName(obj);
		    } catch (JMException x) {
			if (isDebugOn()) {
			    debug("filterListOfObjects",
				  "Can't obtain class name for " +
				  no.getName() + ": " + x);
			    debugX("filterListOfObjects",x);
			}
		    }
		    result.add(new ObjectInstance(no.getName(), className));
                }
            }
        }
	return result;
!!!3164571.java!!!	filterListOfObjectInstances(inout list : Set, inout query : QueryExp) : Set
        // Null query.
	//
        if (query == null) {
	    return list;
        } else {
	    Set result = new HashSet();
            // Access the filter.
	    //
            for (final Iterator i = list.iterator(); i.hasNext(); ) {
		final ObjectInstance oi = (ObjectInstance) i.next();
                boolean res = false;
		MBeanServer oldServer = QueryEval.getMBeanServer();
		query.setMBeanServer(server);
                try {
                    res = query.apply(oi.getObjectName());
                } catch (Exception e) {
                    res = false;
                } finally {
		    /*
		     * query.setMBeanServer is probably
		     * QueryEval.setMBeanServer so put back the old
		     * value.  Since that method uses a ThreadLocal
		     * variable, this code is only needed for the
		     * unusual case where the user creates a custom
		     * QueryExp that calls a nested query on another
		     * MBeanServer.
		     */
		    query.setMBeanServer(oldServer);
		}
                if (res) {
		    result.add(oi);
                }
            }
	    return result;
        }
!!!3164699.java!!!	getListenerWrapper(inout l : NotificationListener, inout name : ObjectName, inout mbean : Object, inout create : boolean) : NotificationListener
	NotificationListener wrapper = new ListenerWrapper(l, name, mbean);
	synchronized (listenerWrappers) {
	    WeakReference ref = (WeakReference) listenerWrappers.get(wrapper);
	    if (ref != null) {
		NotificationListener existing =
		    (NotificationListener) ref.get();
		if (existing != null)
		    return existing;
	    }
	    if (create) {
		listenerWrappers.put(wrapper, new WeakReference(wrapper));
		return wrapper;
	    } else
		return null;
	}
!!!3165467.java!!!	checkMBeanPermission(in classname : String, in member : String, inout objectName : ObjectName, in actions : String) : void
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    Permission perm = new MBeanPermission(classname,
						  member,
						  objectName,
						  actions);
	    sm.checkPermission(perm);
	}
!!!3165595.java!!!	checkMBeanTrustPermission(in theClass : Class) : void
	SecurityManager sm = System.getSecurityManager();
	if (sm != null) {
	    Permission perm = new MBeanTrustPermission("register");
	    ProtectionDomain pd = (ProtectionDomain)
		AccessController.doPrivileged(new PrivilegedAction() {
		    public Object run() {
			return theClass.getProtectionDomain();
		    }
		});
	    AccessControlContext acc =
		new AccessControlContext(new ProtectionDomain[] { pd });
	    sm.checkPermission(perm, acc);
	}
!!!3165723.java!!!	isTraceOn() : boolean
        return Trace.isSelected(Trace.LEVEL_TRACE, Trace.INFO_MBEANSERVER);
!!!3165851.java!!!	trace(in clz : String, in func : String, in info : String) : void
        Trace.send(Trace.LEVEL_TRACE, Trace.INFO_MBEANSERVER, clz, func, info);
!!!3165979.java!!!	trace(in func : String, in info : String) : void
        trace(dbgTag, func, info);
!!!3166107.java!!!	error(in func : String, in info : String) : void
        Trace.send(Trace.LEVEL_ERROR,Trace.INFO_MBEANSERVER,dbgTag,func,info);
!!!3166235.java!!!	isDebugOn() : boolean
        return Trace.isSelected(Trace.LEVEL_DEBUG, Trace.INFO_MBEANSERVER);
!!!3166363.java!!!	debug(in clz : String, in func : String, in info : String) : void
        Trace.send(Trace.LEVEL_DEBUG, Trace.INFO_MBEANSERVER, clz, func, info);
!!!3166491.java!!!	debug(in func : String, in info : String) : void
        debug(dbgTag, func, info);
!!!3166619.java!!!	debugX(in func : String, inout e : Throwable) : void
	if (isDebugOn()) {
	    final StringWriter s = new StringWriter();
	    e.printStackTrace(new PrintWriter(s));
	    final String stack = s.toString();

	    debug(dbgTag,func,"Exception caught in "+ func+"(): "+e);
	    debug(dbgTag,func,stack);

	    // java.lang.System.err.println("**** Exception caught in "+
	    //				 func+"(): "+e);
	    // java.lang.System.err.println(stack);
	}
