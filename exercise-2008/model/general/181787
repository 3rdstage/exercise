format 66
"locks" // src::java::util::concurrent::locks
  revision 3
  modified_by 27 "3rdstage"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  java_dir "java/util/concurrent/locks"
  java_package "java.util.concurrent.locks"
  classview 176539 "locks"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    class 989211 "ReentrantLock"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "A reentrant mutual exclusion {@link Lock} with the same basic
behavior and semantics as the implicit monitor lock accessed using
<tt>synchronized</tt> methods and statements, but with extended
capabilities.

<p> A <tt>ReentrantLock</tt> is <em>owned</em> by the thread last
successfully locking, but not yet unlocking it. A thread invoking
<tt>lock</tt> will return, successfully acquiring the lock, when
the lock is not owned by another thread. The method will return
immediately if the current thread already owns the lock. This can
be checked using methods {@link #isHeldByCurrentThread}, and {@link
#getHoldCount}.  

<p> The constructor for this class accepts an optional
<em>fairness</em> parameter.  When set <tt>true</tt>, under
contention, locks favor granting access to the longest-waiting
thread.  Otherwise this lock does not guarantee any particular
access order.  Programs using fair locks accessed by many threads
may display lower overall throughput (i.e., are slower; often much
slower) than those using the default setting, but have smaller
variances in times to obtain locks and guarantee lack of
starvation. Note however, that fairness of locks does not guarantee
fairness of thread scheduling. Thus, one of many threads using a
fair lock may obtain it multiple times in succession while other
active threads are not progressing and not currently holding the
lock.
Also note that the untimed {@link #tryLock() tryLock} method does not
honor the fairness setting. It will succeed if the lock
is available even if other threads are waiting.

<p> It is recommended practice to <em>always</em> immediately
follow a call to <tt>lock</tt> with a <tt>try</tt> block, most
typically in a before/after construction such as:

<pre>
class X {
  private final ReentrantLock lock = new ReentrantLock();
  // ...

  public void m() { 
    lock.lock();  // block until condition holds
    try {
      // ... method body
    } finally {
      lock.unlock()
    }
  }
}
</pre>

<p>In addition to implementing the {@link Lock} interface, this
class defines methods <tt>isLocked</tt> and
<tt>getLockQueueLength</tt>, as well as some associated
<tt>protected</tt> access methods that may be useful for
instrumentation and monitoring.

<p> Serialization of this class behaves in the same way as built-in
locks: a deserialized lock is in the unlocked state, regardless of
its state when serialized.

<p> This lock supports a maximum of 2147483648 recursive locks by
the same thread. 

@since 1.5
@author Doug Lea
"
      classrelation 1923739 // <realization>
	relation 1923739 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 1923739 // <realization>
	  b parent class_ref 990363 // Lock
      end

      classrelation 1923867 // <realization>
	relation 1923867 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 1923867 // <realization>
	  b parent class_ref 137883 // Serializable
      end

      attribute 2923035 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value "=  7373984872572414699L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      class 990491 "Sync"
	abstract visibility package 
	cpp_decl ""
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 1925787 // <generalisation>
	  relation 1925787 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 1925787 // <generalisation>
	    b parent class_ref 990619 // AbstractQueuedSynchronizer
	end

	classrelation 1925915 // owner (<unidirectional association>)
	  relation 1925915 --->
	    a role_name "owner" package
	      comment " Current owner thread 
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1925915 // owner (<unidirectional association>)
	    b parent class_ref 163227 // Thread
	end

	operation 7891483 "lock"
	  abstract package explicit_return_type "void"
	  nparams 0
	  
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Perform {@link Lock#lock}. The main reason for subclassing
is to allow fast path for nonfair version."
	end

	operation 7891611 "nonfairTryAcquire"
	  package explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Perform non-fair tryLock.  tryAcquire is
implemented in subclasses, but both need nonfair
try for trylock method"
	end

	operation 7891739 "tryRelease"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "releases" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7891867 "isHeldExclusively"
	  protected explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7891995 "newCondition"
	  package return_type class_ref 990875 // ConditionObject
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7892123 "getOwner"
	  package return_type class_ref 163227 // Thread
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Methods relayed from outer class"
	end

	operation 7892251 "getHoldCount"
	  package explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7892379 "isLocked"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7892507 "readObject"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "s" type class_ref 201115 // ObjectInputStream
	  nexceptions 2
	    exception class_ref 179355 // IOException
	    exception class_ref 201883 // ClassNotFoundException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Reconstitute this lock instance from a stream
@param s the stream"
	end
      end

      classrelation 1923995 // sync (<unidirectional association>)
	relation 1923995 --->
	  a role_name "sync" const_relation private
	    comment " Synchronizer providing all implementation mechanics 
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 1923995 // sync (<unidirectional association>)
	  b parent class_ref 990491 // Sync
      end

      class 991003 "NonfairSync"
	visibility package 
	cpp_decl ""
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 1926043 // <generalisation>
	  relation 1926043 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 1926043 // <generalisation>
	    b parent class_ref 990491 // Sync
	end

	operation 7892635 "lock"
	  package explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Perform lock.  Try immediate barge, backing up to normal
acquire on failure."
	end

	operation 7892763 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      class 991131 "FairSync"
	visibility package 
	cpp_decl ""
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 1926171 // <generalisation>
	  relation 1926171 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 1926171 // <generalisation>
	    b parent class_ref 990491 // Sync
	end

	operation 7892891 "lock"
	  package explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7893019 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Fair version of tryAcquire.  Don't grant access unless
recursive call or no waiters or is first."
	end
      end

      operation 7893147 "ReentrantLock"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates an instance of <tt>ReentrantLock</tt>.
This is equivalent to using <tt>ReentrantLock(false)</tt>."
      end

      operation 7893275 "ReentrantLock"
	public explicit_return_type ""
	nparams 1
	  param inout name "fair" explicit_type "boolean"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates an instance of <tt>ReentrantLock</tt> with the
given fairness policy.
@param fair true if this lock will be fair; else false"
      end

      operation 7893403 "lock"
	public explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock. 

<p>Acquires the lock if it is not held by another thread and returns 
immediately, setting the lock hold count to one.

<p>If the current thread
already holds the lock then the hold count is incremented by one and
the method returns immediately.

<p>If the lock is held by another thread then the
current thread becomes disabled for thread scheduling 
purposes and lies dormant until the lock has been acquired,
at which time the lock hold count is set to one. "
      end

      operation 7893531 "lockInterruptibly"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock unless the current thread is 
{@link Thread#interrupt interrupted}.

<p>Acquires the lock if it is not held by another thread and returns 
immediately, setting the lock hold count to one.

<p>If the current thread already holds this lock then the hold count 
is incremented by one and the method returns immediately.

<p>If the lock is held by another thread then the
current thread becomes disabled for thread scheduling 
purposes and lies dormant until one of two things happens:

<ul>

<li>The lock is acquired by the current thread; or

<li>Some other thread {@link Thread#interrupt interrupts} the current
thread.

</ul>

<p>If the lock is acquired by the current thread then the lock hold 
count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or 

<li>is {@link Thread#interrupt interrupted} while acquiring 
the lock,

</ul>

then {@link InterruptedException} is thrown and the current thread's 
interrupted status is cleared. 

<p>In this implementation, as this method is an explicit interruption 
point, preference is 
given to responding to the interrupt over normal or reentrant 
acquisition of the lock.

@throws InterruptedException if the current thread is interrupted"
      end

      operation 7893659 "tryLock"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock only if it is not held by another thread at the time
of invocation.

<p>Acquires the lock if it is not held by another thread and
returns immediately with the value <tt>true</tt>, setting the
lock hold count to one. Even when this lock has been set to use a
fair ordering policy, a call to <tt>tryLock()</tt> <em>will</em>
immediately acquire the lock if it is available, whether or not
other threads are currently waiting for the lock. 
This &quot;barging&quot; behavior can be useful in certain 
circumstances, even though it breaks fairness. If you want to honor
the fairness setting for this lock, then use 
{@link #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }
which is almost equivalent (it also detects interruption).

<p> If the current thread
already holds this lock then the hold count is incremented by one and
the method returns <tt>true</tt>.

<p>If the lock is held by another thread then this method will return 
immediately with the value <tt>false</tt>.  

@return <tt>true</tt> if the lock was free and was acquired by the
current thread, or the lock was already held by the current thread; and
<tt>false</tt> otherwise."
      end

      operation 7893787 "tryLock"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "timeout" explicit_type "long"
	  param inout name "unit" type class_ref 988315 // TimeUnit
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock if it is not held by another thread within the given 
waiting time and the current thread has not been 
{@link Thread#interrupt interrupted}.

<p>Acquires the lock if it is not held by another thread and returns 
immediately with the value <tt>true</tt>, setting the lock hold count 
to one. If this lock has been set to use a fair ordering policy then
an available lock <em>will not</em> be acquired if any other threads
are waiting for the lock. This is in contrast to the {@link #tryLock()}
method. If you want a timed <tt>tryLock</tt> that does permit barging on
a fair lock then combine the timed and un-timed forms together:

<pre>if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }
</pre>

<p>If the current thread
already holds this lock then the hold count is incremented by one and
the method returns <tt>true</tt>.

<p>If the lock is held by another thread then the
current thread becomes disabled for thread scheduling 
purposes and lies dormant until one of three things happens:

<ul>

<li>The lock is acquired by the current thread; or

<li>Some other thread {@link Thread#interrupt interrupts} the current
thread; or

<li>The specified waiting time elapses

</ul>

<p>If the lock is acquired then the value <tt>true</tt> is returned and
the lock hold count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or 

<li>is {@link Thread#interrupt interrupted} while acquiring
the lock,

</ul>
then {@link InterruptedException} is thrown and the current thread's 
interrupted status is cleared. 

<p>If the specified waiting time elapses then the value <tt>false</tt>
is returned.
If the time is 
less than or equal to zero, the method will not wait at all.

<p>In this implementation, as this method is an explicit interruption 
point, preference is 
given to responding to the interrupt over normal or reentrant 
acquisition of the lock, and over reporting the elapse of the waiting
time.

@param timeout the time to wait for the lock
@param unit the time unit of the timeout argument

@return <tt>true</tt> if the lock was free and was acquired by the
current thread, or the lock was already held by the current thread; and
<tt>false</tt> if the waiting time elapsed before the lock could be 
acquired.

@throws InterruptedException if the current thread is interrupted
@throws NullPointerException if unit is null
"
      end

      operation 7893915 "unlock"
	public explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to release this lock.  

<p>If the current thread is the
holder of this lock then the hold count is decremented. If the
hold count is now zero then the lock is released.  If the
current thread is not the holder of this lock then {@link
IllegalMonitorStateException} is thrown.
@throws IllegalMonitorStateException if the current thread does not
hold this lock."
      end

      operation 7894043 "newCondition"
	public return_type class_ref 989339 // Condition
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a {@link Condition} instance for use with this 
{@link Lock} instance.

<p>The returned {@link Condition} instance supports the same
usages as do the {@link Object} monitor methods ({@link
Object#wait() wait}, {@link Object#notify notify}, and {@link
Object#notifyAll notifyAll}) when used with the built-in
monitor lock.

<ul>

<li>If this lock is not held when any of the {@link Condition}
{@link Condition#await() waiting} or {@link Condition#signal
signalling} methods are called, then an {@link
IllegalMonitorStateException} is thrown.

<li>When the condition {@link Condition#await() waiting}
methods are called the lock is released and, before they
return, the lock is reacquired and the lock hold count restored
to what it was when the method was called.

<li>If a thread is {@link Thread#interrupt interrupted} while
waiting then the wait will terminate, an {@link
InterruptedException} will be thrown, and the thread's
interrupted status will be cleared.

<li> Waiting threads are signalled in FIFO order

<li>The ordering of lock reacquisition for threads returning
from waiting methods is the same as for threads initially
acquiring the lock, which is in the default case not specified,
but for <em>fair</em> locks favors those threads that have been
waiting the longest.

</ul>

@return the Condition object"
      end

      operation 7894171 "getHoldCount"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of holds on this lock by the current thread.

<p>A thread has a hold on a lock for each lock action that is not 
matched by an unlock action.

<p>The hold count information is typically only used for testing and
debugging purposes. For example, if a certain section of code should
not be entered with the lock already held then we can assert that
fact:

<pre>
class X {
  ReentrantLock lock = new ReentrantLock();
  // ...     
  public void m() { 
    assert lock.getHoldCount() == 0;
    lock.lock();
    try {
      // ... method body
    } finally {
      lock.unlock();
    }
  }
}
</pre>

@return the number of holds on this lock by the current thread,
or zero if this lock is not held by the current thread."
      end

      operation 7894299 "isHeldByCurrentThread"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if this lock is held by the current thread.

<p>Analogous to the {@link Thread#holdsLock} method for built-in
monitor locks, this method is typically used for debugging and
testing. For example, a method that should only be called while
a lock is held can assert that this is the case:

<pre>
class X {
  ReentrantLock lock = new ReentrantLock();
  // ...

  public void m() { 
      assert lock.isHeldByCurrentThread();
      // ... method body
  }
}
</pre>

<p>It can also be used to ensure that a reentrant lock is used
in a non-reentrant manner, for example:

<pre>
class X {
  ReentrantLock lock = new ReentrantLock();
  // ...

  public void m() { 
      assert !lock.isHeldByCurrentThread();
      lock.lock();
      try {
          // ... method body
      } finally {
          lock.unlock();
      }
  }
}
</pre>
@return <tt>true</tt> if current thread holds this lock and 
<tt>false</tt> otherwise."
      end

      operation 7894427 "isLocked"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if this lock is held by any thread. This method is
designed for use in monitoring of the system state, 
not for synchronization control.
@return <tt>true</tt> if any thread holds this lock and 
<tt>false</tt> otherwise."
      end

      operation 7894555 "isFair"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if this lock has fairness set true.
@return true if this lock has fairness set true."
      end

      operation 7894683 "getOwner"
	protected return_type class_ref 163227 // Thread
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the thread that currently owns this lock, or
<tt>null</tt> if not owned. Note that the owner may be
momentarily <tt>null</tt> even if there are threads trying to
acquire the lock but have not yet done so.  This method is
designed to facilitate construction of subclasses that provide
more extensive lock monitoring facilities.
@return the owner, or <tt>null</tt> if not owned."
      end

      operation 7894811 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting to acquire this lock. Note that
because cancellations may occur at any time, a <tt>true</tt>
return does not guarantee that any other thread will ever
acquire this lock.  This method is designed primarily for use in
monitoring of the system state.

@return true if there may be other threads waiting to acquire
the lock."
      end

      operation 7894939 "hasQueuedThread"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 163227 // Thread
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether the given thread is waiting to acquire this
lock. Note that because cancellations may occur at any time, a
<tt>true</tt> return does not guarantee that this thread
will ever acquire this lock.  This method is designed primarily for use
in monitoring of the system state.

@param thread the thread
@return true if the given thread is queued waiting for this lock.
@throws NullPointerException if thread is null"
      end

      operation 7895067 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting to
acquire this lock.  The value is only an estimate because the number of
threads may change dynamically while this method traverses
internal data structures.  This method is designed for use in
monitoring of the system state, not for synchronization
control.
@return the estimated number of threads waiting for this lock"
      end

      operation 7895195 "getQueuedThreads"
	protected return_type class_ref 135067 // Collection
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire this lock.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive monitoring facilities.
@return the collection of threads"
      end

      operation 7895323 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 989339 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with this lock. Note that because timeouts and
interrupts may occur at any time, a <tt>true</tt> return does
not guarantee that a future <tt>signal</tt> will awaken any
threads.  This method is designed primarily for use in
monitoring of the system state.
@param condition the condition
@return <tt>true</tt> if there are any waiting threads.
@throws IllegalMonitorStateException if this lock 
is not held
@throws IllegalArgumentException if the given condition is
not associated with this lock
@throws NullPointerException if condition null"
      end

      operation 7895451 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 989339 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with this lock. Note that because
timeouts and interrupts may occur at any time, the estimate
serves only as an upper bound on the actual number of waiters.
This method is designed for use in monitoring of the system
state, not for synchronization control.
@param condition the condition
@return the estimated number of waiting threads.
@throws IllegalMonitorStateException if this lock 
is not held
@throws IllegalArgumentException if the given condition is
not associated with this lock
@throws NullPointerException if condition null"
      end

      operation 7895579 "getWaitingThreads"
	protected return_type class_ref 135067 // Collection
	nparams 1
	  param inout name "condition" type class_ref 989339 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with this lock.
Because the actual set of threads may change dynamically while
constructing this result, the returned collection is only a
best-effort estimate. The elements of the returned collection
are in no particular order.  This method is designed to
facilitate construction of subclasses that provide more
extensive condition monitoring facilities.
@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if this lock 
is not held
@throws IllegalArgumentException if the given condition is
not associated with this lock
@throws NullPointerException if condition null"
      end

      operation 7895707 "toString"
	public explicit_return_type "String"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this lock, as well as its lock
state.  The state, in brackets, includes either the String
&quot;Unlocked&quot; or the String &quot;Locked by&quot;
followed by the {@link Thread#getName} of the owning thread.
@return a string identifying this lock, as well as its lock state."
      end
    end

    class 989339 "Condition"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "<tt>Condition</tt> factors out the <tt>Object</tt> monitor
methods ({@link Object#wait() wait}, {@link Object#notify notify}
and {@link Object#notifyAll notifyAll}) into distinct objects to
give the effect of having multiple wait-sets per object, by
combining them with the use of arbitrary {@link Lock} implementations.
Where a <tt>Lock</tt> replaces the use of <tt>synchronized</tt> methods
and statements, a <tt>Condition</tt> replaces the use of the Object
monitor methods.

<p>Conditions (also known as <em>condition queues</em> or
<em>condition variables</em>) provide a means for one thread to
suspend execution (to &quot;wait&quot;) until notified by another
thread that some state condition may now be true.  Because access
to this shared state information occurs in different threads, it
must be protected, so a lock of some form is associated with the
condition. The key property that waiting for a condition provides
is that it <em>atomically</em> releases the associated lock and
suspends the current thread, just like <tt>Object.wait</tt>.

<p>A <tt>Condition</tt> instance is intrinsically bound to a lock.
To obtain a <tt>Condition</tt> instance for a particular {@link Lock} 
instance use its {@link Lock#newCondition newCondition()} method.

<p>As an example, suppose we have a bounded buffer which supports
<tt>put</tt> and <tt>take</tt> methods.  If a
<tt>take</tt> is attempted on an empty buffer, then the thread will block
until an item becomes available; if a <tt>put</tt> is attempted on a
full buffer, then the thread will block until a space becomes available.
We would like to keep waiting <tt>put</tt> threads and <tt>take</tt>
threads in separate wait-sets so that we can use the optimization of
only notifying a single thread at a time when items or spaces become
available in the buffer. This can be achieved using two 
{@link Condition} instances.
<pre>
class BoundedBuffer {
  <b>final Lock lock = new ReentrantLock();</b>
  final Condition notFull  = <b>lock.newCondition(); </b>
  final Condition notEmpty = <b>lock.newCondition(); </b>

  final Object[] items = new Object[100];
  int putptr, takeptr, count;

  public void put(Object x) throws InterruptedException {
    <b>lock.lock();
    try {</b>
      while (count == items.length) 
        <b>notFull.await();</b>
      items[putptr] = x; 
      if (++putptr == items.length) putptr = 0;
      ++count;
      <b>notEmpty.signal();</b>
    <b>} finally {
      lock.unlock();
    }</b>
  }

  public Object take() throws InterruptedException {
    <b>lock.lock();
    try {</b>
      while (count == 0) 
        <b>notEmpty.await();</b>
      Object x = items[takeptr]; 
      if (++takeptr == items.length) takeptr = 0;
      --count;
      <b>notFull.signal();</b>
      return x;
    <b>} finally {
      lock.unlock();
    }</b>
  } 
}
</pre>

(The {@link java.util.concurrent.ArrayBlockingQueue} class provides
this functionality, so there is no reason to implement this
sample usage class.)

<p>A <tt>Condition</tt> implementation can provide behavior and semantics 
that is 
different from that of the <tt>Object</tt> monitor methods, such as 
guaranteed ordering for notifications, or not requiring a lock to be held 
when performing notifications.
If an implementation provides such specialized semantics then the 
implementation must document those semantics.

<p>Note that <tt>Condition</tt> instances are just normal objects and can 
themselves be used as the target in a <tt>synchronized</tt> statement,
and can have their own monitor {@link Object#wait wait} and
{@link Object#notify notification} methods invoked.
Acquiring the monitor lock of a <tt>Condition</tt> instance, or using its
monitor methods, has no specified relationship with acquiring the
{@link Lock} associated with that <tt>Condition</tt> or the use of its
{@link #await waiting} and {@link #signal signalling} methods.
It is recommended that to avoid confusion you never use <tt>Condition</tt>
instances in this way, except perhaps within their own implementation.

<p>Except where noted, passing a <tt>null</tt> value for any parameter 
will result in a {@link NullPointerException} being thrown.

<h3>Implementation Considerations</h3>

<p>When waiting upon a <tt>Condition</tt>, a &quot;<em>spurious
wakeup</em>&quot; is permitted to occur, in 
general, as a concession to the underlying platform semantics.
This has little practical impact on most application programs as a
<tt>Condition</tt> should always be waited upon in a loop, testing
the state predicate that is being waited for.  An implementation is
free to remove the possibility of spurious wakeups but it is 
recommended that applications programmers always assume that they can
occur and so always wait in a loop.

<p>The three forms of condition waiting 
(interruptible, non-interruptible, and timed) may differ in their ease of 
implementation on some platforms and in their performance characteristics.
In particular, it may be difficult to provide these features and maintain 
specific semantics such as ordering guarantees. 
Further, the ability to interrupt the actual suspension of the thread may 
not always be feasible to implement on all platforms.
<p>Consequently, an implementation is not required to define exactly the 
same guarantees or semantics for all three forms of waiting, nor is it 
required to support interruption of the actual suspension of the thread.
<p>An implementation is required to
clearly document the semantics and guarantees provided by each of the 
waiting methods, and when an implementation does support interruption of 
thread suspension then it must obey the interruption semantics as defined 
in this interface.
<p>As interruption generally implies cancellation, and checks for 
interruption are often infrequent, an implementation can favor responding
to an interrupt over normal method return. This is true even if it can be
shown that the interrupt occurred after another action may have unblocked
the thread. An implementation should document this behavior. 


@since 1.5
@author Doug Lea"
      operation 7887771 "await"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or 
{@link Thread#interrupt interrupted}.

<p>The lock associated with this <tt>Condition</tt> is atomically 
released and the current thread becomes disabled for thread scheduling 
purposes and lies dormant until <em>one</em> of four things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this 
<tt>Condition</tt> and the current thread happens to be chosen as the 
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this 
<tt>Condition</tt>; or
<li>Some other thread {@link Thread#interrupt interrupts} the current
thread, and interruption of thread suspension is supported; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or 
<li>is {@link Thread#interrupt interrupted} while waiting 
and interruption of thread suspension is supported, 
</ul>
then {@link InterruptedException} is thrown and the current thread's 
interrupted status is cleared. It is not specified, in the first
case, whether or not the test for interruption occurs before the lock
is released.

<p><b>Implementation Considerations</b>
<p>The current thread is assumed to hold the lock associated with this
<tt>Condition</tt> when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be 
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.

<p>An implementation can favor responding to an interrupt over normal
method return in response to a signal. In that case the implementation
must ensure that the signal is redirected to another waiting thread, if
there is one.

@throws InterruptedException if the current thread is interrupted (and
interruption of thread suspension is supported)."
      end

      operation 7887899 "awaitUninterruptibly"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled.

<p>The lock associated with this condition is atomically 
released and the current thread becomes disabled for thread scheduling 
purposes and lies dormant until <em>one</em> of three things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this 
<tt>Condition</tt> and the current thread happens to be chosen as the 
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this 
<tt>Condition</tt>; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.

<p>If the current thread's interrupted status is set when it enters
this method, or it is {@link Thread#interrupt interrupted} 
while waiting, it will continue to wait until signalled. When it finally
returns from this method its interrupted status will still
be set.

<p><b>Implementation Considerations</b>
<p>The current thread is assumed to hold the lock associated with this
<tt>Condition</tt> when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be 
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.
"
      end

      operation 7888027 "awaitNanos"
	public explicit_return_type "long"
	nparams 1
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or interrupted,
or the specified waiting time elapses.

<p>The lock associated with this condition is atomically 
released and the current thread becomes disabled for thread scheduling 
purposes and lies dormant until <em>one</em> of five things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this 
<tt>Condition</tt> and the current thread happens to be chosen as the 
thread to be awakened; or 
<li>Some other thread invokes the {@link #signalAll} method for this 
<tt>Condition</tt>; or
<li>Some other thread {@link Thread#interrupt interrupts} the current
thread, and interruption of thread suspension is supported; or
<li>The specified waiting time elapses; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or 
<li>is {@link Thread#interrupt interrupted} while waiting 
and interruption of thread suspension is supported, 
</ul>
then {@link InterruptedException} is thrown and the current thread's 
interrupted status is cleared. It is not specified, in the first
case, whether or not the test for interruption occurs before the lock
is released.

<p>The method returns an estimate of the number of nanoseconds
remaining to wait given the supplied <tt>nanosTimeout</tt>
value upon return, or a value less than or equal to zero if it
timed out. This value can be used to determine whether and how
long to re-wait in cases where the wait returns but an awaited
condition still does not hold. Typical uses of this method take
the following form:

<pre>
synchronized boolean aMethod(long timeout, TimeUnit unit) {
  long nanosTimeout = unit.toNanos(timeout);
  while (!conditionBeingWaitedFor) {
    if (nanosTimeout &gt; 0)
        nanosTimeout = theCondition.awaitNanos(nanosTimeout);
     else
       return false;
  }
  // ... 
}
</pre>

<p> Design note: This method requires a nanosecond argument so
as to avoid truncation errors in reporting remaining times.
Such precision loss would make it difficult for programmers to
ensure that total waiting times are not systematically shorter
than specified when re-waits occur.

<p><b>Implementation Considerations</b>
<p>The current thread is assumed to hold the lock associated with this
<tt>Condition</tt> when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be 
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.

<p>An implementation can favor responding to an interrupt over normal
method return in response to a signal, or over indicating the elapse
of the specified waiting time. In either case the implementation
must ensure that the signal is redirected to another waiting thread, if
there is one.

@param nanosTimeout the maximum time to wait, in nanoseconds
@return A value less than or equal to zero if the wait has
timed out; otherwise an estimate, that
is strictly less than the <tt>nanosTimeout</tt> argument,
of the time still remaining when this method returned.

@throws InterruptedException if the current thread is interrupted (and
interruption of thread suspension is supported)."
      end

      operation 7888155 "await"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "time" explicit_type "long"
	  param inout name "unit" type class_ref 988315 // TimeUnit
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or interrupted,
or the specified waiting time elapses. This method is behaviorally
equivalent to:<br>
<pre>
  awaitNanos(unit.toNanos(time)) &gt; 0
</pre>
@param time the maximum time to wait
@param unit the time unit of the <tt>time</tt> argument.
@return <tt>false</tt> if the waiting time detectably elapsed
before return from the method, else <tt>true</tt>.
@throws InterruptedException if the current thread is interrupted (and
interruption of thread suspension is supported)."
      end

      operation 7888283 "awaitUntil"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "deadline" type class_ref 139163 // Date
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or interrupted,
or the specified deadline elapses.

<p>The lock associated with this condition is atomically 
released and the current thread becomes disabled for thread scheduling 
purposes and lies dormant until <em>one</em> of five things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this 
<tt>Condition</tt> and the current thread happens to be chosen as the 
thread to be awakened; or 
<li>Some other thread invokes the {@link #signalAll} method for this 
<tt>Condition</tt>; or
<li>Some other thread {@link Thread#interrupt interrupts} the current
thread, and interruption of thread suspension is supported; or
<li>The specified deadline elapses; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.


<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or 
<li>is {@link Thread#interrupt interrupted} while waiting 
and interruption of thread suspension is supported, 
</ul>
then {@link InterruptedException} is thrown and the current thread's 
interrupted status is cleared. It is not specified, in the first
case, whether or not the test for interruption occurs before the lock
is released.


<p>The return value indicates whether the deadline has elapsed,
which can be used as follows:
<pre>
synchronized boolean aMethod(Date deadline) {
  boolean stillWaiting = true;
  while (!conditionBeingWaitedFor) {
    if (stillwaiting)
        stillWaiting = theCondition.awaitUntil(deadline);
     else
       return false;
  }
  // ... 
}
</pre>

<p><b>Implementation Considerations</b>
<p>The current thread is assumed to hold the lock associated with this
<tt>Condition</tt> when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be 
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.

<p>An implementation can favor responding to an interrupt over normal
method return in response to a signal, or over indicating the passing
of the specified deadline. In either case the implementation
must ensure that the signal is redirected to another waiting thread, if
there is one.


@param deadline the absolute time to wait until
@return <tt>false</tt> if the deadline has
elapsed upon return, else <tt>true</tt>.

@throws InterruptedException if the current thread is interrupted (and
interruption of thread suspension is supported)."
      end

      operation 7888411 "signal"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up one waiting thread.

<p>If any threads are waiting on this condition then one
is selected for waking up. That thread must then re-acquire the
lock before returning from <tt>await</tt>."
      end

      operation 7888539 "signalAll"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up all waiting threads.

<p>If any threads are waiting on this condition then they are
all woken up. Each thread must re-acquire the lock before it can
return from <tt>await</tt>."
      end
    end

    class 990363 "Lock"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "<tt>Lock</tt> implementations provide more extensive locking
operations than can be obtained using <tt>synchronized</tt> methods
and statements.  They allow more flexible structuring, may have
quite different properties, and may support multiple associated
{@link Condition} objects.

<p>A lock is a tool for controlling access to a shared resource by
multiple threads. Commonly, a lock provides exclusive access to a
shared resource: only one thread at a time can acquire the lock and
all access to the shared resource requires that the lock be
acquired first. However, some locks may allow concurrent access to
a shared resource, such as the read lock of a {@link
ReadWriteLock}.

<p>The use of <tt>synchronized</tt> methods or statements provides 
access to the implicit monitor lock associated with every object, but
forces all lock acquisition and release to occur in a block-structured way:
when multiple locks are acquired they must be released in the opposite
order, and all locks must be released in the same lexical scope in which
they were acquired.

<p>While the scoping mechanism for <tt>synchronized</tt> methods
and statements makes it much easier to program with monitor locks,
and helps avoid many common programming errors involving locks,
there are occasions where you need to work with locks in a more
flexible way. For example, some algorithms for traversing
concurrently accessed data structures require the use of
&quot;hand-over-hand&quot; or &quot;chain locking&quot;: you
acquire the lock of node A, then node B, then release A and acquire
C, then release B and acquire D and so on.  Implementations of the
<tt>Lock</tt> interface enable the use of such techniques by
allowing a lock to be acquired and released in different scopes,
and allowing multiple locks to be acquired and released in any
order.

<p>With this increased flexibility comes additional
responsibility. The absence of block-structured locking removes the
automatic release of locks that occurs with <tt>synchronized</tt>
methods and statements. In most cases, the following idiom
should be used:

<pre><tt>     Lock l = ...; 
    l.lock();
    try {
        // access the resource protected by this lock
    } finally {
        l.unlock();
    }
</tt></pre>

When locking and unlocking occur in different scopes, care must be
taken to ensure that all code that is executed while the lock is
held is protected by try-finally or try-catch to ensure that the
lock is released when necessary.

<p><tt>Lock</tt> implementations provide additional functionality
over the use of <tt>synchronized</tt> methods and statements by
providing a non-blocking attempt to acquire a lock ({@link
#tryLock()}), an attempt to acquire the lock that can be
interrupted ({@link #lockInterruptibly}, and an attempt to acquire
the lock that can timeout ({@link #tryLock(long, TimeUnit)}).

<p>A <tt>Lock</tt> class can also provide behavior and semantics
that is quite different from that of the implicit monitor lock,
such as guaranteed ordering, non-reentrant usage, or deadlock
detection. If an implementation provides such specialized semantics
then the implementation must document those semantics.

<p>Note that <tt>Lock</tt> instances are just normal objects and can 
themselves be used as the target in a <tt>synchronized</tt> statement.
Acquiring the
monitor lock of a <tt>Lock</tt> instance has no specified relationship
with invoking any of the {@link #lock} methods of that instance. 
It is recommended that to avoid confusion you never use <tt>Lock</tt>
instances in this way, except within their own implementation.

<p>Except where noted, passing a <tt>null</tt> value for any
parameter will result in a {@link NullPointerException} being
thrown.

<h3>Memory Synchronization</h3>
<p>All <tt>Lock</tt> implementations <em>must</em> enforce the same
memory synchronization semantics as provided by the built-in monitor lock:
<ul>
<li>A successful lock operation acts like a successful 
<tt>monitorEnter</tt> action
<li>A successful <tt>unlock</tt> operation acts like a successful
<tt>monitorExit</tt> action
</ul>

Unsuccessful locking and unlocking operations, and reentrant
locking/unlocking operations, do not require any memory
synchronization effects.

<h3>Implementation Considerations</h3>

<p> The three forms of lock acquisition (interruptible,
non-interruptible, and timed) may differ in their performance
characteristics, ordering guarantees, or other implementation
qualities.  Further, the ability to interrupt the <em>ongoing</em>
acquisition of a lock may not be available in a given <tt>Lock</tt>
class.  Consequently, an implementation is not required to define
exactly the same guarantees or semantics for all three forms of
lock acquisition, nor is it required to support interruption of an
ongoing lock acquisition.  An implementation is required to clearly
document the semantics and guarantees provided by each of the
locking methods. It must also obey the interruption semantics as
defined in this interface, to the extent that interruption of lock
acquisition is supported: which is either totally, or only on
method entry.

<p>As interruption generally implies cancellation, and checks for 
interruption are often infrequent, an implementation can favor responding
to an interrupt over normal method return. This is true even if it can be
shown that the interrupt occurred after another action may have unblocked
the thread. An implementation should document this behavior. 


@see ReentrantLock
@see Condition
@see ReadWriteLock

@since 1.5
@author Doug Lea
"
      operation 7879835 "lock"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock.
<p>If the lock is not available then
the current thread becomes disabled for thread scheduling 
purposes and lies dormant until the lock has been acquired.
<p><b>Implementation Considerations</b>
<p>A <tt>Lock</tt> implementation may be able to detect 
erroneous use of the lock, such as an invocation that would cause 
deadlock, and may throw an (unchecked) exception in such circumstances. 
The circumstances and the exception type must be documented by that 
<tt>Lock</tt> implementation.
"
      end

      operation 7879963 "lockInterruptibly"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock unless the current thread is  
{@link Thread#interrupt interrupted}. 
<p>Acquires the lock if it is available and returns immediately.
<p>If the lock is not available then
the current thread becomes disabled for thread scheduling 
purposes and lies dormant until one of two things happens:
<ul>
<li>The lock is acquired by the current thread; or
<li>Some other thread {@link Thread#interrupt interrupts} the current
thread, and interruption of lock acquisition is supported.
</ul>
<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or 
<li>is {@link Thread#interrupt interrupted} while acquiring 
the lock, and interruption of lock acquisition is supported, 
</ul>
then {@link InterruptedException} is thrown and the current thread's 
interrupted status is cleared. 

<p><b>Implementation Considerations</b>

<p>The ability to interrupt a lock acquisition in some
implementations may not be possible, and if possible may be an
expensive operation.  The programmer should be aware that this
may be the case. An implementation should document when this is
the case.

<p>An implementation can favor responding to an interrupt over
normal method return.

<p>A <tt>Lock</tt> implementation may be able to detect
erroneous use of the lock, such as an invocation that would
cause deadlock, and may throw an (unchecked) exception in such
circumstances.  The circumstances and the exception type must
be documented by that <tt>Lock</tt> implementation.

@throws InterruptedException if the current thread is interrupted
while acquiring the lock (and interruption of lock acquisition is 
supported).

@see Thread#interrupt
"
      end

      operation 7880091 "tryLock"
	public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock only if it is free at the time of invocation.
<p>Acquires the lock if it is available and returns immediately
with the value <tt>true</tt>.
If the lock is not available then this method will return 
immediately with the value <tt>false</tt>.
<p>A typical usage idiom for this method would be:
<pre>
     Lock lock = ...;
     if (lock.tryLock()) {
         try {
             // manipulate protected state
         } finally {
             lock.unlock();
         }
     } else {
         // perform alternative actions
     }
</pre>
This usage ensures that the lock is unlocked if it was acquired, and
doesn't try to unlock if the lock was not acquired.

@return <tt>true</tt> if the lock was acquired and <tt>false</tt>
otherwise."
      end

      operation 7880219 "tryLock"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "time" explicit_type "long"
	  param inout name "unit" type class_ref 988315 // TimeUnit
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock if it is free within the given waiting time and the
current thread has not been {@link Thread#interrupt interrupted}.

<p>If the lock is available this method returns immediately
with the value <tt>true</tt>.
If the lock is not available then
the current thread becomes disabled for thread scheduling 
purposes and lies dormant until one of three things happens:
<ul>
<li>The lock is acquired by the current thread; or
<li>Some other thread {@link Thread#interrupt interrupts} the current
thread, and interruption of lock acquisition is supported; or
<li>The specified waiting time elapses
</ul>
<p>If the lock is acquired then the value <tt>true</tt> is returned.
<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or 
<li>is {@link Thread#interrupt interrupted} while acquiring 
the lock, and interruption of lock acquisition is supported, 
</ul>
then {@link InterruptedException} is thrown and the current thread's 
interrupted status is cleared. 
<p>If the specified waiting time elapses then the value <tt>false</tt>
is returned.
If the time is 
less than or equal to zero, the method will not wait at all.

<p><b>Implementation Considerations</b>
<p>The ability to interrupt a lock acquisition in some implementations
may not be possible, and if possible may 
be an expensive operation. 
The programmer should be aware that this may be the case. An
implementation should document when this is the case.
<p>An implementation can favor responding to an interrupt over normal 
method return, or reporting a timeout.
<p>A <tt>Lock</tt> implementation may be able to detect 
erroneous use of the lock, such as an invocation that would cause 
deadlock, and may throw an (unchecked) exception in such circumstances. 
The circumstances and the exception type must be documented by that 
<tt>Lock</tt> implementation.

@param time the maximum time to wait for the lock
@param unit the time unit of the <tt>time</tt> argument.
@return <tt>true</tt> if the lock was acquired and <tt>false</tt>
if the waiting time elapsed before the lock was acquired.

@throws InterruptedException if the current thread is interrupted
while acquiring the lock (and interruption of lock acquisition is 
supported).

@see Thread#interrupt
"
      end

      operation 7880347 "unlock"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases the lock.
<p><b>Implementation Considerations</b>
<p>A <tt>Lock</tt> implementation will usually impose
restrictions on which thread can release a lock (typically only the
holder of the lock can release it) and may throw
an (unchecked) exception if the restriction is violated.
Any restrictions and the exception
type must be documented by that <tt>Lock</tt> implementation."
      end

      operation 7880475 "newCondition"
	public return_type class_ref 989339 // Condition
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a new {@link Condition} instance that is bound to this 
<tt>Lock</tt> instance.
<p>Before waiting on the condition the lock must be held by the 
current thread. 
A call to {@link Condition#await()} will atomically release the lock 
before waiting and re-acquire the lock before the wait returns.
<p><b>Implementation Considerations</b>
<p>The exact operation of the {@link Condition} instance depends on the
<tt>Lock</tt> implementation and must be documented by that
implementation.

@return A new {@link Condition} instance for this <tt>Lock</tt> 
instance.
@throws UnsupportedOperationException if this <tt>Lock</tt> 
implementation does not support conditions."
      end
    end

    class 990619 "AbstractQueuedSynchronizer"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "Provides a framework for implementing blocking locks and related
synchronizers (semaphores, events, etc) that rely on
first-in-first-out (FIFO) wait queues.  This class is designed to
be a useful basis for most kinds of synchronizers that rely on a
single atomic <tt>int</tt> value to represent state. Subclasses
must define the protected methods that change this state, and which
define what that state means in terms of this object being acquired
or released.  Given these, the other methods in this class carry
out all queuing and blocking mechanics. Subclasses can maintain
other state fields, but only the atomically updated <tt>int</tt>
value manipulated using methods {@link #getState}, {@link
#setState} and {@link #compareAndSetState} is tracked with respect
to synchronization.

<p>Subclasses should be defined as non-public internal helper
classes that are used to implement the synchronization properties
of their enclosing class.  Class
<tt>AbstractQueuedSynchronizer</tt> does not implement any
synchronization interface.  Instead it defines methods such as
{@link #acquireInterruptibly} that can be invoked as
appropriate by concrete locks and related synchronizers to
implement their public methods. 

<p>This class supports either or both a default <em>exclusive</em>
mode and a <em>shared</em> mode. When acquired in exclusive mode,
attempted acquires by other threads cannot succeed. Shared mode
acquires by multiple threads may (but need not) succeed. This class
does not &quot;understand&quot; these differences except in the
mechanical sense that when a shared mode acquire succeeds, the next
waiting thread (if one exists) must also determine whether it can
acquire as well. Threads waiting in the different modes share the
same FIFO queue. Usually, implementation subclasses support only
one of these modes, but both can come into play for example in a
{@link ReadWriteLock}. Subclasses that support only exclusive or
only shared modes need not define the methods supporting the unused mode.

<p>This class defines a nested {@link ConditionObject} class that
can be used as a {@link Condition} implementation by subclasses
supporting exclusive mode for which method {@link
#isHeldExclusively} reports whether synchronization is exclusively
held with respect to the current thread, method {@link #release}
invoked with the current {@link #getState} value fully releases
this object, and {@link #acquire}, given this saved state value,
eventually restores this object to its previous acquired state.  No
<tt>AbstractQueuedSynchronizer</tt> method otherwise creates such a
condition, so if this constraint cannot be met, do not use it.  The
behavior of {@link ConditionObject} depends of course on the
semantics of its synchronizer implementation.

<p> This class provides inspection, instrumentation, and monitoring
methods for the internal queue, as well as similar methods for
condition objects. These can be exported as desired into classes
using an <tt>AbstractQueuedSynchronizer</tt> for their
synchronization mechanics.

<p> Serialization of this class stores only the underlying atomic
integer maintaining state, so deserialized objects have empty
thread queues. Typical subclasses requiring serializability will
define a <tt>readObject</tt> method that restores this to a known
initial state upon deserialization.

<h3>Usage</h3>

<p> To use this class as the basis of a synchronizer, redefine the
following methods, as applicable, by inspecting and/or modifying
the synchronization state using {@link #getState}, {@link
#setState} and/or {@link #compareAndSetState}: 

<ul>
<li> {@link #tryAcquire}
<li> {@link #tryRelease}
<li> {@link #tryAcquireShared}
<li> {@link #tryReleaseShared}
<li> {@link #isHeldExclusively}
</ul>

Each of these methods by default throws {@link
UnsupportedOperationException}.  Implementations of these methods
must be internally thread-safe, and should in general be short and
not block. Defining these methods is the <em>only</em> supported
means of using this class. All other methods are declared
<tt>final</tt> because they cannot be independently varied.

<p> Even though this class is based on an internal FIFO queue, it
does not automatically enforce FIFO acquisition policies.  The core
of exclusive synchronization takes the form:

<pre>
Acquire:
    while (!tryAcquire(arg)) {
       <em>enqueue thread if it is not already queued</em>;
       <em>possibly block current thread</em>;
    }

Release:
    if (tryRelease(arg))
       <em>unblock the first queued thread</em>;
</pre>

(Shared mode is similar but may involve cascading signals.)

<p> Because checks in acquire are invoked before enqueuing, a newly
acquiring thread may <em>barge</em> ahead of others that are
blocked and queued. However, you can, if desired, define
<tt>tryAcquire</tt> and/or <tt>tryAcquireShared</tt> to disable
barging by internally invoking one or more of the inspection
methods. In particular, a strict FIFO lock can define
<tt>tryAcquire</tt> to immediately return <tt>false</tt> if {@link
#getFirstQueuedThread} does not return the current thread.  A
normally preferable non-strict fair version can immediately return
<tt>false</tt> only if {@link #hasQueuedThreads} returns
<tt>true</tt> and <tt>getFirstQueuedThread</tt> is not the current
thread; or equivalently, that <tt>getFirstQueuedThread</tt> is both
non-null and not the current thread.  Further variations are
possible.

<p> Throughput and scalability are generally highest for the
default barging (also known as <em>greedy</em>,
<em>renouncement</em>, and <em>convoy-avoidance</em>) strategy.
While this is not guaranteed to be fair or starvation-free, earlier
queued threads are allowed to recontend before later queued
threads, and each recontention has an unbiased chance to succeed
against incoming threads.  Also, while acquires do not
&quot;spin&quot; in the usual sense, they may perform multiple
invocations of <tt>tryAcquire</tt> interspersed with other
computations before blocking.  This gives most of the benefits of
spins when exclusive synchronization is only briefly held, without
most of the liabilities when it isn't. If so desired, you can
augment this by preceding calls to acquire methods with
\"fast-path\" checks, possibly prechecking {@link #hasContended}
and/or {@link #hasQueuedThreads} to only do so if the synchronizer
is likely not to be contended.

<p> This class provides an efficient and scalable basis for
synchronization in part by specializing its range of use to
synchronizers that can rely on <tt>int</tt> state, acquire, and
release parameters, and an internal FIFO wait queue. When this does
not suffice, you can build synchronizers from a lower level using
{@link java.util.concurrent.atomic atomic} classes, your own custom
{@link java.util.Queue} classes, and {@link LockSupport} blocking
support.

<h3>Usage Examples</h3>

<p>Here is a non-reentrant mutual exclusion lock class that uses
the value zero to represent the unlocked state, and one to
represent the locked state. It also supports conditions and exposes
one of the instrumentation methods:

<pre>
class Mutex implements Lock, java.io.Serializable {

   // Our internal helper class
   private static class Sync extends AbstractQueuedSynchronizer {
     // Report whether in locked state
     protected boolean isHeldExclusively() { 
       return getState() == 1; 
     }

     // Acquire the lock if state is zero
     public boolean tryAcquire(int acquires) {
       assert acquires == 1; // Otherwise unused
       return compareAndSetState(0, 1);
     }

     // Release the lock by setting state to zero
     protected boolean tryRelease(int releases) {
       assert releases == 1; // Otherwise unused
       if (getState() == 0) throw new IllegalMonitorStateException();
       setState(0);
       return true;
     }
      
     // Provide a Condition
     Condition newCondition() { return new ConditionObject(); }

     // Deserialize properly
     private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
       s.defaultReadObject();
       setState(0); // reset to unlocked state
     }
   }

   // The sync object does all the hard work. We just forward to it.
   private final Sync sync = new Sync();

   public void lock()                { sync.acquire(1); }
   public boolean tryLock()          { return sync.tryAcquire(1); }
   public void unlock()              { sync.release(1); }
   public Condition newCondition()   { return sync.newCondition(); }
   public boolean isLocked()         { return sync.isHeldExclusively(); }
   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
   public void lockInterruptibly() throws InterruptedException { 
     sync.acquireInterruptibly(1);
   }
   public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
     return sync.tryAcquireNanos(1, unit.toNanos(timeout));
   }
}
</pre>

<p> Here is a latch class that is like a {@link CountDownLatch}
except that it only requires a single <tt>signal</tt> to
fire. Because a latch is non-exclusive, it uses the <tt>shared</tt>
acquire and release methods.

<pre>
class BooleanLatch {

   private static class Sync extends AbstractQueuedSynchronizer {
     boolean isSignalled() { return getState() != 0; }

     protected int tryAcquireShared(int ignore) {
       return isSignalled()? 1 : -1;
     }
       
     protected boolean tryReleaseShared(int ignore) {
       setState(1);
       return true;
     }
   }

   private final Sync sync = new Sync();
   public boolean isSignalled() { return sync.isSignalled(); }
   public void signal()         { sync.releaseShared(1); }
   public void await() throws InterruptedException {
     sync.acquireSharedInterruptibly(1);
   }
}

</pre>

@since 1.5
@author Doug Lea"
      classrelation 1924123 // <realization>
	relation 1924123 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 1924123 // <realization>
	  b parent class_ref 137883 // Serializable
      end

      attribute 2923163 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value "=  7373984972572414691L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 7880603 "AbstractQueuedSynchronizer"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new <tt>AbstractQueuedSynchronizer</tt> instance
with initial synchronization state of zero."
      end

      class 990747 "Node"
	visibility package 
	cpp_decl ""
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	attribute 2923291 "CANCELLED"
	  class_attribute const_attribute package explicit_type "int"
	  init_value "=   1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " waitStatus value to indicate thread has cancelled "
	end

	attribute 2923419 "SIGNAL"
	  class_attribute const_attribute package explicit_type "int"
	  init_value "=  -1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " waitStatus value to indicate thread needs unparking "
	end

	attribute 2923547 "CONDITION"
	  class_attribute const_attribute package explicit_type "int"
	  init_value "=  -2"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " waitStatus value to indicate thread is waiting on condition "
	end

	classrelation 1924251 // SHARED (<unidirectional association>)
	  relation 1924251 --->
	    a role_name "SHARED" init_value "=  new Node()" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in shared mode 
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1924251 // SHARED (<unidirectional association>)
	    b parent class_ref 990747 // Node
	end

	classrelation 1924379 // EXCLUSIVE (<unidirectional association>)
	  relation 1924379 --->
	    a role_name "EXCLUSIVE" init_value "=  null" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in exclusive mode 
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1924379 // EXCLUSIVE (<unidirectional association>)
	    b parent class_ref 990747 // Node
	end

	attribute 2923675 "waitStatus"
	  volatile package explicit_type "int"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "Status field, taking on only the values:
  SIGNAL:     The successor of this node is (or will soon be) 
              blocked (via park), so the current node must 
              unpark its successor when it releases or 
              cancels. To avoid races, acquire methods must
              first indicate they need a signal, 
              then retry the atomic acquire, and then, 
              on failure, block.
  CANCELLED:  Node is cancelled due to timeout or interrupt
              Nodes never leave this state. In particular,
              a thread with cancelled node never again blocks.
  CONDITION:  Node is currently on a condition queue
              It will not be used as a sync queue node until
              transferred. (Use of this value here
              has nothing to do with the other uses
              of the field, but simplifies mechanics.)
  0:          None of the above

The values are arranged numerically to simplify use.
Non-negative values mean that a node doesn't need to
signal. So, most code doesn't need to check for particular
values, just for sign.

The field is initialized to 0 for normal sync nodes, and
CONDITION for condition nodes.  It is modified only using
CAS.
"
	end

	classrelation 1924507 // prev (<unidirectional association>)
	  relation 1924507 --->
	    a role_name "prev" volatile package
	      comment "
Link to predecessor node that current node/thread relies on
for checking waitStatus. Assigned during enqueing, and nulled
out (for sake of GC) only upon dequeuing.  Also, upon
cancellation of a predecessor, we short-circuit while
finding a non-cancelled one, which will always exist
because the head node is never cancelled: A node becomes
head only as a result of successful acquire. A
cancelled thread never succeeds in acquiring, and a thread only
cancels itself, not any other node.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1924507 // prev (<unidirectional association>)
	    b parent class_ref 990747 // Node
	end

	classrelation 1924635 // next (<unidirectional association>)
	  relation 1924635 --->
	    a role_name "next" volatile package
	      comment "
Link to the successor node that the current node/thread
unparks upon release. Assigned once during enqueuing, and
nulled out (for sake of GC) when no longer needed.  Upon
cancellation, we cannot adjust this field, but can notice
status and bypass the node if cancelled.  The enq operation
does not assign next field of a predecessor until after
attachment, so seeing a null next field does not
necessarily mean that node is at end of queue. However, if
a next field appears to be null, we can scan prev's from
the tail to double-check.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1924635 // next (<unidirectional association>)
	    b parent class_ref 990747 // Node
	end

	classrelation 1924763 // thread (<unidirectional association>)
	  relation 1924763 --->
	    a role_name "thread" volatile package
	      comment "
The thread that enqueued this node.  Initialized on
construction and nulled out after use. 

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1924763 // thread (<unidirectional association>)
	    b parent class_ref 163227 // Thread
	end

	classrelation 1924891 // nextWaiter (<unidirectional association>)
	  relation 1924891 --->
	    a role_name "nextWaiter" package
	      comment " 
Link to next node waiting on condition, or the special
value SHARED.  Because condition queues are accessed only
when holding in exclusive mode, we just need a simple
linked queue to hold nodes while they are waiting on
conditions. They are then transferred to the queue to
re-acquire. And because conditions can only be exclusive,
we save a field by using special value to indicate shared
mode.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1924891 // nextWaiter (<unidirectional association>)
	    b parent class_ref 990747 // Node
	end

	operation 7880731 "isShared"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns true if node is waiting in shared mode"
	end

	operation 7880859 "predecessor"
	  package return_type class_ref 990747 // Node
	  nparams 0
	  nexceptions 1
	    exception class_ref 538779 // NullPointerException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns previous node, or throws NullPointerException if
null.  Use when predecessor cannot be null.
@return the predecessor of this node"
	end

	operation 7880987 "Node"
	  package explicit_return_type ""
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7881115 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 163227 // Thread
	    param inout name "mode" type class_ref 990747 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7881243 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 163227 // Thread
	    param in name "waitStatus" explicit_type "int"
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 1925019 // head (<unidirectional association>)
	relation 1925019 --->
	  a role_name "head" volatile private
	    comment " 
Head of the wait queue, lazily initialized.  Except for
initialization, it is modified only via method setHead.  Note:
If head exists, its waitStatus is guaranteed not to be
CANCELLED.

"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 1925019 // head (<unidirectional association>)
	  b parent class_ref 990747 // Node
      end

      classrelation 1925147 // tail (<unidirectional association>)
	relation 1925147 --->
	  a role_name "tail" volatile private
	    comment " 
Tail of the wait queue, lazily initialized.  Modified only via
method enq to add new wait node.

"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 1925147 // tail (<unidirectional association>)
	  b parent class_ref 990747 // Node
      end

      attribute 2923803 "state"
	volatile private explicit_type "int"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "The synchronization state.
"
      end

      operation 7881371 "getState"
	protected explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the current value of synchronization state.
This operation has memory semantics of a <tt>volatile</tt> read.
@return current state value"
      end

      operation 7881499 "setState"
	protected explicit_return_type "void"
	nparams 1
	  param in name "newState" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets the value of synchronization state.
This operation has memory semantics of a <tt>volatile</tt> write.
@param newState the new state value"
      end

      operation 7881627 "compareAndSetState"
	protected explicit_return_type "boolean"
	nparams 2
	  param in name "expect" explicit_type "int"
	  param in name "update" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Atomically sets synchronization state to the given updated
value if the current state value equals the expected value.
This operation has memory semantics of a <tt>volatile</tt> read
and write.
@param expect the expected value
@param update the new value
@return true if successful. False return indicates that
the actual value was not equal to the expected value."
      end

      operation 7881755 "enq"
	private return_type class_ref 990747 // Node
	nparams 1
	  param in name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Queuing utilities

Insert node into queue, initializing if necessary. See picture above.
@param node the node to insert
@return node's predecessor"
      end

      operation 7881883 "addWaiter"
	private return_type class_ref 990747 // Node
	nparams 1
	  param inout name "mode" type class_ref 990747 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Create and enq node for given thread and mode
@param current the thread
@param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
@return the new node"
      end

      operation 7882011 "setHead"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Set head of queue to be node, thus dequeuing. Called only by
acquire methods.  Also nulls out unused fields for sake of GC
and to suppress unnecessary signals and traversals.
@param node the node "
      end

      operation 7882139 "unparkSuccessor"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wake up node's successor, if one exists.
@param node the node"
      end

      operation 7882267 "setHeadAndPropagate"
	private explicit_return_type "void"
	nparams 2
	  param inout name "node" type class_ref 990747 // Node
	  param in name "propagate" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Set head of queue, and check if successor may be waiting
in shared mode, if so propagating if propagate > 0.
@param pred the node holding waitStatus for node
@param node the node 
@param propagate the return value from a tryAcquireShared"
      end

      operation 7882395 "cancelAcquire"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Utilities for various versions of acquire

Cancel an ongoing attempt to acquire.
@param node the node"
      end

      operation 7882523 "shouldParkAfterFailedAcquire"
	class_operation private explicit_return_type "boolean"
	nparams 2
	  param inout name "pred" type class_ref 990747 // Node
	  param inout name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Checks and updates status for a node that failed to acquire.
Returns true if thread should block. This is the main signal
control in all acquire loops.  Requires that pred == node.prev
@param pred node's predecessor holding status
@param node the node 
@return true if thread should block"
      end

      operation 7882651 "selfInterrupt"
	class_operation private explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to interrupt current thread."
      end

      operation 7882779 "parkAndCheckInterrupt"
	class_operation private explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to park and then check if interrupted
@return true if interrupted"
      end

      operation 7882907 "acquireQueued"
	package explicit_return_type "boolean"
	nparams 2
	  param in name "node" type class_ref 990747 // Node
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Various flavors of acquire, varying in exclusive/shared and
control modes.  Each is mostly the same, but annoyingly
different.  Only a little bit of factoring is possible due to
interactions of exception mechanics (including ensuring that we
cancel if tryAcquire throws exception) and other control, at
least not without hurting performance too much. 


Acquire in exclusive uninterruptible mode for thread already in
queue. Used by condition wait methods as well as acquire.
@param node the node
@param arg the acquire argument
@return true if interrupted while waiting"
      end

      operation 7883035 "doAcquireInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquire in exclusive interruptible mode
@param arg the acquire argument"
      end

      operation 7883163 "doAcquireNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquire in exclusive timed mode
@param arg the acquire argument
@param nanosTimeout max wait time
@return true if acquired"
      end

      operation 7883291 "doAcquireShared"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquire in shared uninterruptible mode
@param arg the acquire argument"
      end

      operation 7883419 "doAcquireSharedInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquire in shared interruptible mode
@param arg the acquire argument"
      end

      operation 7883547 "doAcquireSharedNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquire in shared timed mode
@param arg the acquire argument
@param nanosTimeout max wait time
@return true if acquired"
      end

      operation 7883675 "tryAcquire"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Main exported methods 

Attempts to acquire in exclusive mode. This method should query
if the state of the object permits it to be acquired in the
exclusive mode, and if so to acquire it.

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread. This can be used
to implement method {@link Lock#tryLock()}. 

<p>The default
implementation throws {@link UnsupportedOperationException}

@param arg the acquire argument. This value
is always the one passed to an acquire method,
or is the value saved on entry to a condition wait.
The value is otherwise uninterpreted and can represent anything
you like.
@return true if successful. Upon success, this object has been
acquired.
@throws IllegalMonitorStateException if acquiring would place
this synchronizer in an illegal state. This exception must be
thrown in a consistent fashion for synchronization to work
correctly.
@throws UnsupportedOperationException if exclusive mode is not supported"
      end

      operation 7883803 "tryRelease"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in exclusive
mode.  <p>This method is always invoked by the thread
performing release.

<p>The default implementation throws
{@link UnsupportedOperationException}
@param arg the release argument. This value
is always the one passed to a release method,
or the current state value upon entry to a condition wait.
The value is otherwise uninterpreted and can represent anything
you like.
@return <tt>true</tt> if this object is now in a fully released state, 
so that any waiting threads may attempt to acquire; and <tt>false</tt>
otherwise.
@throws IllegalMonitorStateException if releasing would place
this synchronizer in an illegal state. This exception must be
thrown in a consistent fashion for synchronization to work
correctly.
@throws UnsupportedOperationException if exclusive mode is not supported"
      end

      operation 7883931 "tryAcquireShared"
	protected explicit_return_type "int"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode. This method should query if
the state of the object permits it to be acquired in the shared
mode, and if so to acquire it.  

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread.

<p>The default implementation throws {@link
UnsupportedOperationException}

@param arg the acquire argument. This value
is always the one passed to an acquire method,
or is the value saved on entry to a condition wait.
The value is otherwise uninterpreted and can represent anything
you like.
@return a negative value on failure, zero on exclusive success,
and a positive value if non-exclusively successful, in which
case a subsequent waiting thread must check
availability. (Support for three different return values
enables this method to be used in contexts where acquires only
sometimes act exclusively.)  Upon success, this object has been
acquired.
@throws IllegalMonitorStateException if acquiring would place
this synchronizer in an illegal state. This exception must be
thrown in a consistent fashion for synchronization to work
correctly.
@throws UnsupportedOperationException if shared mode is not supported"
      end

      operation 7884059 "tryReleaseShared"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in shared mode.
<p>This method is always invoked by the thread performing release.
<p> The default implementation throws 
{@link UnsupportedOperationException}
@param arg the release argument. This value
is always the one passed to a release method,
or the current state value upon entry to a condition wait.
The value is otherwise uninterpreted and can represent anything
you like.
@return <tt>true</tt> if this object is now in a fully released state, 
so that any waiting threads may attempt to acquire; and <tt>false</tt>
otherwise.
@throws IllegalMonitorStateException if releasing would place
this synchronizer in an illegal state. This exception must be
thrown in a consistent fashion for synchronization to work
correctly.
@throws UnsupportedOperationException if shared mode is not supported"
      end

      operation 7884187 "isHeldExclusively"
	protected explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if synchronization is held exclusively with respect
to the current (calling) thread.  This method is invoked
upon each call to a non-waiting {@link ConditionObject} method.
(Waiting methods instead invoke {@link #release}.)
<p>The default implementation throws {@link
UnsupportedOperationException}. This method is invoked
internally only within {@link ConditionObject} methods, so need
not be defined if conditions are not used.

@return true if synchronization is held exclusively;
else false
@throws UnsupportedOperationException if conditions are not supported"
      end

      operation 7884315 "acquire"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, ignoring interrupts.  Implemented
by invoking at least once {@link #tryAcquire},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquire} until success.  This method can be used
to implement method {@link Lock#lock}
@param arg the acquire argument.
This value is conveyed to {@link #tryAcquire} but is
otherwise uninterpreted and can represent anything
you like."
      end

      operation 7884443 "acquireInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, aborting if interrupted.
Implemented by first checking interrupt status, then invoking
at least once {@link #tryAcquire}, returning on
success.  Otherwise the thread is queued, possibly repeatedly
blocking and unblocking, invoking {@link #tryAcquire}
until success or the thread is interrupted.  This method can be
used to implement method {@link Lock#lockInterruptibly}
@param arg the acquire argument.
This value is conveyed to {@link #tryAcquire} but is
otherwise uninterpreted and can represent anything
you like.
@throws InterruptedException if the current thread is interrupted"
      end

      operation 7884571 "tryAcquireNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in exclusive mode, aborting if interrupted,
and failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquire}, returning on success.  Otherwise, the thread is
queued, possibly repeatedly blocking and unblocking, invoking
{@link #tryAcquire} until success or the thread is interrupted
or the timeout elapses.  This method can be used to implement
method {@link Lock#tryLock(long, TimeUnit)}.
@param arg the acquire argument.
This value is conveyed to {@link #tryAcquire} but is
otherwise uninterpreted and can represent anything
you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return true if acquired; false if timed out
@throws InterruptedException if the current thread is interrupted"
      end

      operation 7884699 "release"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in exclusive mode.  Implemented by unblocking one or
more threads if {@link #tryRelease} returns true.
This method can be used to implement method {@link Lock#unlock}
@param arg the release argument.
This value is conveyed to {@link #tryRelease} but is
otherwise uninterpreted and can represent anything
you like.
@return the value returned from {@link #tryRelease} "
      end

      operation 7884827 "acquireShared"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, ignoring interrupts.  Implemented by
first invoking at least once {@link #tryAcquireShared},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquireShared} until success.  
@param arg the acquire argument.
This value is conveyed to {@link #tryAcquireShared} but is
otherwise uninterpreted and can represent anything
you like."
      end

      operation 7884955 "acquireSharedInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, aborting if interrupted.  Implemented
by first checking interrupt status, then invoking at least once
{@link #tryAcquireShared}, returning on success.  Otherwise the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted.  
@param arg the acquire argument.
This value is conveyed to {@link #tryAcquireShared} but is
otherwise uninterpreted and can represent anything
you like.
@throws InterruptedException if the current thread is interrupted"
      end

      operation 7885083 "tryAcquireSharedNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 164123 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode, aborting if interrupted, and
failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquireShared}, returning on success.  Otherwise, the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted or the timeout elapses.
@param arg the acquire argument.
This value is conveyed to {@link #tryAcquireShared} but is
otherwise uninterpreted and can represent anything
you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return true if acquired; false if timed out
@throws InterruptedException if the current thread is interrupted"
      end

      operation 7885211 "releaseShared"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in shared mode.  Implemented by unblocking one or more
threads if {@link #tryReleaseShared} returns true. 
@param arg the release argument.
This value is conveyed to {@link #tryReleaseShared} but is
otherwise uninterpreted and can represent anything
you like.
@return the value returned from {@link #tryReleaseShared} "
      end

      operation 7885339 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Queue inspection methods

Queries whether any threads are waiting to acquire. Note that
because cancellations due to interrupts and timeouts may occur
at any time, a <tt>true</tt> return does not guarantee that any
other thread will ever acquire.

<p> In this implementation, this operation returns in
constant time.

@return true if there may be other threads waiting to acquire
the lock."
      end

      operation 7885467 "hasContended"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads have ever contended to acquire this
synchronizer; that is if an acquire method has ever blocked.

<p> In this implementation, this operation returns in
constant time.

@return true if there has ever been contention"
      end

      operation 7885595 "getFirstQueuedThread"
	public return_type class_ref 163227 // Thread
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the first (longest-waiting) thread in the queue, or
<tt>null</tt> if no threads are currently queued.

<p> In this implementation, this operation normally returns in
constant time, but may iterate upon contention if other threads are
concurrently modifying the queue.

@return the first (longest-waiting) thread in the queue, or
<tt>null</tt> if no threads are currently queued."
      end

      operation 7885723 "fullGetFirstQueuedThread"
	private return_type class_ref 163227 // Thread
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Version of getFirstQueuedThread called when fastpath fails"
      end

      operation 7885851 "isQueued"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 163227 // Thread
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if the given thread is currently queued. 

<p> This implementation traverses the queue to determine
presence of the given thread.

@param thread the thread
@return true if the given thread in on the queue
@throws NullPointerException if thread null"
      end

      operation 7885979 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation and monitoring methods

Returns an estimate of the number of threads waiting to
acquire.  The value is only an estimate because the number of
threads may change dynamically while this method traverses
internal data structures.  This method is designed for use in
monitoring system state, not for synchronization
control.

@return the estimated number of threads waiting for this lock"
      end

      operation 7886107 "getQueuedThreads"
	public return_type class_ref 135067 // Collection
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive monitoring facilities.
@return the collection of threads"
      end

      operation 7886235 "getExclusiveQueuedThreads"
	public return_type class_ref 135067 // Collection
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in exclusive mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to an exclusive acquire.
@return the collection of threads"
      end

      operation 7886363 "getSharedQueuedThreads"
	public return_type class_ref 135067 // Collection
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in shared mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to a shared acquire.
@return the collection of threads"
      end

      operation 7886491 "toString"
	public explicit_return_type "String"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this synchronizer, as well as its
state.  The state, in brackets, includes the String &quot;State
=&quot; followed by the current value of {@link #getState}, and
either &quot;nonempty&quot; or &quot;empty&quot; depending on
whether the queue is empty.

@return a string identifying this synchronizer, as well as its state."
      end

      operation 7886619 "isOnSyncQueue"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Internal support methods for Conditions

Returns true if a node, always one that was initially placed on
a condition queue, is now waiting to reacquire on sync queue.
@param node the node
@return true if is reacquiring"
      end

      operation 7886747 "findNodeFromTail"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if node is on sync queue by searching backwards from tail.
Called only when needed by isOnSyncQueue.
@return true if present"
      end

      operation 7886875 "transferForSignal"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers a node from a condition queue onto sync queue. 
Returns true if successful.
@param node the node
@return true if successfully transferred (else the node was
cancelled before signal)."
      end

      operation 7887003 "transferAfterCancelledWait"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers node, if necessary, to sync queue after a cancelled
wait. Returns true if thread was cancelled before being
signalled.
@param current the waiting thread
@param node its node
@return true if cancelled before the node was signalled."
      end

      operation 7887131 "fullyRelease"
	package explicit_return_type "int"
	nparams 1
	  param inout name "node" type class_ref 990747 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Invoke release with current state value; return saved state.
Cancel node and throw exception on failure.
@param node the condition node for this wait
@return previous sync state"
      end

      operation 7887259 "owns"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 990875 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation methods for conditions

Queries whether the given ConditionObject 
uses this synchronizer as its lock.
@param condition the condition
@return <tt>true</tt> if owned
@throws NullPointerException if condition null"
      end

      class 990875 "ConditionObject"
	visibility public 
	cpp_decl ""
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 1925275 // <realization>
	  relation 1925275 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 1925275 // <realization>
	    b parent class_ref 989339 // Condition
	end

	classrelation 1925403 // <realization>
	  relation 1925403 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 1925403 // <realization>
	    b parent class_ref 137883 // Serializable
	end

	attribute 2923931 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value "=  1173984872572414699L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	classrelation 1925531 // firstWaiter (<unidirectional association>)
	  relation 1925531 --->
	    a role_name "firstWaiter" private
	      comment " First node of condition queue. 
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1925531 // firstWaiter (<unidirectional association>)
	    b parent class_ref 990747 // Node
	end

	classrelation 1925659 // lastWaiter (<unidirectional association>)
	  relation 1925659 --->
	    a role_name "lastWaiter" private
	      comment " Last node of condition queue. 
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1925659 // lastWaiter (<unidirectional association>)
	    b parent class_ref 990747 // Node
	end

	operation 7888667 "ConditionObject"
	  public explicit_return_type ""
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Creates a new <tt>ConditionObject</tt> instance."
	end

	operation 7888795 "addConditionWaiter"
	  private return_type class_ref 990747 // Node
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Internal methods

Add a new waiter to wait queue
@return its new wait node"
	end

	operation 7888923 "doSignal"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 990747 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Remove and transfer nodes until hit non-cancelled one or
null. Split out from signal in part to encourage compilers
to inline the case of no waiters.
@param first (non-null) the first node on condition queue"
	end

	operation 7889051 "doSignalAll"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 990747 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Remove and transfer all nodes.
@param first (non-null) the first node on condition queue"
	end

	operation 7889179 "signal"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " public methods

Moves the longest-waiting thread, if one exists, from the
wait queue for this condition to the wait queue for the
owning lock.
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
returns false"
	end

	operation 7889307 "signalAll"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Moves all threads from the wait queue for this condition to
the wait queue for the owning lock.
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
returns false"
	end

	operation 7889435 "unlinkCancelledWaiters"
	  private explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Unlinks cancelled waiter nodes from condition queue.
Called only while holding lock. This is called when
cancellation occurred during condition wait, and upon
insertion of a new waiter when lastWaiter is seen to have
been cancelled. This method is needed to avoid garbage
retention in the absence of signals. So even though it may
require a full traversal, it comes into play only when
timeouts or cancellations occur in the absence of
signals. It traverses all nodes rather than stopping at a
particular target to unlink all pointers to garbage nodes
without requiring many re-traversals during cancellation
storms."
	end

	operation 7889563 "awaitUninterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements uninterruptible condition wait.
<ol>
<li> Save lock state returned by {@link #getState} 
<li> Invoke {@link #release} with 
     saved state as argument, throwing 
     IllegalMonitorStateException  if it fails.
<li> Block until signalled
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
</ol>"
	end

	attribute 2924059 "REINTERRUPT"
	  class_attribute const_attribute private explicit_type "int"
	  init_value "=   1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment "For interruptible waits, we need to track whether to throw
InterruptedException, if interrupted while blocked on
condition, versus reinterrupt current thread, if
interrupted while blocked waiting to re-acquire.

 Mode meaning to reinterrupt on exit from wait "
	end

	attribute 2924187 "THROW_IE"
	  class_attribute const_attribute private explicit_type "int"
	  init_value "=  -1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  comment " Mode meaning to throw InterruptedException on exit from wait "
	end

	operation 7889691 "checkInterruptWhileWaiting"
	  private explicit_return_type "int"
	  nparams 1
	    param inout name "node" type class_ref 990747 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Check for interrupt, returning THROW_IE if interrupted
before signalled, REINTERRUPT if after signalled, or
0 if not interrupted."
	end

	operation 7889819 "reportInterruptAfterWait"
	  private explicit_return_type "void"
	  nparams 1
	    param in name "interruptMode" explicit_type "int"
	  nexceptions 1
	    exception class_ref 164123 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Throw InterruptedException, reinterrupt current thread, or
do nothing, depending on mode."
	end

	operation 7889947 "await"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 164123 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements interruptible condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException
<li> Save lock state returned by {@link #getState} 
<li> Invoke {@link #release} with 
     saved state as argument, throwing 
     IllegalMonitorStateException  if it fails.
<li> Block until signalled or interrupted
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw exception
</ol>"
	end

	operation 7890075 "awaitNanos"
	  public explicit_return_type "long"
	  nparams 1
	    param in name "nanosTimeout" explicit_type "long"
	  nexceptions 1
	    exception class_ref 164123 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException
<li> Save lock state returned by {@link #getState} 
<li> Invoke {@link #release} with 
     saved state as argument, throwing 
     IllegalMonitorStateException  if it fails.
<li> Block until signalled, interrupted, or timed out
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException
</ol>"
	end

	operation 7890203 "awaitUntil"
	  public explicit_return_type "boolean"
	  nparams 1
	    param inout name "deadline" type class_ref 139163 // Date
	  nexceptions 1
	    exception class_ref 164123 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements absolute timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException
<li> Save lock state returned by {@link #getState} 
<li> Invoke {@link #release} with 
     saved state as argument, throwing 
     IllegalMonitorStateException  if it fails.
<li> Block until signalled, interrupted, or timed out
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException
<li> If timed out while blocked in step 4, return false, else true
</ol>"
	end

	operation 7890331 "await"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "time" explicit_type "long"
	    param inout name "unit" type class_ref 988315 // TimeUnit
	  nexceptions 1
	    exception class_ref 164123 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait. 
<ol>
<li> If current thread is interrupted, throw InterruptedException
<li> Save lock state returned by {@link #getState} 
<li> Invoke {@link #release} with 
     saved state as argument, throwing 
     IllegalMonitorStateException  if it fails.
<li> Block until signalled, interrupted, or timed out
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException
<li> If timed out while blocked in step 4, return false, else true
</ol>"
	end

	operation 7890459 "isOwnedBy"
	  package explicit_return_type "boolean"
	  nparams 1
	    param inout name "sync" type class_ref 990619 // AbstractQueuedSynchronizer
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "  support for instrumentation

Returns true if this condition was created by the given
synchronization object
@return true if owned"
	end

	operation 7890587 "hasWaiters"
	  protected explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Queries whether any threads are waiting on this condition.
Implements {@link AbstractQueuedSynchronizer#hasWaiters}
@return <tt>true</tt> if there are any waiting threads.
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
returns false"
	end

	operation 7890715 "getWaitQueueLength"
	  protected explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns an estimate of the number of threads waiting on
this condition. 
Implements {@link AbstractQueuedSynchronizer#getWaitQueueLength}
@return the estimated number of waiting threads.
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
returns false"
	end

	operation 7890843 "getWaitingThreads"
	  protected return_type class_ref 135067 // Collection
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a collection containing those threads that may be
waiting on this Condition.  
Implements {@link AbstractQueuedSynchronizer#getWaitingThreads}
@return the collection of threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
returns false"
	end
      end

      operation 7887387 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 990875 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with this synchronizer. Note that because timeouts
and interrupts may occur at any time, a <tt>true</tt> return
does not guarantee that a future <tt>signal</tt> will awaken
any threads.  This method is designed primarily for use in
monitoring of the system state.
@param condition the condition
@return <tt>true</tt> if there are any waiting threads.
@throws IllegalMonitorStateException if exclusive synchronization 
is not held
@throws IllegalArgumentException if the given condition is
not associated with this synchronizer
@throws NullPointerException if condition null"
      end

      operation 7887515 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 990875 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with this synchronizer. Note that
because timeouts and interrupts may occur at any time, the
estimate serves only as an upper bound on the actual number of
waiters.  This method is designed for use in monitoring of the
system state, not for synchronization control.
@param condition the condition
@return the estimated number of waiting threads.
@throws IllegalMonitorStateException if exclusive synchronization 
is not held
@throws IllegalArgumentException if the given condition is
not associated with this synchronizer
@throws NullPointerException if condition null"
      end

      operation 7887643 "getWaitingThreads"
	public return_type class_ref 135067 // Collection
	nparams 1
	  param inout name "condition" type class_ref 990875 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with this
synchronizer.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate. The elements of the
returned collection are in no particular order.  
@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if exclusive synchronization 
is not held
@throws IllegalArgumentException if the given condition is
not associated with this synchronizer
@throws NullPointerException if condition null"
      end

      attribute 2924315 "unsafe"
	class_attribute const_attribute private explicit_type "Unsafe"
	init_value "=   Unsafe.getUnsafe()"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "Setup to support compareAndSet. We need to natively implement
this here: For the sake of permitting future enhancements, we
cannot explicitly subclass AtomicInteger, which would be
efficient and useful otherwise. So, as the lesser of evils, we
natively implement using hotspot intrinsics API. And while we
are at it, we do the same for other CASable fields (which could
otherwise be done with atomic field updaters).
"
      end

      attribute 2924443 "stateOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 2924571 "headOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 2924699 "tailOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 2924827 "waitStatusOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 2924955 "nextOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      extra_member 165787 "initialization"
	
	cpp "" ""
	java "  static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(\"state\"));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(\"head\"));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(\"tail\"));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"waitStatus\"));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"next\"));
            
        } catch(Exception ex) { throw new Error(ex); }
    }"
	php ""
	python ""
	idl ""
      end

      operation 7890971 "compareAndSetHead"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "update" type class_ref 990747 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS head field. Used only by enq"
      end

      operation 7891099 "compareAndSetTail"
	private explicit_return_type "boolean"
	nparams 2
	  param inout name "expect" type class_ref 990747 // Node
	  param inout name "update" type class_ref 990747 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS tail field. Used only by enq"
      end

      operation 7891227 "compareAndSetWaitStatus"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 990747 // Node
	  param in name "expect" explicit_type "int"
	  param in name "update" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS waitStatus field of a node."
      end

      operation 7891355 "compareAndSetNext"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 990747 // Node
	  param inout name "expect" type class_ref 990747 // Node
	  param inout name "update" type class_ref 990747 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS next field of a node."
      end
    end

    class 1001883 "LockSupport"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "Basic thread blocking primitives for creating locks and other
synchronization classes.

<p>This class associates with each thread that uses it, a permit
(in the sense of the {@link java.util.concurrent.Semaphore
Semaphore} class). A call to <tt>park</tt> will return immediately
if the permit is available, consuming it in the process; otherwise
it <em>may</em> block.  A call to <tt>unpark</tt> makes the permit
available, if it was not already available. (Unlike with Semaphores
though, permits do not accumulate. There is at most one.)

<p>Methods <tt>park</tt> and <tt>unpark</tt> provide efficient
means of blocking and unblocking threads that do not encounter the
problems that cause the deprecated methods <tt>Thread.suspend</tt>
and <tt>Thread.resume</tt> to be unusable for such purposes: Races
between one thread invoking <tt>park</tt> and another thread trying
to <tt>unpark</tt> it will preserve liveness, due to the
permit. Additionally, <tt>park</tt> will return if the caller's
thread was interrupted, and timeout versions are supported. The
<tt>park</tt> method may also return at any other time, for \"no
reason\", so in general must be invoked within a loop that rechecks
conditions upon return. In this sense <tt>park</tt> serves as an
optimization of a \"busy wait\" that does not waste as much time
spinning, but must be paired with an <tt>unpark</tt> to be
effective.

<p>These methods are designed to be used as tools for creating
higher-level synchronization utilities, and are not in themselves
useful for most concurrency control applications.

<p><b>Sample Usage.</b> Here is a sketch of a First-in-first-out
non-reentrant lock class.
<pre>
class FIFOMutex {
  private AtomicBoolean locked = new AtomicBoolean(false);
  private Queue&lt;Thread&gt; waiters = new ConcurrentLinkedQueue&lt;Thread&gt;();

  public void lock() { 
    boolean wasInterrupted = false;
    Thread current = Thread.currentThread();
    waiters.add(current);

    // Block while not first in queue or cannot acquire lock
    while (waiters.peek() != current || 
           !locked.compareAndSet(false, true)) { 
       LockSupport.park();
       if (Thread.interrupted()) // ignore interrupts while waiting
         wasInterrupted = true;
    }

    waiters.remove();
    if (wasInterrupted)          // reassert interrupt status on exit
       current.interrupt();
  }

  public void unlock() {
    locked.set(false);
    LockSupport.unpark(waiters.peek());
  } 
}
</pre>"
      operation 7996443 "LockSupport"
	private explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      attribute 2942875 "unsafe"
	class_attribute const_attribute private explicit_type "Unsafe"
	init_value "=   Unsafe.getUnsafe()"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	comment " Cannot be instantiated.
 Hotspot implementation via intrinsics API"
      end

      operation 7996571 "unpark"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "thread" type class_ref 163227 // Thread
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Make available the permit for the given thread, if it
was not already available.  If the thread was blocked on
<tt>park</tt> then it will unblock.  Otherwise, its next call
to <tt>park</tt> is guaranteed not to block. This operation
is not guaranteed to have any effect at all if the given
thread has not been started.
@param thread the thread to unpark, or <tt>null</tt>, in which case
this operation has no effect. "
      end

      operation 7996699 "park"
	class_operation public explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes unless the
permit is available.
<p>If the permit is available then it is consumed and the call returns
immediately; otherwise 
the current thread becomes disabled for thread scheduling 
purposes and lies dormant until one of three things happens:
<ul>
<li>Some other thread invokes <tt>unpark</tt> with the current thread 
as the target; or
<li>Some other thread {@link Thread#interrupt interrupts} the current
thread; or
<li>The call spuriously (that is, for no reason) returns.
</ul>
<p>This method does <em>not</em> report which of these caused the 
method to return. Callers should re-check the conditions which caused 
the thread to park in the first place. Callers may also determine, 
for example, the interrupt status of the thread upon return."
      end

      operation 7996827 "parkNanos"
	class_operation public explicit_return_type "void"
	nparams 1
	  param in name "nanos" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, for up to
the specified waiting time, unless the permit is available.
<p>If the permit is available then it is consumed and the call returns
immediately; otherwise 
the current thread becomes disabled for thread scheduling 
purposes and lies dormant until one of four things happens:
<ul>
<li>Some other thread invokes <tt>unpark</tt> with the current thread 
as the target; or
<li>Some other thread {@link Thread#interrupt interrupts} the current
thread; or
<li>The specified waiting time elapses; or
<li>The call spuriously (that is, for no reason) returns.
</ul>
<p>This method does <em>not</em> report which of these caused the 
method to return. Callers should re-check the conditions which caused 
the thread to park in the first place. Callers may also determine, 
for example, the interrupt status of the thread, or the elapsed time
upon return.

@param nanos the maximum number of nanoseconds to wait"
      end

      operation 7996955 "parkUntil"
	class_operation public explicit_return_type "void"
	nparams 1
	  param in name "deadline" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, until
the specified deadline, unless the permit is available.
<p>If the permit is available then it is consumed and the call returns
immediately; otherwise 
the current thread becomes disabled for thread scheduling 
purposes and lies dormant until one of four things happens:
<ul>
<li>Some other thread invokes <tt>unpark</tt> with the current thread 
as the target; or
<li>Some other thread {@link Thread#interrupt interrupts} the current
thread; or
<li>The specified deadline passes; or
<li>The call spuriously (that is, for no reason) returns.
</ul>
<p>This method does <em>not</em> report which of these caused the 
method to return. Callers should re-check the conditions which caused 
the thread to park in the first place. Callers may also determine, 
for example, the interrupt status of the thread, or the current time
upon return.

@param deadline the absolute time, in milliseconds from the Epoch, to
wait until"
      end
    end

    class 1002011 "ReadWriteLock"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "A <tt>ReadWriteLock</tt> maintains a pair of associated {@link
Lock locks}, one for read-only operations and one for writing.
The {@link #readLock read lock} may be held simultaneously by
multiple reader threads, so long as there are no writers.  The
{@link #writeLock write lock} is exclusive.

<p>A read-write lock allows for a greater level of concurrency in
accessing shared data than that permitted by a mutual exclusion lock.
It exploits the fact that while only a single thread at a time (a
<em>writer</em> thread) can modify the shared data, in many cases any 
number of threads can concurrently read the data (hence <em>reader</em>
threads).
In theory, the increase in concurrency permitted by the use of a read-write
lock will lead to performance improvements over the use of a mutual
exclusion lock. In practice this increase in concurrency will only be fully
realized on a multi-processor, and then only if the access patterns for
the shared data are suitable.

<p>Whether or not a read-write lock will improve performance over the use
of a mutual exclusion lock depends on the frequency that the data is
read compared to being modified, the duration of the read and write 
operations, and the contention for the data - that is, the number of
threads that will try to read or write the data at the same time.
For example, a collection that is initially populated with data and
thereafter infrequently modified, while being frequently searched
(such as a directory of some kind) is an ideal candidate for the use of
a read-write lock. However, if updates become frequent then the data
spends most of its time being exclusively locked and there is little, if any
increase in concurrency. Further, if the read operations are too short
the overhead of the read-write lock implementation (which is inherently
more complex than a mutual exclusion lock) can dominate the execution
cost, particularly as many read-write lock implementations still serialize
all threads through a small section of code. Ultimately, only profiling
and measurement will establish whether the use of a read-write lock is
suitable for your application.


<p>Although the basic operation of a read-write lock is straight-forward,
there are many policy decisions that an implementation must make, which
may affect the effectiveness of the read-write lock in a given application.
Examples of these policies include:
<ul>
<li>Determining whether to grant the read lock or the write lock, when
both readers and writers are waiting, at the time that a writer releases
the write lock. Writer preference is common, as writes are expected to be
short and infrequent. Reader preference is less common as it can lead to
lengthy delays for a write if the readers are frequent and long-lived as
expected. Fair, or &quot;in-order&quot; implementations are also possible.

<li>Determining whether readers that request the read lock while a 
reader is active and a writer is waiting, are granted the read lock.
Preference to the reader can delay the writer indefinitely, while
preference to the writer can reduce the potential for concurrency.

<li>Determining whether the locks are reentrant: can a thread with the
write lock reacquire it? Can it acquire a read lock while holding the
write lock? Is the read lock itself reentrant?

<li>Can the write lock be downgraded to a read lock without allowing
an intervening writer? Can a read lock be upgraded to a write lock,
in preference to other waiting readers or writers?

</ul>
You should consider all of these things when evaluating the suitability
of a given implementation for your application.

@see ReentrantReadWriteLock
@see Lock
@see ReentrantLock

@since 1.5
@author Doug Lea"
      operation 7997083 "readLock"
	public return_type class_ref 990363 // Lock
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the lock used for reading.

@return the lock used for reading."
      end

      operation 7997211 "writeLock"
	public return_type class_ref 990363 // Lock
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the lock used for writing.

@return the lock used for writing."
      end
    end

    class 1002139 "ReentrantReadWriteLock"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "An implementation of {@link ReadWriteLock} supporting similar
semantics to {@link ReentrantLock}.
<p>This class has the following properties:

<ul>
<li><b>Acquisition order</b>

<p> This class does not impose a reader or writer preference
ordering for lock access.  However, it does support an optional
<em>fairness</em> policy.  When constructed as fair, threads
contend for entry using an approximately arrival-order policy. When
the write lock is released either the longest-waiting single writer
will be assigned the write lock, or if there is a reader waiting
longer than any writer, the set of readers will be assigned the
read lock.  When constructed as non-fair, the order of entry to the
lock need not be in arrival order.  In either case, if readers are
active and a writer enters the lock then no subsequent readers will
be granted the read lock until after that writer has acquired and
released the write lock.

<li><b>Reentrancy</b>
<p>This lock allows both readers and writers to reacquire read or
write locks in the style of a {@link ReentrantLock}. Readers are not
allowed until all write locks held by the writing thread have been
released.  
<p>Additionally, a writer can acquire the read lock - but not vice-versa.
Among other applications, reentrancy can be useful when
write locks are held during calls or callbacks to methods that
perform reads under read locks. 
If a reader tries to acquire the write lock it will never succeed.

<li><b>Lock downgrading</b>
<p>Reentrancy also allows downgrading from the write lock to a read lock,
by acquiring the write lock, then the read lock and then releasing the
write lock. However, upgrading from a read lock to the write lock is
<b>not</b> possible.

<li><b>Interruption of lock acquisition</b>
<p>The read lock and write lock both support interruption during lock
acquisition.

<li><b>{@link Condition} support</b>
<p>The write lock provides a {@link Condition} implementation that
behaves in the same way, with respect to the write lock, as the 
{@link Condition} implementation provided by
{@link ReentrantLock#newCondition} does for {@link ReentrantLock}.
This {@link Condition} can, of course, only be used with the write lock.
<p>The read lock does not support a {@link Condition} and
<tt>readLock().newCondition()</tt> throws 
<tt>UnsupportedOperationException</tt>.

<li><b>Instrumentation</b>
<P> This class supports methods to determine whether locks
are held or contended. These methods are designed for monitoring
system state, not for synchronization control.
</ul>

<p> Serialization of this class behaves in the same way as built-in
locks: a deserialized lock is in the unlocked state, regardless of
its state when serialized.

<p><b>Sample usages</b>. Here is a code sketch showing how to exploit
reentrancy to perform lock downgrading after updating a cache (exception
handling is elided for simplicity):
<pre>
class CachedData {
  Object data;
  volatile boolean cacheValid;
  ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

  void processCachedData() {
    rwl.readLock().lock();
    if (!cacheValid) {
       // upgrade lock manually
       rwl.readLock().unlock();   // must unlock first to obtain writelock
       rwl.writeLock().lock();
       if (!cacheValid) { // recheck
         data = ...
         cacheValid = true;
       }
       // downgrade lock
       rwl.readLock().lock();  // reacquire read without giving up write lock
       rwl.writeLock().unlock(); // unlock write, still hold read
    }

    use(data);
    rwl.readLock().unlock();
  }
}
</pre>

ReentrantReadWriteLocks can be used to improve concurrency in some
uses of some kinds of Collections. This is typically worthwhile
only when the collections are expected to be large, accessed by
more reader threads than writer threads, and entail operations with
overhead that outweighs synchronization overhead. For example, here
is a class using a TreeMap that is expected to be large and 
concurrently accessed.

<pre>
class RWDictionary {
   private final Map&lt;String, Data&gt;  m = new TreeMap&lt;String, Data&gt;();
   private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
   private final Lock r = rwl.readLock();
   private final Lock w = rwl.writeLock();

   public Data get(String key) {
       r.lock(); try { return m.get(key); } finally { r.unlock(); }
   }
   public String[] allKeys() {
       r.lock(); try { return m.keySet().toArray(); } finally { r.unlock(); }
   }
   public Data put(String key, Data value) {
       w.lock(); try { return m.put(key, value); } finally { w.unlock(); }
   }
   public void clear() {
       w.lock(); try { m.clear(); } finally { w.unlock(); }
   }
}
</pre>


<h3>Implementation Notes</h3>

<p>A reentrant write lock intrinsically defines an owner and can
only be released by the thread that acquired it.  In contrast, in
this implementation, the read lock has no concept of ownership, and
there is no requirement that the thread releasing a read lock is
the same as the one that acquired it.  However, this property is
not guaranteed to hold in future implementations of this class.

<p> This lock supports a maximum of 65536 recursive write locks
and 65536 read locks. Attempts to exceed these limits result in
{@link Error} throws from locking methods.

@since 1.5
@author Doug Lea
"
      classrelation 1951899 // <realization>
	relation 1951899 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 1951899 // <realization>
	  b parent class_ref 1002011 // ReadWriteLock
      end

      classrelation 1952027 // <realization>
	relation 1952027 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 1952027 // <realization>
	  b parent class_ref 137883 // Serializable
      end

      attribute 2943003 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value "=  -6992448646407690164L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      class 1002267 "ReadLock"
	visibility public 
	cpp_decl ""
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 1953051 // <realization>
	  relation 1953051 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 1953051 // <realization>
	    b parent class_ref 990363 // Lock
	end

	classrelation 1953179 // <realization>
	  relation 1953179 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 1953179 // <realization>
	    b parent class_ref 137883 // Serializable
	end

	attribute 2943515 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value "=  -5992448646407690164L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	classrelation 1953307 // sync (<unidirectional association>)
	  relation 1953307 --->
	    a role_name "sync" const_relation private
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1953307 // sync (<unidirectional association>)
	    b parent class_ref 1002523 // Sync
	end

	operation 8000539 "ReadLock"
	  protected explicit_return_type ""
	  nparams 1
	    param inout name "lock" type class_ref 1002139 // ReentrantReadWriteLock
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Constructor for use by subclasses 
@param lock the outer lock object
@throws NullPointerException if lock null"
	end

	operation 8000667 "lock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock. 

<p>Acquires the read lock if the write lock is not held by
another thread and returns immediately.

<p>If the write lock is held by another thread then
the current thread becomes disabled for thread scheduling
purposes and lies dormant until the read lock has been acquired."
	end

	operation 8000795 "lockInterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 164123 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock unless the current thread is 
{@link Thread#interrupt interrupted}.

<p>Acquires the read lock if the write lock is not held
by another thread and returns immediately.

<p>If the write lock is held by another thread then the
current thread becomes disabled for thread scheduling 
purposes and lies dormant until one of two things happens:

<ul>

<li>The read lock is acquired by the current thread; or

<li>Some other thread {@link Thread#interrupt interrupts}
the current thread.

</ul>

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or 

<li>is {@link Thread#interrupt interrupted} while acquiring 
the read lock,

</ul>

then {@link InterruptedException} is thrown and the current
thread's interrupted status is cleared.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock.

@throws InterruptedException if the current thread is interrupted"
	end

	operation 8000923 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock only if the write lock is not held by
another thread at the time of invocation.

<p>Acquires the read lock if the write lock is not held by
another thread and returns immediately with the value
<tt>true</tt>. Even when this lock has been set to use a
fair ordering policy, a call to <tt>tryLock()</tt>
<em>will</em> immediately acquire the read lock if it is
available, whether or not other threads are currently
waiting for the read lock.  This &quot;barging&quot; behavior
can be useful in certain circumstances, even though it
breaks fairness. If you want to honor the fairness setting
for this lock, then use {@link #tryLock(long, TimeUnit)
tryLock(0, TimeUnit.SECONDS) } which is almost equivalent
(it also detects interruption).

<p>If the write lock is held by another thread then
this method will return immediately with the value
<tt>false</tt>.

@return <tt>true</tt> if the read lock was acquired."
	end

	operation 8001051 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "timeout" explicit_type "long"
	    param inout name "unit" type class_ref 988315 // TimeUnit
	  nexceptions 1
	    exception class_ref 164123 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock if the write lock is not held by
another thread within the given waiting time and the
current thread has not been {@link Thread#interrupt
interrupted}.

<p>Acquires the read lock if the write lock is not held by
another thread and returns immediately with the value
<tt>true</tt>. If this lock has been set to use a fair
ordering policy then an available lock <em>will not</em> be
acquired if any other threads are waiting for the
lock. This is in contrast to the {@link #tryLock()}
method. If you want a timed <tt>tryLock</tt> that does
permit barging on a fair lock then combine the timed and
un-timed forms together:

<pre>if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }
</pre>

<p>If the write lock is held by another thread then the
current thread becomes disabled for thread scheduling 
purposes and lies dormant until one of three things happens:

<ul>

<li>The read lock is acquired by the current thread; or

<li>Some other thread {@link Thread#interrupt interrupts} the current
thread; or

<li>The specified waiting time elapses

</ul>

<p>If the read lock is acquired then the value <tt>true</tt> is
returned.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or 

<li>is {@link Thread#interrupt interrupted} while acquiring
the read lock,

</ul> then {@link InterruptedException} is thrown and the
current thread's interrupted status is cleared.

<p>If the specified waiting time elapses then the value
<tt>false</tt> is returned.  If the time is less than or
equal to zero, the method will not wait at all.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock, and over reporting the elapse of the waiting time.

@param timeout the time to wait for the read lock
@param unit the time unit of the timeout argument

@return <tt>true</tt> if the read lock was acquired.

@throws InterruptedException if the current thread is interrupted
@throws NullPointerException if unit is null
"
	end

	operation 8001179 "unlock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Attempts to release this lock.  

<p> If the number of readers is now zero then the lock
is made available for write lock attempts."
	end

	operation 8001307 "newCondition"
	  public return_type class_ref 989339 // Condition
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Throws <tt>UnsupportedOperationException</tt> because
<tt>ReadLocks</tt> do not support conditions.
@throws UnsupportedOperationException always"
	end

	operation 8001435 "toString"
	  public explicit_return_type "String"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a string identifying this lock, as well as its lock state.
The state, in brackets, includes the String 
&quot;Read locks =&quot; followed by the number of held
read locks.
@return a string identifying this lock, as well as its lock state."
	end
      end

      classrelation 1952155 // readerLock (<unidirectional association>)
	relation 1952155 --->
	  a role_name "readerLock" const_relation private
	    comment " Inner class providing readlock 
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 1952155 // readerLock (<unidirectional association>)
	  b parent class_ref 1002267 // ReadLock
      end

      class 1002395 "WriteLock"
	visibility public 
	cpp_decl ""
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 1953435 // <realization>
	  relation 1953435 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 1953435 // <realization>
	    b parent class_ref 990363 // Lock
	end

	classrelation 1953563 // <realization>
	  relation 1953563 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 1953563 // <realization>
	    b parent class_ref 137883 // Serializable
	end

	attribute 2943643 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value "=  -4992448646407690164L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end

	classrelation 1953691 // sync (<unidirectional association>)
	  relation 1953691 --->
	    a role_name "sync" const_relation private
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1953691 // sync (<unidirectional association>)
	    b parent class_ref 1002523 // Sync
	end

	operation 8001563 "WriteLock"
	  protected explicit_return_type ""
	  nparams 1
	    param inout name "lock" type class_ref 1002139 // ReentrantReadWriteLock
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Constructor for use by subclasses 
@param lock the outer lock object
@throws NullPointerException if lock null"
	end

	operation 8001691 "lock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquire the write lock. 

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately, setting the write lock hold count to
one.

<p>If the current thread already holds the write lock then the
hold count is incremented by one and the method returns
immediately.

<p>If the lock is held by another thread then the current
thread becomes disabled for thread scheduling purposes and
lies dormant until the write lock has been acquired, at which
time the write lock hold count is set to one."
	end

	operation 8001819 "lockInterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 164123 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock unless the current thread is {@link
Thread#interrupt interrupted}.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately, setting the write lock hold count to
one.

<p>If the current thread already holds this lock then the
hold count is incremented by one and the method returns
immediately.

<p>If the lock is held by another thread then the current
thread becomes disabled for thread scheduling purposes and
lies dormant until one of two things happens:

<ul>

<li>The write lock is acquired by the current thread; or

<li>Some other thread {@link Thread#interrupt interrupts}
the current thread.

</ul>

<p>If the write lock is acquired by the current thread then the
lock hold count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method;
or

<li>is {@link Thread#interrupt interrupted} while acquiring
the write lock,

</ul>

then {@link InterruptedException} is thrown and the current
thread's interrupted status is cleared.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock.

@throws InterruptedException if the current thread is interrupted"
	end

	operation 8001947 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock only if it is not held by another thread
at the time of invocation.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately with the value <tt>true</tt>,
setting the write lock hold count to one. Even when this lock has
been set to use a fair ordering policy, a call to
<tt>tryLock()</tt> <em>will</em> immediately acquire the
lock if it is available, whether or not other threads are
currently waiting for the write lock.  This &quot;barging&quot;
behavior can be useful in certain circumstances, even
though it breaks fairness. If you want to honor the
fairness setting for this lock, then use {@link
#tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }
which is almost equivalent (it also detects interruption).

<p> If the current thread already holds this lock then the
hold count is incremented by one and the method returns
<tt>true</tt>.

<p>If the lock is held by another thread then this method
will return immediately with the value <tt>false</tt>.

@return <tt>true</tt> if the lock was free and was acquired
by the current thread, or the write lock was already held
by the current thread; and <tt>false</tt> otherwise."
	end

	operation 8002075 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "timeout" explicit_type "long"
	    param inout name "unit" type class_ref 988315 // TimeUnit
	  nexceptions 1
	    exception class_ref 164123 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock if it is not held by another thread
within the given waiting time and the current thread has
not been {@link Thread#interrupt interrupted}.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately with the value <tt>true</tt>,
setting the write lock hold count to one. If this lock has been
set to use a fair ordering policy then an available lock
<em>will not</em> be acquired if any other threads are
waiting for the write lock. This is in contrast to the {@link
#tryLock()} method. If you want a timed <tt>tryLock</tt>
that does permit barging on a fair lock then combine the
timed and un-timed forms together:

<pre>if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }
</pre>

<p>If the current thread already holds this lock then the
hold count is incremented by one and the method returns
<tt>true</tt>.

<p>If the lock is held by another thread then the current
thread becomes disabled for thread scheduling purposes and
lies dormant until one of three things happens:

<ul>

<li>The write lock is acquired by the current thread; or

<li>Some other thread {@link Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses

</ul>

<p>If the write lock is acquired then the value <tt>true</tt> is
returned and the write lock hold count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method;
or

<li>is {@link Thread#interrupt interrupted} while acquiring
the write lock,

</ul> 

then {@link InterruptedException} is thrown and the current
thread's interrupted status is cleared.

<p>If the specified waiting time elapses then the value
<tt>false</tt> is returned.  If the time is less than or
equal to zero, the method will not wait at all.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock, and over reporting the elapse of the waiting time.

@param timeout the time to wait for the write lock
@param unit the time unit of the timeout argument

@return <tt>true</tt> if the lock was free and was acquired
by the current thread, or the write lock was already held by the
current thread; and <tt>false</tt> if the waiting time
elapsed before the lock could be acquired.

@throws InterruptedException if the current thread is interrupted
@throws NullPointerException if unit is null
"
	end

	operation 8002203 "unlock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Attempts to release this lock.  

<p>If the current thread is the holder of this lock then
the hold count is decremented. If the hold count is now
zero then the lock is released.  If the current thread is
not the holder of this lock then {@link
IllegalMonitorStateException} is thrown.
@throws IllegalMonitorStateException if the current thread does not
hold this lock."
	end

	operation 8002331 "newCondition"
	  public return_type class_ref 989339 // Condition
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a {@link Condition} instance for use with this
{@link Lock} instance. 
<p>The returned {@link Condition} instance supports the same
usages as do the {@link Object} monitor methods ({@link
Object#wait() wait}, {@link Object#notify notify}, and {@link
Object#notifyAll notifyAll}) when used with the built-in
monitor lock.

<ul>

<li>If this write lock is not held when any {@link
Condition} method is called then an {@link
IllegalMonitorStateException} is thrown.  (Read locks are
held independently of write locks, so are not checked or
affected. However it is essentially always an error to
invoke a condition waiting method when the current thread
has also acquired read locks, since other threads that
could unblock it will not be able to acquire the write
lock.)

<li>When the condition {@link Condition#await() waiting}
methods are called the write lock is released and, before
they return, the write lock is reacquired and the lock hold
count restored to what it was when the method was called.

<li>If a thread is {@link Thread#interrupt interrupted} while
waiting then the wait will terminate, an {@link
InterruptedException} will be thrown, and the thread's
interrupted status will be cleared.

<li> Waiting threads are signalled in FIFO order.

<li>The ordering of lock reacquisition for threads returning
from waiting methods is the same as for threads initially
acquiring the lock, which is in the default case not specified,
but for <em>fair</em> locks favors those threads that have been
waiting the longest.

</ul>
@return the Condition object"
	end

	operation 8002459 "toString"
	  public explicit_return_type "String"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a string identifying this lock, as well as its lock
state.  The state, in brackets includes either the String
&quot;Unlocked&quot; or the String &quot;Locked by&quot;
followed by the {@link Thread#getName} of the owning thread.
@return a string identifying this lock, as well as its lock state."
	end
      end

      classrelation 1952283 // writerLock (<unidirectional association>)
	relation 1952283 --->
	  a role_name "writerLock" const_relation private
	    comment " Inner class providing writelock 
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 1952283 // writerLock (<unidirectional association>)
	  b parent class_ref 1002395 // WriteLock
      end

      class 1002523 "Sync"
	abstract visibility package 
	cpp_decl ""
	java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 1952539 // <generalisation>
	  relation 1952539 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 1952539 // <generalisation>
	    b parent class_ref 990619 // AbstractQueuedSynchronizer
	end

	classrelation 1952667 // owner (<unidirectional association>)
	  relation 1952667 --->
	    a role_name "owner" package
	      comment " Current (exclusive) owner thread 
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 1952667 // owner (<unidirectional association>)
	    b parent class_ref 163227 // Thread
	end

	operation 7998107 "wlock"
	  abstract package explicit_return_type "void"
	  nparams 0
	  
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Perform write lock. Allows fast path in non-fair version."
	end

	operation 7998235 "nonfairTryAcquire"
	  package explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Perform non-fair tryLock for write.  tryAcquire is
implemented in subclasses, but both versions need nonfair
try for trylock method"
	end

	operation 7998363 "nonfairTryAcquireShared"
	  package explicit_return_type "int"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Perform nonfair tryLock for read. "
	end

	operation 7998491 "tryRelease"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "releases" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7998619 "tryReleaseShared"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "releases" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7998747 "isHeldExclusively"
	  protected explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7998875 "newCondition"
	  package return_type class_ref 990875 // ConditionObject
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Methods relayed to outer class"
	end

	operation 7999003 "getOwner"
	  package return_type class_ref 163227 // Thread
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7999131 "getReadLockCount"
	  package explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7999259 "isWriteLocked"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7999387 "getWriteHoldCount"
	  package explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7999515 "readObject"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "s" type class_ref 201115 // ObjectInputStream
	  nexceptions 2
	    exception class_ref 179355 // IOException
	    exception class_ref 201883 // ClassNotFoundException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Reconstitute this lock instance from a stream
@param s the stream"
	end

	operation 7999643 "getCount"
	  package explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 1952411 // sync (<unidirectional association>)
	relation 1952411 --->
	  a role_name "sync" const_relation private
	    comment " Performs all synchronization mechanics 
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 1952411 // sync (<unidirectional association>)
	  b parent class_ref 1002523 // Sync
      end

      operation 7997339 "ReentrantReadWriteLock"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new <tt>ReentrantReadWriteLock</tt> with
default ordering properties."
      end

      operation 7997467 "ReentrantReadWriteLock"
	public explicit_return_type ""
	nparams 1
	  param inout name "fair" explicit_type "boolean"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new <tt>ReentrantReadWriteLock</tt> with
the given fairness policy.

@param fair true if this lock should use a fair ordering policy"
      end

      operation 7997595 "writeLock"
	public return_type class_ref 1002395 // WriteLock
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 7997723 "readLock"
	public return_type class_ref 1002267 // ReadLock
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      attribute 2943131 "SHARED_SHIFT"
	class_attribute const_attribute package explicit_type "int"
	init_value "=  16"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	comment "Read vs write count extraction constants and functions.
Lock state is logically divided into two shorts: The lower
one representing the exclusive (writer) lock hold count,
and the upper the shared (reader) hold count.
"
      end

      attribute 2943259 "SHARED_UNIT"
	class_attribute const_attribute package explicit_type "int"
	init_value "=  (1 << SHARED_SHIFT)"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 2943387 "EXCLUSIVE_MASK"
	class_attribute const_attribute package explicit_type "int"
	init_value "=  (1 << SHARED_SHIFT) - 1"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 7997851 "sharedCount"
	class_operation package explicit_return_type "int"
	nparams 1
	  param in name "c" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Returns the number of shared holds represented in count  "
      end

      operation 7997979 "exclusiveCount"
	class_operation package explicit_return_type "int"
	nparams 1
	  param in name "c" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Returns the number of exclusive holds represented in count  "
      end

      class 1002651 "NonfairSync"
	visibility package 
	cpp_decl ""
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 1952795 // <generalisation>
	  relation 1952795 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 1952795 // <generalisation>
	    b parent class_ref 1002523 // Sync
	end

	operation 7999771 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7999899 "tryAcquireShared"
	  protected explicit_return_type "int"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 8000027 "wlock"
	  package explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Use fastpath for main write lock method"
	end
      end

      class 1002779 "FairSync"
	visibility package 
	cpp_decl ""
	final java_decl "${comment}${@}${visibility}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	classrelation 1952923 // <generalisation>
	  relation 1952923 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 1952923 // <generalisation>
	    b parent class_ref 1002523 // Sync
	end

	operation 8000155 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 8000283 "tryAcquireShared"
	  protected explicit_return_type "int"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 8000411 "wlock"
	  package explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      operation 8002587 "isFair"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation and status

Returns true if this lock has fairness set true.
@return true if this lock has fairness set true."
      end

      operation 8002715 "getOwner"
	protected return_type class_ref 163227 // Thread
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the thread that currently owns the write lock, or
<tt>null</tt> if not owned. Note that the owner may be
momentarily <tt>null</tt> even if there are threads trying to
acquire the lock but have not yet done so.  This method is
designed to facilitate construction of subclasses that provide
more extensive lock monitoring facilities.
@return the owner, or <tt>null</tt> if not owned."
      end

      operation 8002843 "getReadLockCount"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of read locks held for this lock. This
method is designed for use in monitoring system state, not for
synchronization control.
@return the number of read locks held."
      end

      operation 8002971 "isWriteLocked"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if the write lock is held by any thread. This method is
designed for use in monitoring system state, not for
synchronization control.
@return <tt>true</tt> if any thread holds the write lock and 
<tt>false</tt> otherwise."
      end

      operation 8003099 "isWriteLockedByCurrentThread"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if the write lock is held by the current thread. 
@return <tt>true</tt> if the current thread holds the write lock and 
<tt>false</tt> otherwise."
      end

      operation 8003227 "getWriteHoldCount"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of reentrant write holds on this lock by the
current thread.  A writer thread has a hold on a lock for
each lock action that is not matched by an unlock action.

@return the number of holds on the write lock by the current thread,
or zero if the write lock is not held by the current thread."
      end

      operation 8003355 "getQueuedWriterThreads"
	protected return_type class_ref 135067 // Collection
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire the write lock.  Because the actual set of threads may
change dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive lock monitoring facilities.
@return the collection of threads"
      end

      operation 8003483 "getQueuedReaderThreads"
	protected return_type class_ref 135067 // Collection
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire the read lock.  Because the actual set of threads may
change dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive lock monitoring facilities.
@return the collection of threads"
      end

      operation 8003611 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting to acquire the read or
write lock. Note that because cancellations may occur at any
time, a <tt>true</tt> return does not guarantee that any other
thread will ever acquire a lock.  This method is designed
primarily for use in monitoring of the system state.

@return true if there may be other threads waiting to acquire
the lock."
      end

      operation 8003739 "hasQueuedThread"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 163227 // Thread
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether the given thread is waiting to acquire either
the read or write lock. Note that because cancellations may
occur at any time, a <tt>true</tt> return does not guarantee
that this thread will ever acquire a lock.  This method is
designed primarily for use in monitoring of the system state.

@param thread the thread
@return true if the given thread is queued waiting for this lock.
@throws NullPointerException if thread is null"
      end

      operation 8003867 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting to acquire
either the read or write lock.  The value is only an estimate
because the number of threads may change dynamically while this
method traverses internal data structures.  This method is
designed for use in monitoring of the system state, not for
synchronization control.
@return the estimated number of threads waiting for this lock"
      end

      operation 8003995 "getQueuedThreads"
	protected return_type class_ref 135067 // Collection
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire either the read or write lock.  Because the actual set
of threads may change dynamically while constructing this
result, the returned collection is only a best-effort estimate.
The elements of the returned collection are in no particular
order.  This method is designed to facilitate construction of
subclasses that provide more extensive monitoring facilities.
@return the collection of threads"
      end

      operation 8004123 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 989339 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with the write lock. Note that because timeouts and
interrupts may occur at any time, a <tt>true</tt> return does
not guarantee that a future <tt>signal</tt> will awaken any
threads.  This method is designed primarily for use in
monitoring of the system state.
@param condition the condition
@return <tt>true</tt> if there are any waiting threads.
@throws IllegalMonitorStateException if this lock 
is not held
@throws IllegalArgumentException if the given condition is
not associated with this lock
@throws NullPointerException if condition null"
      end

      operation 8004251 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 989339 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with the write lock. Note that because
timeouts and interrupts may occur at any time, the estimate
serves only as an upper bound on the actual number of waiters.
This method is designed for use in monitoring of the system
state, not for synchronization control.
@param condition the condition
@return the estimated number of waiting threads.
@throws IllegalMonitorStateException if this lock 
is not held
@throws IllegalArgumentException if the given condition is
not associated with this lock
@throws NullPointerException if condition null"
      end

      operation 8004379 "getWaitingThreads"
	protected return_type class_ref 135067 // Collection
	nparams 1
	  param inout name "condition" type class_ref 989339 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with the write lock.
Because the actual set of threads may change dynamically while
constructing this result, the returned collection is only a
best-effort estimate. The elements of the returned collection
are in no particular order.  This method is designed to
facilitate construction of subclasses that provide more
extensive condition monitoring facilities.
@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if this lock 
is not held
@throws IllegalArgumentException if the given condition is
not associated with this lock
@throws NullPointerException if condition null"
      end

      operation 8004507 "toString"
	public explicit_return_type "String"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this lock, as well as its lock state.
The state, in brackets, includes the String &quot;Write locks =&quot;
followed by the number of reentrantly held write locks, and the
String &quot;Read locks =&quot; followed by the number of held
read locks.
@return a string identifying this lock, as well as its lock state."
      end
    end
  end

  deploymentview 168859 "locks"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 758043 "Lock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.TimeUnit;
${definition}"
      associated_classes
	class_ref 990363 // Lock
      end
      comment "@(#)Lock.java	1.4 03/12/19

Copyright 2004 Sun Microsystems, Inc. All rights reserved.
SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms."
    end

    artifact 758171 "Condition"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.*;
import java.util.Date;
${definition}"
      associated_classes
	class_ref 989339 // Condition
      end
      comment "@(#)Condition.java	1.5 04/07/12

Copyright 2004 Sun Microsystems, Inc. All rights reserved.
SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms."
    end

    artifact 758299 "AbstractQueuedSynchronizer"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import sun.misc.Unsafe;
${definition}"
      associated_classes
	class_ref 990619 // AbstractQueuedSynchronizer
      end
      comment "@(#)AbstractQueuedSynchronizer.java	1.4 07/01/04

Copyright 2004 Sun Microsystems, Inc. All rights reserved.
SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms."
    end

    artifact 758427 "ReentrantLock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
${definition}"
      associated_classes
	class_ref 989211 // ReentrantLock
      end
      comment "@(#)ReentrantLock.java	1.7 04/07/13

Copyright 2004 Sun Microsystems, Inc. All rights reserved.
SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms."
    end

    artifact 763419 "LockSupport"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.*;
import sun.misc.Unsafe;
${definition}"
      associated_classes
	class_ref 1001883 // LockSupport
      end
      comment "@(#)LockSupport.java	1.6 04/01/24

Copyright 2004 Sun Microsystems, Inc. All rights reserved.
SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms."
    end

    artifact 763547 "ReadWriteLock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_classes
	class_ref 1002011 // ReadWriteLock
      end
      comment "@(#)ReadWriteLock.java	1.6 04/07/13

Copyright 2004 Sun Microsystems, Inc. All rights reserved.
SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms."
    end

    artifact 763675 "ReentrantReadWriteLock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.*;
${definition}"
      associated_classes
	class_ref 1002139 // ReentrantReadWriteLock
      end
      comment "@(#)ReentrantReadWriteLock.java	1.7 04/07/14

Copyright 2004 Sun Microsystems, Inc. All rights reserved.
SUN PROPRIETARY/CONFIDENTIAL. Use is subject to license terms."
    end
  end
end
