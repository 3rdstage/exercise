class RequiredModelMBean
!!!8304411.java!!!	RequiredModelMBean()

	if (tracing())
	    trace("RequiredModelMBean()","Entry and Exit");

	modelMBeanInfo = createDefaultModelMBeanInfo();
!!!8304539.java!!!	RequiredModelMBean(inout mbi : ModelMBeanInfo)

	if (tracing())
	    trace("RequiredModelMBean(MBeanInfo)","Entry");

	setModelMBeanInfo(mbi);

	if (tracing())
	    trace("RequiredModelMBean(MBeanInfo)","Exit");
!!!8304667.java!!!	setModelMBeanInfo(inout mbi : ModelMBeanInfo) : void
	
	if (tracing())
	    trace("setModelMBeanInfo(ModelMBeanInfo)","Entry");
	
	if (mbi == null) {
	    if (tracing())	
		trace("setModelMBeanInfo(ModelMBeanInfo)",
		      "ModelMBeanInfo is null: Raising exception.");
	    final RuntimeException x = new
		IllegalArgumentException("ModelMBeanInfo must not be null");
	    final String exceptionText =
		"Exception occured trying to initialize the " +
		"ModelMBeanInfo of the RequiredModelMBean";
	    throw new RuntimeOperationsException(x,exceptionText);
	}

	if (registered) {
	    if (tracing())	
		trace("setModelMBeanInfo(ModelMBeanInfo)",
		      "RequiredMBean is registered: Raising exception.");
	    final String exceptionText =
		"Exception occured trying to set the " +
		"ModelMBeanInfo of the RequiredModelMBean";
	    final RuntimeException x = new IllegalStateException(
	     "cannot call setModelMBeanInfo while ModelMBean is registered");
	    throw new RuntimeOperationsException(x,exceptionText);
	}

	if (tracing()) {
	    trace("setModelMBeanInfo(ModelMBeanInfo)",
		  "Setting ModelMBeanInfo to " + printModelMBeanInfo(mbi));
	    trace("setModelMBeanInfo(ModelMBeanInfo)",
		  "ModelMBeanInfo notifications has " +
		  (mbi.getNotifications()).length + " elements");
	}

	modelMBeanInfo = (ModelMBeanInfo)mbi.clone();
	
	if (tracing())
	    trace("setModelMBeanInfo(ModelMBeanInfo)","set mbeanInfo to: "+
		  printModelMBeanInfo(modelMBeanInfo));
	
	if (tracing())
	    trace("setModelMBeanInfo(ModelMBeanInfo)","Exit");
!!!8304795.java!!!	setManagedResource(inout mr : Object, in mr_type : String) : void
	if (tracing())
	    trace("setManagedResource(Object,String)","Entry");

	// check that the mr_type is supported by this JMXAgent
	// only "objectReference" is supported
	if ((mr_type == null) ||
	    (! mr_type.equalsIgnoreCase("objectReference"))) {
	    if (tracing())
		trace("setManagedResource(Object,String)",
		      "Managed Resouce Type is not supported: " + mr_type);
	
	    throw new InvalidTargetObjectTypeException(mr_type);
	}

	if (tracing())
	    trace("setManagedResource(Object,String)",
		  "Managed Resouce is valid");

	managedResource = mr;
		
	if (tracing())
	    trace("setManagedResource(Object, String)", "Exit");
!!!8304923.java!!!	load() : void
	final ServiceNotFoundException x = new ServiceNotFoundException(
			        "Persistence not supported for this MBean");
	throw new MBeanException(x, x.getMessage());
!!!8305051.java!!!	store() : void
	final ServiceNotFoundException x = new ServiceNotFoundException(
			        "Persistence not supported for this MBean");
	throw new MBeanException(x, x.getMessage());
!!!8305179.java!!!	resolveForCacheValue(inout descr : Descriptor) : Object
	if (tracing())
	    trace("resolveForCacheValue(Descriptor)","Entry");

	Object response = null;
	boolean resetValue = false, returnCachedValue = true;
	long currencyPeriod = 0;

	if (descr == null) {
	    if (tracing())
		trace("resolveForCacheValue(Descriptor)",
		      "Input Descriptor is null");
	    return response;
	}

	if (tracing())
	    trace("resolveForCacheValue(Descriptor)","descriptor is " +
		  descr.toString());

	final Descriptor mmbDescr = modelMBeanInfo.getMBeanDescriptor();
	if (mmbDescr == null) {
	    if (tracing())
		trace("resolveForCacheValue(Descriptor)",
		      "MBean Descriptor is null");
	    //return response;
	}

	Object objExpTime = descr.getFieldValue("currencyTimeLimit");

	String expTime;
	if (objExpTime != null) {	
	    expTime = objExpTime.toString();
	} else {
	    expTime = null;
	}

	if ((expTime == null) && (mmbDescr != null)) {
	    objExpTime = mmbDescr.getFieldValue("currencyTimeLimit");
	    if (objExpTime != null) {		
		expTime = objExpTime.toString();
	    } else {
		expTime = null;
	    }	
	}

	if (expTime != null) {
	    if (tracing())
		trace("resolveForCacheValue(Descriptor)",
		      "currencyTimeLimit: " + expTime);

	    // convert seconds to milliseconds for time comparison
	    currencyPeriod = ((new Long(expTime)).longValue()) * 1000;	
	    if (currencyPeriod < 0) {
		/* if currencyTimeLimit is -1 then value is never cached */
		returnCachedValue = false;
		resetValue = true;
		if (tracing())
		    trace("resolveForCacheValue(Descriptor)",
			  currencyPeriod + ": never Cached");
	    } else if (currencyPeriod == 0) {
		/* if currencyTimeLimit is 0 then value is always cached */
		returnCachedValue = true;
		resetValue = false;
		if (tracing())
		    trace("resolveForCacheValue(Descriptor)",
			  "always valid Cache");
	    } else {
		Object objtStamp =
		    descr.getFieldValue("lastUpdatedTimeStamp");

		String tStamp;
		if (objtStamp != null) tStamp = objtStamp.toString();
		else tStamp = null;
		
		if (tracing())
		    trace("resolveForCacheValue(Descriptor)",
			  "lastUpdatedTimeStamp: " + tStamp);

		if (tStamp == null)
		    tStamp = "0";
	
		long lastTime = (new Long(tStamp)).longValue();

		if (tracing())
		    trace("resolveForCacheValue(Descriptor)",
			  " currencyPeriod:" + currencyPeriod +
			  " lastUpdatedTimeStamp:" + lastTime);

		long now = (new Date()).getTime();

		if (now < (lastTime + currencyPeriod)) {
		    returnCachedValue = true;
		    resetValue = false;
		    if (tracing())
			trace("resolveForCacheValue(Descriptor)",
			      " timed valid Cache for " + now + " < " +
			      (lastTime + currencyPeriod));
		} else { /* value is expired */
		    returnCachedValue = false;
		    resetValue = true;
		    if (tracing())
			trace("resolveForCacheValue(Descriptor)",
			      "timed expired cache for " + now + " > " +
			      (lastTime + currencyPeriod));
		}
	    }

	    if (tracing())
		trace("resolveForCacheValue(Descriptor)",
		      "returnCachedValue:" + returnCachedValue +
		      " resetValue: " + resetValue);

	    if (returnCachedValue == true) {
		Object currValue = descr.getFieldValue("value");
		if (currValue != null) {
		    /* error/validity check return value here */
		    response = currValue;
		    /* need to cast string cached value to type */
		    if (tracing())
			trace("resolveForCacheValue(Descriptor)",
			      "valid Cache value: " + currValue);
					
		} else {
		    response = null;
		    if (tracing())
			trace("resolveForCacheValue(Descriptor)",
			      "no Cached value");
		}
	    }

	    if (resetValue == true) {
		/* value is not current, so remove it */
		descr.removeField("lastUpdatedTimeStamp");
		descr.removeField("value");
		response = null;
		modelMBeanInfo.setDescriptor(descr,null);
		if (tracing())
		    trace("resolveForCacheValue(Descriptor)",
			  "reset cached value to null");
	    }
	}

	if (tracing())
	    trace("resolveForCache(Descriptor)","Exit");

	return response;
!!!8305307.java!!!	getMBeanInfo() : MBeanInfo
	
	if (tracing())
	    trace("getMBeanInfo()","Entry and Exit");

	if (modelMBeanInfo == null) {
	    if (tracing())
		trace("getMBeanInfo()","modelMBeanInfo is null");
	    modelMBeanInfo = createDefaultModelMBeanInfo();
	    //return new ModelMBeanInfo(" ", "", null, null, null, null);
	}

	if (tracing()) {
	    trace("getMBeanInfo()","ModelMBeanInfo is " +
		  modelMBeanInfo.getClassName() + " for " +
		  modelMBeanInfo.getDescription());
	    trace("getMBeanInfo()",printModelMBeanInfo(modelMBeanInfo));
	}

	return((MBeanInfo) ((ModelMBeanInfo)modelMBeanInfo).clone());
!!!8305435.java!!!	printModelMBeanInfo(inout info : ModelMBeanInfo) : String
	final StringBuffer retStr = new StringBuffer();
	if (info == null) {
	    if (tracing())
		trace("printModelMBeanInfo(ModelMBeanInfo)",
		      "ModelMBeanInfo to print is null, " +
		      "printing local ModelMBeanInfo");
	    info = modelMBeanInfo;
	}

	retStr.append("\nMBeanInfo for ModelMBean is:");
	retStr.append("\nCLASSNAME: \t"+ info.getClassName());
	retStr.append("\nDESCRIPTION: \t"+ info.getDescription());


	try {
	    retStr.append("\nMBEAN DESCRIPTOR: \t"+
			  info.getMBeanDescriptor());
	} catch (Exception e) {
	    retStr.append("\nMBEAN DESCRIPTOR: \t" + " is invalid");
	}

	retStr.append("\nATTRIBUTES");

	final MBeanAttributeInfo[] attrInfo = info.getAttributes();
	if ((attrInfo != null) && (attrInfo.length>0)) {
	    for (int i=0; i<attrInfo.length; i++) {
		final ModelMBeanAttributeInfo attInfo =
		    (ModelMBeanAttributeInfo)attrInfo[i];
		retStr.append(" ** NAME: \t"+ attInfo.getName());
		retStr.append("    DESCR: \t"+ attInfo.getDescription());
		retStr.append("    TYPE: \t"+ attInfo.getType() +
			      "    READ: \t"+ attInfo.isReadable() +
			      "    WRITE: \t"+ attInfo.isWritable());
		retStr.append("    DESCRIPTOR: " +
			      attInfo.getDescriptor().toString());
	    }
	} else {
	    retStr.append(" ** No attributes **");
	}

	retStr.append("\nCONSTRUCTORS");
	final MBeanConstructorInfo[] constrInfo = info.getConstructors();
	if ((constrInfo != null) && (constrInfo.length > 0 )) {
	    for (int i=0; i<constrInfo.length; i++) {
		final ModelMBeanConstructorInfo ctorInfo =
		    (ModelMBeanConstructorInfo)constrInfo[i];
		retStr.append(" ** NAME: \t"+ ctorInfo.getName());
		retStr.append("    DESCR: \t"+
			      ctorInfo.getDescription());
		retStr.append("    PARAM: \t"+
			      ctorInfo.getSignature().length +
			      " parameter(s)");
		retStr.append("    DESCRIPTOR: " +
			      ctorInfo.getDescriptor().toString());
	    }
	} else {
	    retStr.append(" ** No Constructors **");
	}
		
	retStr.append("\nOPERATIONS");
	final MBeanOperationInfo[] opsInfo = info.getOperations();
	if ((opsInfo != null) && (opsInfo.length>0)) {
	    for (int i=0; i<opsInfo.length; i++) {
		final ModelMBeanOperationInfo operInfo =
		    (ModelMBeanOperationInfo)opsInfo[i];
		retStr.append(" ** NAME: \t"+ operInfo.getName());
		retStr.append("    DESCR: \t"+ operInfo.getDescription());
		retStr.append("    PARAM: \t"+
			      operInfo.getSignature().length +
			      " parameter(s)");
		retStr.append("    DESCRIPTOR: " +
			      operInfo.getDescriptor().toString());
	    }
	} else {
	    retStr.append(" ** No operations ** ");
	}

	retStr.append("\nNOTIFICATIONS");

	MBeanNotificationInfo[] notifInfo = info.getNotifications();
	if ((notifInfo != null) && (notifInfo.length>0)) {
	    for (int i=0; i<notifInfo.length; i++) {
		final ModelMBeanNotificationInfo nInfo =
		    (ModelMBeanNotificationInfo)notifInfo[i];
		retStr.append(" ** NAME: \t"+ nInfo.getName());
		retStr.append("    DESCR: \t"+ nInfo.getDescription());
		retStr.append("    DESCRIPTOR: " +
			      nInfo.getDescriptor().toString());
	    }
	} else {
	    retStr.append(" ** No notifications **");
	}

	retStr.append(" ** ModelMBean: End of MBeanInfo ** ");

	return retStr.toString();
!!!8305563.java!!!	echo(in txt : String) : void
	trace("echo(txt)",txt);
!!!8305691.java!!!	invoke(in opName : String, inout opArgs : Object, in sig : String) : Object
	final boolean tracing = tracing();

	if (tracing)
	    trace("invoke(String, Object[], String[])","Entry");

	if (opName == null) {
	    final RuntimeException x =
		new IllegalArgumentException("Method name must not be null");
	    throw new RuntimeOperationsException(x,
                      "An exception occured while trying to " +
		      "invoke a method on a RequiredModelMBean");
	}

	String opClassName = null;
	String opMethodName;

	// Parse for class name and method
	int opSplitter = opName.lastIndexOf(".");
	if (opSplitter > 0) {
	    opClassName = opName.substring(0,opSplitter);
	    opMethodName = opName.substring(opSplitter+1);
	} else
	    opMethodName = opName;

	/* Ignore anything after a left paren.  We keep this for
	   compatibility but it isn't specified.  */
	opSplitter = opMethodName.indexOf("(");
	if (opSplitter > 0)
	    opMethodName = opMethodName.substring(0,opSplitter);
	
	if (tracing)
	    trace("invoke(String, Object[], String[])",
		  "Finding operation " + opName + " as " + opMethodName);

	ModelMBeanOperationInfo opInfo =
	    modelMBeanInfo.getOperation(opMethodName);
	if (opInfo == null) {
	    final String msg =
		"Operation " + opName + " not in ModelMBeanInfo";
	    throw new MBeanException(new ServiceNotFoundException(msg), msg);
	}

	final Descriptor opDescr = opInfo.getDescriptor();
	if (opDescr == null) {	
	    final String msg = "Operation descriptor null";
	    throw new MBeanException(new ServiceNotFoundException(msg), msg);
	}

	final Object cached = resolveForCacheValue(opDescr);
	if (cached != null) {
	    if (tracing)
		trace("invoke(String, Object[], String[])",
		      "Returning cached value");
	    return cached;
	}

        if (opClassName == null)
	    opClassName = (String) opDescr.getFieldValue("class");
	// may still be null now

	opMethodName = (String) opDescr.getFieldValue("name");
	if (opMethodName == null) {
	    final String msg =
		"Method descriptor must include `name' field";
	    throw new MBeanException(new ServiceNotFoundException(msg), msg);
	}

	final String targetTypeField = (String)
	    opDescr.getFieldValue("targetType");
	if (targetTypeField != null
	    && !targetTypeField.equalsIgnoreCase("objectReference")) {
	    final String msg =
		"Target type must be objectReference: " + targetTypeField;
	    throw new MBeanException(new InvalidTargetObjectTypeException(msg),
				     msg);
	}

	final Object targetObjectField = opDescr.getFieldValue("targetObject");
	if (tracing && targetObjectField != null)
	    trace("invoke(String, Object[], String[])",
		  "Found target object in descriptor");

	/* Now look for the method, either in RequiredModelMBean itself
	   or in the target object.  Set "method" and "targetObject"
	   appropriately.  */
	Method method;
	Object targetObject;

	method = findRMMBMethod(opMethodName, targetObjectField,
				opClassName, sig);

	if (method != null)
	    targetObject = this;
	else {
	    if (tracing)
		trace("invoke(String, Object[], String[])",
		      "looking for method in managedResource class");
	    if (targetObjectField != null)
		targetObject = targetObjectField;
	    else {
		targetObject = managedResource;
		if (targetObject == null) {
		    final String msg =
			"managedResource for invoke " + opName +
			" is null";
		    Exception snfe = new ServiceNotFoundException(msg);
		    throw new MBeanException(snfe);
		}
	    }

	    final Class targetClass;

	    if (opClassName != null) {
		try {
		    final ClassLoader targetClassLoader =
			targetObject.getClass().getClassLoader();
		    targetClass = Class.forName(opClassName, false,
						targetClassLoader);
		} catch (ClassNotFoundException e) {
		    final String msg =
			"class for invoke " + opName + " not found";
		    throw new ReflectionException(e, msg);
		}
	    } else
		targetClass = targetObject.getClass();

	    method = resolveMethod(targetClass, opMethodName, sig);
	}

	if (tracing)
	    trace("invoke(String, Object[], String[])",
		  "found " + opMethodName + ", now invoking");

	final Object result =
	    invokeMethod(opName, method, targetObject, opArgs);

	if (tracing)
	    trace("invoke(String, Object[], String[])",
		  "successfully invoked method");

	if (result != null)
	    cacheResult(opInfo, opDescr, result);

	return result;
!!!8305819.java!!!	resolveMethod(inout targetClass : Class, in opMethodName : String, in sig : String) : Method
	final boolean tracing = tracing();

	if (tracing)
	    trace("resolveMethod",
		  "resolving " + targetClass + "." + opMethodName);

	final Class[] argClasses;

	if (sig == null)
	    argClasses = null;
	else {
	    final ClassLoader targetClassLoader = targetClass.getClassLoader();
	    argClasses = new Class[sig.length];
	    for (int i = 0; i < sig.length; i++) {
		if (tracing)
		    trace("resolveMethod", "resolve type " + sig[i]);
		argClasses[i] = (Class) primitiveClassMap.get(sig[i]);
		if (argClasses[i] == null) {
		    try {
			argClasses[i] =
			    Class.forName(sig[i], false, targetClassLoader);
		    } catch (ClassNotFoundException e) {
			if (tracing)
			    trace("resolveMethod", "class not found");
			final String msg = "Parameter class not found";
			throw new ReflectionException(e, msg);
		    }
		}
	    }
	}

	try {
	    return targetClass.getMethod(opMethodName, argClasses);
	} catch (NoSuchMethodException e) {
	    final String msg =
		"Target method not found: " + targetClass.getName() + "." +
		opMethodName;
	    throw new ReflectionException(e, msg);
	}
!!!8305947.java!!!	findRMMBMethod(in opMethodName : String, inout targetObjectField : Object, in opClassName : String, in sig : String) : Method
	if (tracing())
	    trace("invoke(String, Object[], String[])",
		  "looking for method in RequiredModelMBean class");
	if (!isRMMBMethodName(opMethodName))
	    return null;
	if (targetObjectField != null)
	    return null;
	final Class rmmbClass = RequiredModelMBean.class;
	final Class targetClass;
	if (opClassName == null)
	    targetClass = rmmbClass;
	else {
	    try {
		final ClassLoader targetClassLoader =
		    rmmbClass.getClassLoader();
		targetClass = Class.forName(opClassName, false,
					    targetClassLoader);
		if (!rmmbClass.isAssignableFrom(targetClass))
		    return null;
	    } catch (ClassNotFoundException e) {
		return null;
	    }
	}
	try {
	    return resolveMethod(targetClass, opMethodName, sig);
	} catch (ReflectionException e) {
	    return null;
	}
!!!8306075.java!!!	invokeMethod(in opName : String, inout method : Method, inout targetObject : Object, inout opArgs : Object) : Object
	try {
            ReflectUtil.checkPackageAccess(method.getDeclaringClass());
	    return MethodUtil.invoke(method, targetObject, opArgs);
	} catch (RuntimeErrorException ree) {
	    throw new RuntimeOperationsException(ree,
		      "RuntimeException occured in RequiredModelMBean "+
		      "while trying to invoke operation " + opName);
	} catch (RuntimeException re) {
	    throw new RuntimeOperationsException(re,
		      "RuntimeException occured in RequiredModelMBean "+
		      "while trying to invoke operation " + opName);
	} catch (IllegalAccessException iae) {
	    throw new ReflectionException(iae,
		      "IllegalAccessException occured in " +
		      "RequiredModelMBean while trying to " +
		      "invoke operation " + opName);
	} catch (InvocationTargetException ite) {
	    Throwable mmbTargEx = ite.getTargetException();
	    if (mmbTargEx instanceof RuntimeException) {
		throw new MBeanException ((RuntimeException)mmbTargEx,
		      "RuntimeException thrown in RequiredModelMBean "+
		      "while trying to invoke operation " + opName);
	    } else if (mmbTargEx instanceof Error) {
		throw new RuntimeErrorException((Error)mmbTargEx,
		      "Error occured in RequiredModelMBean while trying "+
		      "to invoke operation " + opName);
	    } else if (mmbTargEx instanceof ReflectionException) {
		throw (ReflectionException) mmbTargEx;
	    } else {
		throw new MBeanException ((Exception)mmbTargEx,
		      "Exception thrown in RequiredModelMBean "+
		      "while trying to invoke operation " + opName);
	    }
	} catch (Error err) {
	    throw new RuntimeErrorException(err,
		  "Error occured in RequiredModelMBean while trying "+
		  "to invoke operation " + opName);
	} catch (Exception e) {
	    throw new ReflectionException(e,
		  "Exception occured in RequiredModelMBean while " +
		  "trying to invoke operation " + opName);
	}
!!!8306203.java!!!	cacheResult(inout opInfo : ModelMBeanOperationInfo, inout opDescr : Descriptor, inout result : Object) : void

	Descriptor mmbDesc =
	    modelMBeanInfo.getMBeanDescriptor();

	Object objctl =
	    opDescr.getFieldValue("currencyTimeLimit");
	String ctl;
	if (objctl != null) {		
	    ctl = objctl.toString();
	} else {
	    ctl = null;
	}					
	if ((ctl == null) && (mmbDesc != null)) {
	    objctl =
		mmbDesc.getFieldValue("currencyTimeLimit");
	    if (objctl != null) {		
		ctl = objctl.toString();
	    } else {
		ctl = null;
	    }
	}
	if ((ctl != null) && !(ctl.equals("-1"))) {
	    opDescr.setField("value", result);
	    opDescr.setField("lastUpdatedTimeStamp",
	      (new Long((new Date()).getTime())).toString());

	    modelMBeanInfo.setDescriptor(opDescr,
					 "operation");
	    if (tracing()) {
		trace("invoke(String,Object[],Object[])",
		      "new descriptor is " +
		      opDescr.toString());
	    }
	}
!!!8306331.java!!!	isRMMBMethodName(in name : String) : boolean
	if (rmmbMethodNames == null) {
	    try {
		Set names = new HashSet();
		Method[] methods = RequiredModelMBean.class.getMethods();
		for (int i = 0; i < methods.length; i++)
		    names.add(methods[i].getName());
		rmmbMethodNames = names;
	    } catch (Exception e) {
		return true;
		// This is only an optimization so we'll go on to discover
		// whether the name really is an RMMB method.
	    }
	}
	return rmmbMethodNames.contains(name);
!!!8306459.java!!!	getAttribute(in attrName : String) : Object
	if (attrName == null)
	    throw new RuntimeOperationsException(new
		IllegalArgumentException("attributeName must not be null"),
		"Exception occured trying to get attribute of a " +
	        "RequiredModelMBean");

	if (tracing())
	    trace("getAttribute(String)","Entry with" + attrName);

	/* Check attributeDescriptor for getMethod */
	ModelMBeanAttributeInfo attrInfo=null;
	Descriptor attrDescr=null;
	Object response = null;

	try {
	    if (modelMBeanInfo == null)
		throw new AttributeNotFoundException(
                      "getAttribute failed: ModelMBeanInfo not found for "+
		      attrName);

	    attrInfo = modelMBeanInfo.getAttribute(attrName);
	    Descriptor mmbDesc = modelMBeanInfo.getMBeanDescriptor();

	    if (attrInfo == null)
		throw new AttributeNotFoundException("getAttribute failed:"+
		      " ModelMBeanAttributeInfo not found for " + attrName);
	
	    attrDescr = attrInfo.getDescriptor();
	    if (attrDescr != null) {
		if (!attrInfo.isReadable()) 			
		    throw new AttributeNotFoundException(
			  "getAttribute failed: " + attrName +
			  " is not readable ");
		
		response = resolveForCacheValue(attrDescr);

		/* return current cached value */
		if (tracing())
		    trace("getAttribute(String)","*** cached value is " +
			  response);

		if (response == null) {
		    /* no cached value, run getMethod */
		    if (tracing())
			trace("getAttribute(String)",
			      "**** cached value is null" +
			      " - " + "getting getMethod");
		    String attrGetMethod =
			(String)(attrDescr.getFieldValue("getMethod"));

		    if (attrGetMethod != null) {	
			/* run method from operations descriptor */
			if (tracing())
			    trace("getAttribute(String)",
				  "invoking a getMethod for " +  attrName);

			Object getResponse =
			    invoke(attrGetMethod, new Object[] {},
				   new String[] {});

			if (getResponse != null) {
			    // error/validity check return value here
			    if (tracing())
				trace("getAttribute(String)",
				 "got a non-null response from getMethod\n");

			    response = getResponse;

			    // change cached value in attribute descriptor
			    Object objctl =
				attrDescr.getFieldValue("currencyTimeLimit");

			    String ctl;
			    if (objctl != null) ctl = objctl.toString();
			    else ctl = null;
			
			    if ((ctl == null) && (mmbDesc != null)) {
				objctl = mmbDesc.
				    getFieldValue("currencyTimeLimit");
				if (objctl != null) ctl = objctl.toString();
				else ctl = null;
			    }

			    if ((ctl != null) && !(ctl.equals("-1"))) {
				if (tracing())
				    trace("getAttribute(String)",
					  "setting cached value and "+
					  "lastUpdatedTime in descriptor");

				attrDescr.setField("value", response);
				final String stamp =
				    (new Long((new Date()).getTime())).
				    toString();
				attrDescr.setField("lastUpdatedTimeStamp",
						   stamp);
				attrInfo.setDescriptor(attrDescr);
				modelMBeanInfo.setDescriptor(attrDescr,
							     "attribute");
				if (tracing()) {
				    trace("getAttribute(String)",
					  "new descriptor is " +
					  attrDescr.toString());
				    trace("getAttribute(String)","local: "+
					  "AttributeInfo descriptor is "+
					  attrInfo.getDescriptor().
					  toString());
				    final String attStr = modelMBeanInfo.
					getDescriptor(attrName,"attribute").
					toString();
				    trace("getAttribute(String)",
					  "modelMBeanInfo: " +
					  "AttributeInfo descriptor is " +
					  attStr);
				}
			    }
			} else {
			    // response was invalid or really returned null
			    if (tracing())
				trace("getAttribute(String)",
				     "got a null response from getMethod\n");
			    response = null;
			}
		    } else {
			// not getMethod so return descriptor (default) value
			String qualifier="";
			response = attrDescr.getFieldValue("value");
			if (response == null) {
			    qualifier="default ";
			    response = attrDescr.getFieldValue("default");
			}
			if (tracing())
			    trace("getAttribute(String)",
				  "could not find getMethod for " +
				  attrName + ", returning descriptor " +
				  qualifier + "value");
			// !! cast response to right class
		    }
		}

		// make sure response class matches type field
		String respType = attrInfo.getType();
		if (response != null) {
		    String responseClass = response.getClass().getName();
		    if (!respType.equals(responseClass)) {
			boolean wrongType = false;
                        boolean primitiveType = false;
                        boolean correspondingTypes = false;
                        for (int i = 0; i < primitiveTypes.length; i++) {
                            if (respType.equals(primitiveTypes[i])) {
                                primitiveType = true;
                                if (responseClass.equals(primitiveWrappers[i]))
                                    correspondingTypes = true;
                                break;
                            }
                        }
			if (primitiveType) {
			    // inequality may come from primitive/wrapper class
			    if (!correspondingTypes)
				wrongType = true;
			} else {
			    // inequality may come from type subclassing
			    boolean subtype;
			    try {
				ClassLoader cl =
				    response.getClass().getClassLoader();
				Class c = Class.forName(respType, true, cl);
				subtype = c.isInstance(response);
			    } catch (Exception e) {
				subtype = false;
				if (tracing())
				    traceX("getAttribute(String)", e);
			    }
			    if (!subtype)
				wrongType = true;
			}
			if (wrongType) {
			    if (tracing())
				trace("getAttribute(String)",
				      "Wrong response type '" + respType + "'");
			    // throw exception, didn't get
			    // back right attribute type
			    throw new MBeanException(
			      new InvalidAttributeValueException(
			        "Wrong value type received for get attribute"),
			      "An exception occurred while trying to get an " +
			      "attribute value through a RequiredModelMBean");
			}
                    }
		}
	    } else {
		if (tracing())
		    trace("getAttribute(String)","getMethod failed " +
			  attrName + " not in attributeDescriptor\n");
		throw new MBeanException(new
		    InvalidAttributeValueException(
		    "Unable to resolve attribute value, " +
		    "no getMethod defined in descriptor for attribute"),
		    "An exception occured while trying to get an "+
		    "attribute value through a RequiredModelMBean");
	    }

	} catch (MBeanException mbe) {
	    throw mbe;
	} catch (AttributeNotFoundException t) {
	    throw t;
	} catch (Exception e) {
	    if (tracing())
		trace("getAttribute(String)","getMethod failed with " +
		      e.getMessage() + " exception type " +
		      (e.getClass()).toString());
	    throw new MBeanException(e,"An exception occured while trying "+
		      "to get an attribute value: " + e.getMessage());
	}
		
	if (tracing())
	    trace("getAttribute(String)","Exit");

	return response;
!!!8306587.java!!!	getAttributes(in attrNames : String) : AttributeList
	if (tracing())
	    trace("getAttributes(String[])","Entry");

	AttributeList responseList = null;
	if (attrNames == null)
	    throw new RuntimeOperationsException(new
		IllegalArgumentException("attributeNames must not be null"),
		"Exception occured trying to get attributes of a "+
		"RequiredModelMBean");

	responseList = new AttributeList();
	for (int i = 0; i < attrNames.length; i++) {
	    try {
		responseList.add(new Attribute(attrNames[i],
				     getAttribute(attrNames[i])));
	    } catch (Exception e) {
		// eat exceptions because interface doesn't have an
		// exception on it
		error("getAttributes(String[])","Failed to get \"" +
		      attrNames[i] + "\": " + e);
		traceX("getAttributes(String[])",e);
	    }
	}
	
	if (tracing())
	    trace("getAttributes(String[])","Exit");
		
	return responseList;
!!!8306715.java!!!	setAttribute(inout attribute : Attribute) : void
	
	if (tracing())
	    trace("setAttribute()","Entry");

	if (attribute == null)
	    throw new RuntimeOperationsException(new
		IllegalArgumentException("attribute must not be null"),
		"Exception occured trying to set an attribute of a "+
		"RequiredModelMBean");
	
	/* run setMethod if there is one */
	/* return cached value if its current */
	/* set cached value in descriptor and set date/time */
	/* send attribute change Notification */
	/* check persistence policy and persist if need be */
	String attrName = attribute.getName();
	Object attrValue = attribute.getValue();
	boolean updateDescriptor = false;

	ModelMBeanAttributeInfo attrInfo =
	    modelMBeanInfo.getAttribute(attrName);

	if (attrInfo == null)
	    throw new AttributeNotFoundException("setAttribute failed: " +
					       attrName + " is not found ");

	Descriptor mmbDesc = modelMBeanInfo.getMBeanDescriptor();
	Descriptor attrDescr = attrInfo.getDescriptor();

	if (attrDescr != null) {
	    if (!attrInfo.isWritable())	
		throw new AttributeNotFoundException("setAttribute failed: "
					  + attrName + " is not writable ");

	    Object setResponse = null;
	    String attrSetMethod = (String)
		(attrDescr.getFieldValue("setMethod"));
	    String attrType = (String)(attrInfo.getType());
	    Object currValue = "Unknown";

	    try {
		currValue = this.getAttribute(attrName);
	    } catch (Throwable t) {			
		// OK: Default "Unknown" value used for unknown attribute
	    }

	    Attribute oldAttr = new Attribute(attrName, currValue);
					
	    /* run method from operations descriptor */
	    if (attrSetMethod == null) {
		if (attrValue != null) {
		    try {
			final Class  clazz    = loadClass(attrType);
			if (! clazz.isInstance(attrValue))  throw new
			    InvalidAttributeValueException(clazz.getName() +
							   " expected, "   +
					    attrValue.getClass().getName() +
							   " received.");
		    } catch (ClassNotFoundException x) {
			error("setAttribute","Class " + attrType +
			      " for attribute " + attrName + " not found: " +
			      x);
			debug("setAttribute",x);
		    }
		}
		updateDescriptor = true;
	    } else {
	    setResponse = invoke(attrSetMethod,
				 (new Object[] {attrValue}),
				 (new String[] {attrType}) );
	    }
		
	    /* change cached value */
	    Object objctl = attrDescr.getFieldValue("currencyTimeLimit");
	    String ctl;
	    if (objctl != null) ctl = objctl.toString();
	    else ctl = null;
					
	    if ((ctl == null) && (mmbDesc != null)) {		
		objctl = mmbDesc.getFieldValue("currencyTimeLimit");
		if (objctl != null) ctl = objctl.toString();
		else ctl = null;
	    }
		
	    final boolean updateCache = ((ctl != null) && !(ctl.equals("-1")));
	    if (updateCache || updateDescriptor) {
		if (tracing())
		    trace("setAttribute()","setting cached value of " +
			  attrName + " to " + attrValue);

		attrDescr.setField("value", attrValue);

		if (updateCache) {
		    final String currtime =
			(new Long((new Date()).getTime())).toString();

		attrDescr.setField("lastUpdatedTimeStamp", currtime);
		}

		attrInfo.setDescriptor(attrDescr);
			
		modelMBeanInfo.setDescriptor(attrDescr,"attribute");
		if (tracing()) {
		    trace("setAttribute()","new descriptor is " +
			  attrDescr.toString());
		    trace("setAttribute()","AttributeInfo descriptor is " +
			  attrInfo.getDescriptor().toString());
		    trace("setAttribute()","AttributeInfo descriptor is " +
			  modelMBeanInfo.getDescriptor(attrName,"attribute")
			  .toString());
		}
			
	    }

	    if (tracing())
		trace("setAttribute()","sending sendAttributeNotification");
		
	    sendAttributeChangeNotification(oldAttr,attribute);
		
	} else { // if descriptor ... else no descriptor
				
	    if (tracing())
		trace("setAttribute(String)","setMethod failed "+attrName+
		      " not in attributeDescriptor\n");

	    throw new InvalidAttributeValueException(
                      "Unable to resolve attribute value, "+
		      "no defined in descriptor for attribute");
	} // else no descriptor
			
	if (tracing())
	    trace("setAttribute(Attribute)","Exit");

!!!8306843.java!!!	setAttributes(inout attributes : AttributeList) : AttributeList

	if (tracing())
	    trace("setAttributes(AttributeList)","Entry");

	if (attributes == null)
	    throw new RuntimeOperationsException(new
		IllegalArgumentException("attributes must not be null"),
		"Exception occured trying to set attributes of a "+
		"RequiredModelMBean");

	final AttributeList responseList = new AttributeList();

	// Go through the list of attributes
	for (Iterator i = attributes.iterator(); i.hasNext();) {
	    final Attribute attr = (Attribute) i.next();
	    try {
		setAttribute(attr);
		responseList.add(attr);
	    } catch (Exception excep) {
		responseList.remove(attr);
	    }
	}

	return responseList;
!!!8306971.java!!!	createDefaultModelMBeanInfo() : ModelMBeanInfo
	return(new ModelMBeanInfoSupport((this.getClass().getName()),
		   "Default ModelMBean", null, null, null, null));
!!!8307099.java!!!	writeToLog(in logFileName : String, in logEntry : String) : void
	
	PrintStream logOut = null;
	FileOutputStream fos = null;
	if (tracing()) trace("writeToLog()","Notification Logging to " +
			     logFileName + ": " + logEntry);
	if ((logFileName == null) || (logEntry == null)) {
	    if (tracing()) trace("writeToLog()","Bad input parameters");
	    return;
	}

	try {
	    fos = new FileOutputStream(logFileName, true);
	    logOut = new PrintStream(fos);
	    logOut.println(logEntry);
            logOut.close();
	    if (tracing()) trace("writeToLog()",
				 "Successfully opened log " + logFileName);
	} catch (Exception e) {
	    if (tracing())
		trace("writeToLog","Exception " + e.toString() +
		      " trying to write to the Notification log file " +
		      logFileName);
	    throw e;
	}		
!!!8307227.java!!!	addNotificationListener(inout listener : NotificationListener, inout filter : NotificationFilter, inout handback : Object) : void
	final String ftag = "addNotificationListener(NotificationListener, NotificationFilter, Object)";
	if (tracing())
	    trace(ftag,"Entry");
		
	if (listener == null)
	    throw new IllegalArgumentException(
                  "notification listener must not be null");

	if (generalBroadcaster == null)
	    generalBroadcaster = new NotificationBroadcasterSupport();

	generalBroadcaster.addNotificationListener(listener, filter,
						   handback);
	if (tracing()) {
	    trace(ftag,"NotificationListener added");
	    trace(ftag,"Exit");
	}
!!!8307355.java!!!	removeNotificationListener(inout listener : NotificationListener) : void
	if (listener == null)
	    throw new ListenerNotFoundException(
		      "Notification listener is null");
	
	final String ftag="removeNotificationListener(NotificationListener)";

	if (tracing()) trace(ftag,"Entry");

	if (generalBroadcaster == null)
	    throw new ListenerNotFoundException(
                  "No notification listeners registered");
	
	
	generalBroadcaster.removeNotificationListener(listener);

	if (tracing()) trace(ftag,"Exit");
		
!!!8307483.java!!!	removeNotificationListener(inout listener : NotificationListener, inout filter : NotificationFilter, inout handback : Object) : void

	if (listener == null)
	    throw new ListenerNotFoundException(
		      "Notification listener is null");
	
	final String ftag="removeNotificationListener(NotificationListener, NotificationFilter, Object)";

	if (tracing()) trace(ftag,"Entry");

	if (generalBroadcaster == null)
	    throw new ListenerNotFoundException(
                  "No notification listeners registered");
	
	
	generalBroadcaster.removeNotificationListener(listener,filter,
						      handback);

	if (tracing()) trace(ftag,"Exit");
		
!!!8307611.java!!!	sendNotification(inout ntfyObj : Notification) : void
	if (tracing())
	    trace("sendNotification(Notification)","Entry");

	if (ntfyObj == null)
	    throw new RuntimeOperationsException(new
		IllegalArgumentException("notification object must not be "+
					 "null"),
		"Exception occured trying to send a notification from a "+
		"RequiredModelMBean");
		
	
	// log notification if specified in descriptor		
	Descriptor ntfyDesc =
	    modelMBeanInfo.getDescriptor(ntfyObj.getType(),"notification");
	Descriptor mmbDesc = modelMBeanInfo.getMBeanDescriptor();

	if (ntfyDesc != null) {
	    String logging = (String) ntfyDesc.getFieldValue("log");

	    if (logging == null) {
		if (mmbDesc != null)
		    logging = (String) mmbDesc.getFieldValue("log");
	    }

	    if ((logging != null) &&
		(logging.equalsIgnoreCase("t") ||
		 logging.equalsIgnoreCase("true"))) {

		String logfile = (String) ntfyDesc.getFieldValue("logfile");
		if (logfile == null) {
		    if (mmbDesc != null)
			logfile = (String)mmbDesc.getFieldValue("logfile");
		}
		if (logfile != null) {				
		    try {
			writeToLog(logfile,"LogMsg: " +
			    ((new Date(ntfyObj.getTimeStamp())).toString())+
			    " " + ntfyObj.getType() + " " +
			    ntfyObj.getMessage() + " Severity = " +
			    (String)ntfyDesc.getFieldValue("severity"));
		    } catch (Exception e) {
			error("sendNotification(Notification)",
			      "Failed to log " + ntfyObj.getType() +
			      " notification: " + e);
			traceX("sendNotification(Notification)",e);
		    }
		}
	    }
	}
	if (generalBroadcaster != null) {
	    generalBroadcaster.sendNotification(ntfyObj);
	}

	if (tracing()) trace("sendNotification(Notification)",
		  "sendNotification sent provided notification object");
		
	if (tracing())
	    trace("sendNotification(Notification)","Exit");

!!!8307739.java!!!	sendNotification(in ntfyText : String) : void
	if (tracing())
	    trace("sendNotification(String)","Entry");

	if (ntfyText == null)
	    throw new RuntimeOperationsException(new
		IllegalArgumentException("notification message must not "+
					 "be null"),
		"Exception occured trying to send a text notification "+
		"from a ModelMBean");
		
	Notification myNtfyObj = new Notification("jmx.modelmbean.generic",
						  this, 1, ntfyText);
	sendNotification(myNtfyObj);
	if (tracing()) trace("sendNotification(string)",
			     "Notification sent");

	if (tracing())
	    trace("sendNotification(String)","Exit");
!!!8307867.java!!!	hasNotification(in info : ModelMBeanInfo, in notifName : String) : boolean
	try {
	    if (info == null) return false;
	    else return (info.getNotification(notifName)!=null);
	} catch (MBeanException x) {
	    return false;
	} catch (RuntimeOperationsException r) {
	    return false;
	}
!!!8307995.java!!!	makeGenericInfo() : ModelMBeanNotificationInfo
	final Descriptor genericDescriptor = new DescriptorSupport( new
	    String[] {
		"name=GENERIC",
		"descriptorType=notification",
		"log=T",
		"severity=6",
		"displayName=jmx.modelmbean.generic"} );
	
	return new ModelMBeanNotificationInfo(new
	    String[] {"jmx.modelmbean.generic"},
	    "GENERIC",
	    "A text notification has been issued by the managed resource",
	    genericDescriptor);
!!!8308123.java!!!	makeAttributeChangeInfo() : ModelMBeanNotificationInfo
	final Descriptor attributeDescriptor = new DescriptorSupport(new
	    String[] {
		"name=ATTRIBUTE_CHANGE",
		"descriptorType=notification",
		"log=T",
		"severity=6",
		"displayName=jmx.attribute.change"});

	return new ModelMBeanNotificationInfo(new
	    String[] {"jmx.attribute.change"},
	    "ATTRIBUTE_CHANGE",
	    "Signifies that an observed MBean attribute value has changed",
	    attributeDescriptor );
!!!8308251.java!!!	getNotificationInfo() : MBeanNotificationInfo
	if (tracing())
	   trace("getNotificationInfo()","Entry");

	// Using hasNotification() is not optimal, but shouldn't really
	// matter in this context...
	
	// hasGeneric==true if GENERIC notification is present.
	// (bug 4744667)
	final boolean hasGeneric = hasNotification(modelMBeanInfo,"GENERIC");

	// hasAttributeChange==true if ATTRIBUTE_CHANGE notification is
	// present.
	// (bug 4744667)
	final boolean hasAttributeChange =
	   hasNotification(modelMBeanInfo,"ATTRIBUTE_CHANGE");

	// User supplied list of notification infos.
	//
	final ModelMBeanNotificationInfo[] currInfo =
	   (ModelMBeanNotificationInfo[])modelMBeanInfo.getNotifications();

	// Length of the returned list of notification infos:
	//    length of user suplied list + possibly 1 for GENERIC, +
	//    possibly 1 for ATTRIBUTE_CHANGE
	//    (bug 4744667)
	final int len = ((currInfo==null?0:currInfo.length) +
			 (hasGeneric?0:1) + (hasAttributeChange?0:1));

	// Returned list of notification infos:
	//
	final ModelMBeanNotificationInfo[] respInfo =
	   new ModelMBeanNotificationInfo[len];

	// Preserve previous ordering (JMX 1.1)
	//
	
	// Counter of "standard" notification inserted before user
	// supplied notifications.
	//
	int inserted=0;
	if (!hasGeneric)
	    // We need to add description for GENERIC notification
	    // (bug 4744667)
	    respInfo[inserted++] = makeGenericInfo();
	

	if (!hasAttributeChange)
	    // We need to add description for ATTRIBUTE_CHANGE notification
	    // (bug 4744667)
	    respInfo[inserted++] = makeAttributeChangeInfo();

	// Now copy user supplied list in returned list.
	//
	final int count  = currInfo.length;
	final int offset = inserted;
	for (int j=0; j < count; j++) {
	    respInfo[offset+j] = (ModelMBeanNotificationInfo)(currInfo[j]);
	}

	if (tracing())
            trace("getNotificationInfo()","Exit");

	return respInfo;
!!!8308379.java!!!	addAttributeChangeNotificationListener(inout inlistener : NotificationListener, in inAttributeName : String, inout inhandback : Object) : void
	final String ftag="addAttributeChangeNotificationListener(NotificationListener, String, Object)";

	if (tracing()) trace(ftag,"Entry");

	if (inlistener == null)
	    throw new IllegalArgumentException(
                  "Listener to be registered must not be null");
		
		 	
	if (attributeBroadcaster == null)
	    attributeBroadcaster = new NotificationBroadcasterSupport();

	AttributeChangeNotificationFilter currFilter =
	    new AttributeChangeNotificationFilter();

	MBeanAttributeInfo[] attrInfo = modelMBeanInfo.getAttributes();
	boolean found = false;
	if (inAttributeName == null) {		
	    if ((attrInfo != null) && (attrInfo.length>0)) {
		for (int i=0; i<attrInfo.length; i++) {
		    currFilter.enableAttribute(attrInfo[i].getName());
		}
	    }
	} else {
	    if ((attrInfo != null) && (attrInfo.length>0)) {
		for (int i=0; i<attrInfo.length; i++) {
		    if (inAttributeName.equals(attrInfo[i].getName())) {
			found = true;
			currFilter.enableAttribute(inAttributeName);
			break;
		    }				
		}
		if (!found) {
		    throw new RuntimeOperationsException(new
			IllegalArgumentException(
                        "The attribute name does not exist"),
                        "Exception occured trying to add an "+
			"AttributeChangeNotification listener");
		}
	    }
	}

	if (tracing())
	    trace(ftag, "Set attribute change filter to " +
	    ((currFilter.getEnabledAttributes()).firstElement()).toString());

	attributeBroadcaster.addNotificationListener(inlistener,currFilter,
						     inhandback);
	if (tracing()) trace("addAttributeChangeNotificationListener",
			     "added for " + inAttributeName);
	
	if (tracing()) trace(ftag,"Exit");
!!!8308507.java!!!	removeAttributeChangeNotificationListener(inout inlistener : NotificationListener, in inAttributeName : String) : void
	if (inlistener == null) throw new
	    ListenerNotFoundException("Notification listener is null");
	
	final String ftag = "removeAttributeChangeNotificationListener(NotificationListener, String)";

	if (tracing()) trace(ftag,"Entry");
		
	
	if (attributeBroadcaster == null)
	    throw new ListenerNotFoundException(
                  "No attribute change notification listeners registered");
		
	
	MBeanAttributeInfo[] attrInfo = modelMBeanInfo.getAttributes();
	boolean found = false;	
	if ((attrInfo != null) && (attrInfo.length>0)) {
	    for (int i=0; i<attrInfo.length; i++) {
		if (attrInfo[i].getName().equals(inAttributeName)) {
		    found = true;
		    break;
		}				
	    }	
	}
		
	if ((!found) && (inAttributeName != null)) {
	    throw new RuntimeOperationsException(new
		IllegalArgumentException("Invalid attribute name"),
		"Exception occured trying to remove "+
		"attribute change notification listener");
	}

	/* note: */
        /* this may be a problem if the same listener is registered for
	   multiple attributes with multiple filters and/or handback
	   objects.  It may remove all of them */
		
	attributeBroadcaster.removeNotificationListener(inlistener);
		
		
	if (tracing()) trace(ftag,"Exit");
	
!!!8308635.java!!!	sendAttributeChangeNotification(inout ntfyObj : AttributeChangeNotification) : void
	final String ftag =
	    "sendAttributeChangeNotification(AttributeChangeNotification)";

	if (tracing()) trace(ftag,"Entry");
	
	if (ntfyObj == null)
	    throw new RuntimeOperationsException(new
		IllegalArgumentException(
                "attribute change notification object must not be null"),
		"Exception occured trying to send "+
                "attribute change notification of a ModelMBean");
	
	Object oldv = ntfyObj.getOldValue();
	Object newv =  ntfyObj.getNewValue();

	if (oldv == null) oldv = "null";
	if (newv == null) newv = "null";
		
	if (tracing())
	    trace(ftag,"Sending AttributeChangeNotification " +
		  " with " + ntfyObj.getAttributeName() +
		  ntfyObj.getAttributeType() +
		  ntfyObj.getNewValue() +
		  ntfyObj.getOldValue());
	
	// log notification if specified in descriptor
	Descriptor ntfyDesc =
	    modelMBeanInfo.getDescriptor(ntfyObj.getType(),"notification");
	Descriptor mmbDesc = modelMBeanInfo.getMBeanDescriptor();
	
	String logging, logfile;
	
	if (ntfyDesc != null) {
	    logging =(String)  ntfyDesc.getFieldValue("log");
	    if (logging == null) {
		if (mmbDesc != null)
		    logging = (String) mmbDesc.getFieldValue("log");
	    }
	    if ((logging != null) &&
		( logging.equalsIgnoreCase("t") ||
		  logging.equalsIgnoreCase("true"))) {
		logfile = (String) ntfyDesc.getFieldValue("logfile");
		if (logfile == null) {
		    if (mmbDesc != null)
			logfile = (String)mmbDesc.getFieldValue("logfile");
		}
	    	
		if (logfile != null) {			
		    try {
			writeToLog(logfile,"LogMsg: " +
			   ((new Date(ntfyObj.getTimeStamp())).toString())+
			   " " + ntfyObj.getType() + " " +
			   ntfyObj.getMessage() +
			   " Name = " + ntfyObj.getAttributeName() +
			   " Old value = " + oldv +
			   " New value = " + newv);			
		    } catch (Exception e) {
			error(ftag,"Failed to log " + ntfyObj.getType() +
			      " notification: " + e);
			traceX(ftag,e);
		    }
		}
	    }
	} else if (mmbDesc != null) {
	    logging = (String) mmbDesc.getFieldValue("log");
	    if ((logging != null) &&
		( logging.equalsIgnoreCase("t") ||
		  logging.equalsIgnoreCase("true") )) {
		logfile = (String) mmbDesc.getFieldValue("logfile");

		if (logfile != null) {
		    try {
			writeToLog(logfile,"LogMsg: " +
			   ((new Date(ntfyObj.getTimeStamp())).toString())+
			   " " + ntfyObj.getType() + " " +
			   ntfyObj.getMessage() +
			   " Name = " + ntfyObj.getAttributeName() +
			   " Old value = " + oldv +
			   " New value = " + newv);
		    } catch (Exception e) {
			error(ftag,"Failed to log " + ntfyObj.getType() +
			      " notification: " + e);
			traceX(ftag,e);
		    }
		}	
	    }
	}
	if (attributeBroadcaster != null) {
	    attributeBroadcaster.sendNotification(ntfyObj);
	}

	// XXX Revisit: This is a quickfix: it would be better to have a
	//     single broadcaster. However, it is not so simple because
	//     removeAttributeChangeNotificationListener() should
	//     remove only listeners whose filter is an instanceof
	//     AttributeChangeNotificationFilter.
	//
	if (generalBroadcaster != null) {
	    generalBroadcaster.sendNotification(ntfyObj);
	}
	if (tracing()) trace(ftag,"sent notification");
	
	if (tracing()) trace(ftag,"Exit");
!!!8308763.java!!!	sendAttributeChangeNotification(inout inOldVal : Attribute, inout inNewVal : Attribute) : void
	final String ftag =
	    "sendAttributeChangeNotification(Attribute, Attribute)";
	if (tracing()) trace(ftag,"Entry");

	// do we really want to do this?
	if ((inOldVal == null) || (inNewVal == null))
	    throw new RuntimeOperationsException(new
	       IllegalArgumentException("Attribute object must not be null"),
	       "Exception occured trying to send " +
	       "attribute change notification of a ModelMBean");
	

	if (!(inOldVal.getName().equals(inNewVal.getName())))
	    throw new RuntimeOperationsException(new
		IllegalArgumentException("Attribute names are not the same"),
		"Exception occured trying to send " +
		"attribute change notification of a ModelMBean");

	
	Object newVal = inNewVal.getValue();	
	Object oldVal = inOldVal.getValue();
	String className = "unknown";
	if (newVal != null)
	    className = newVal.getClass().getName();		
	if (oldVal != null)
	    className = oldVal.getClass().getName();
	
	AttributeChangeNotification myNtfyObj = new
	    AttributeChangeNotification(this,
					1,
					((new Date()).getTime()),
					"AttributeChangeDetected",
					inOldVal.getName(),
					className,
					inOldVal.getValue(),
					inNewVal.getValue());
	
	sendAttributeChangeNotification(myNtfyObj);

	if (tracing()) trace(ftag,"Exit");

!!!8308891.java!!!	getClassLoaderRepository() : ClassLoaderRepository
	return MBeanServerFactory.getClassLoaderRepository(server);
!!!8309019.java!!!	loadClass(in className : String) : Class
	try {
	    return Class.forName(className);
	} catch (ClassNotFoundException e) {
	    final ClassLoaderRepository clr =
		getClassLoaderRepository();
	    if (clr == null) throw new ClassNotFoundException(className);
	    return clr.loadClass(className);
	}
!!!8309147.java!!!	preRegister(inout server : MBeanServer, inout name : ObjectName) : ObjectName
        // Since ModelMbeanInfo cannot be null (otherwise exception
	// thrown at creation)
        // no exception thrown on ModelMBeanInfo not set.
        if (name == null) throw new NullPointerException(
		     "name of RequiredModelMBean to registered is null");
	this.server = server;
        return name;
!!!8309275.java!!!	postRegister(inout registrationDone : Boolean) : void
        registered = registrationDone.booleanValue();
!!!8309531.java!!!	postDeregister() : void
        registered = false;
	this.server=null;
!!!8309659.java!!!	tracing() : boolean
		
	return Trace.isSelected(Trace.LEVEL_TRACE, Trace.INFO_MODELMBEAN);
!!!8309787.java!!!	trace(in inClass : String, in inMethod : String, in inText : String) : void
	Trace.send(Trace.LEVEL_TRACE, Trace.INFO_MODELMBEAN, inClass,
		   inMethod, inText);
!!!8309915.java!!!	traceX(in inMethod : String, inout x : Throwable) : void
	Trace.send(Trace.LEVEL_TRACE, Trace.INFO_MODELMBEAN, currClass,
		   inMethod, x);
!!!8310043.java!!!	trace(in inMethod : String, in inText : String) : void
	trace(currClass, inMethod, inText);
!!!8310171.java!!!	error(in inMethod : String, in inText : String) : void
	Trace.send(Trace.LEVEL_ERROR, Trace.INFO_MODELMBEAN, currClass,
		   inMethod, inText);
!!!8310299.java!!!	debugging() : boolean
	return Trace.isSelected(Trace.LEVEL_DEBUG, Trace.INFO_MODELMBEAN);
!!!8310427.java!!!	debug(in inClass : String, in inMethod : String, in inText : String) : void
	Trace.send(Trace.LEVEL_DEBUG, Trace.INFO_MODELMBEAN, inClass,
		   inMethod, inText);
!!!8310555.java!!!	debug(in inMethod : String, in inText : String) : void
	debug(currClass, inMethod, inText);
!!!8310683.java!!!	debug(in inMethod : String, inout x : Throwable) : void
	Trace.send(Trace.LEVEL_DEBUG, Trace.INFO_MODELMBEAN, currClass,
		   inMethod, x);
