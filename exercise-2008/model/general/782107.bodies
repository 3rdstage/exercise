class XIncludeHandler
!!!5541659.java!!!	XIncludeHandler()
        fDepth = 0;
        
        fSawFallback[fDepth] = false;
        fSawInclude[fDepth] = false;
        fState[fDepth] = STATE_NORMAL_PROCESSING;
        fNotations = new Vector();
        fUnparsedEntities = new Vector();
        
        baseURIScope = new IntStack();
        baseURI = new Stack();
        literalSystemID = new Stack();
        expandedSystemID = new Stack();
        fCurrentBaseURI = new XMLResourceIdentifierImpl();
!!!5541787.java!!!	reset(inout componentManager : XMLComponentManager) : void
        fNamespaceContext = null;
        fDepth = 0;
        fNotations = new Vector();
        fUnparsedEntities = new Vector();
        fParentRelativeURI = null;
        fIsXML11 = false;
        fInDTD = false;
        
        baseURIScope.clear();
        baseURI.clear();
        literalSystemID.clear();
        expandedSystemID.clear();
        
        // REVISIT: Find a better method for maintaining
        // the state of the XInclude processor. These arrays
        // can potentially grow quite large. Cleaning them
        // out on reset may be very time consuming. -- mrglavas
        //
        // clear the previous settings from the arrays
        for (int i = 0; i < fState.length; ++i) {
            fState[i] = STATE_NORMAL_PROCESSING;
        }
        for (int i = 0; i < fSawFallback.length; ++i) {
            fSawFallback[i] = false;
        }
        for (int i = 0; i < fSawInclude.length; ++i) {
            fSawInclude[i] = false;
        }
        
        try {
            fSendUEAndNotationEvents =
            componentManager.getFeature(ALLOW_UE_AND_NOTATION_EVENTS);
            if (fChildConfig != null) {
                fChildConfig.setFeature(
                ALLOW_UE_AND_NOTATION_EVENTS,
                fSendUEAndNotationEvents);
            }
        }
        catch (XMLConfigurationException e) {
        }
        
        // Get error reporter.
        try {
            XMLErrorReporter value =
            (XMLErrorReporter)componentManager.getProperty(ERROR_REPORTER);
            if (value != null) {
                setErrorReporter(value);
                if (fChildConfig != null) {
                    fChildConfig.setProperty(ERROR_REPORTER, value);
                }
            }
            
        }
        catch (XMLConfigurationException e) {
            fErrorReporter = null;
        }
        
        // Get entity resolver.
        try {
            XMLEntityResolver value =
            (XMLEntityResolver)componentManager.getProperty(
            ENTITY_RESOLVER);
            
            if (value != null) {
                fEntityResolver = value;
                if (fChildConfig != null) {
                    fChildConfig.setProperty(ENTITY_RESOLVER, value);
                }
            }
        }
        catch (XMLConfigurationException e) {
            fEntityResolver = null;
        }
        
        try {
            fXPointerSchema =
            (XPointerSchema [])componentManager.getProperty(
            XPOINTER_SCHEMA);
        }
        catch (XMLConfigurationException e) {
            fXPointerSchema = null;
        }
        
        // Get security manager.
        try {
            SecurityManager value =
            (SecurityManager)componentManager.getProperty(
            SECURITY_MANAGER);
            
            if (value != null) {
                fSecurityManager = value;
                if (fChildConfig != null) {
                    fChildConfig.setProperty(SECURITY_MANAGER, value);
                }
            }
        }
        catch (XMLConfigurationException e) {
            fSecurityManager = null;
        }
        
        fSettings = new ParserConfigurationSettings();
        copyFeatures(componentManager, fSettings);
        // Don't reset fChildConfig -- we don't want it to share the same components.
        // It will be reset when it is actually used to parse something.
!!!5541915.java!!!	getRecognizedFeatures() : String
        return RECOGNIZED_FEATURES;
!!!5542043.java!!!	setFeature(in featureId : String, inout state : boolean) : void
        if (featureId.equals(ALLOW_UE_AND_NOTATION_EVENTS)) {
            fSendUEAndNotationEvents = state;
        }
        if (fSettings != null) {
            fSettings.setFeature(featureId, state);
        }
!!!5542171.java!!!	getRecognizedProperties() : String
        return RECOGNIZED_PROPERTIES;
!!!5542299.java!!!	setProperty(in propertyId : String, inout value : Object) : void
        if (propertyId.equals(ERROR_REPORTER)) {
            setErrorReporter((XMLErrorReporter)value);
            if (fChildConfig != null) {
                fChildConfig.setProperty(propertyId, value);
            }
        }
        if (propertyId.equals(ENTITY_RESOLVER)) {
            fEntityResolver = (XMLEntityResolver)value;
            if (fChildConfig != null) {
                fChildConfig.setProperty(propertyId, value);
            }
        }
        if (propertyId.equals(SECURITY_MANAGER)) {
            fSecurityManager = (SecurityManager)value;
            if (fChildConfig != null) {
                fChildConfig.setProperty(propertyId, value);
            }
        }
        
!!!5542427.java!!!	getFeatureDefault(in featureId : String) : Boolean
        for (int i = 0; i < RECOGNIZED_FEATURES.length; i++) {
            if (RECOGNIZED_FEATURES[i].equals(featureId)) {
                return FEATURE_DEFAULTS[i];
            }
        }
        return null;
!!!5542555.java!!!	getPropertyDefault(in propertyId : String) : Object
        for (int i = 0; i < RECOGNIZED_PROPERTIES.length; i++) {
            if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {
                return PROPERTY_DEFAULTS[i];
            }
        }
        return null;
!!!5542683.java!!!	setDocumentHandler(inout handler : XMLDocumentHandler) : void
        fDocumentHandler = handler;
!!!5542811.java!!!	getDocumentHandler() : XMLDocumentHandler
        return fDocumentHandler;
!!!5542939.java!!!	startDocument(inout locator : XMLLocator, in encoding : String, inout namespaceContext : NamespaceContext, inout augs : Augmentations) : void
        
        // we do this to ensure that the proper location is reported in errors
        // otherwise, the locator from the root document would always be used
        if(fErrorReporter != null)
            fErrorReporter.setDocumentLocator(locator);
        if (!isRootDocument()
        && fParentXIncludeHandler.searchForRecursiveIncludes(locator)) {
            reportFatalError(
            "RecursiveInclude",
            new Object[] { locator.getExpandedSystemId()});
        }
        
        if (!(namespaceContext instanceof XIncludeNamespaceSupport)) {
            reportFatalError("IncompatibleNamespaceContext");
        }
        fNamespaceContext = (XIncludeNamespaceSupport)namespaceContext;
        fDocLocation = locator;
        
        // initialize the current base URI
        fCurrentBaseURI.setBaseSystemId(locator.getBaseSystemId());
        fCurrentBaseURI.setExpandedSystemId(locator.getExpandedSystemId());
        fCurrentBaseURI.setLiteralSystemId(locator.getLiteralSystemId());
        saveBaseURI();
        if (augs == null) {
            augs = new AugmentationsImpl();
        }
        augs.putItem(CURRENT_BASE_URI, fCurrentBaseURI);
        
        if (isRootDocument() && fDocumentHandler != null) {
            fDocumentHandler.startDocument(
            locator,
            encoding,
            namespaceContext,
            augs);
        }
!!!5543067.java!!!	xmlDecl(in version : String, in encoding : String, in standalone : String, inout augs : Augmentations) : void
        fIsXML11 = "1.1".equals(version);
        if (isRootDocument() && fDocumentHandler != null) {
            fDocumentHandler.xmlDecl(version, encoding, standalone, augs);
        }
!!!5543195.java!!!	doctypeDecl(in rootElement : String, in publicId : String, in systemId : String, inout augs : Augmentations) : void
        if (isRootDocument() && fDocumentHandler != null) {
            fDocumentHandler.doctypeDecl(rootElement, publicId, systemId, augs);
        }
!!!5543323.java!!!	comment(inout text : XMLString, inout augs : Augmentations) : void
        if (!fInDTD) {
            if (fDocumentHandler != null
            && getState() == STATE_NORMAL_PROCESSING) {
                fDepth++;
                augs = modifyAugmentations(augs);
                fDocumentHandler.comment(text, augs);
                fDepth--;
            }
        }
        else if (fDTDHandler != null) {
            fDTDHandler.comment(text, augs);
        }
!!!5543451.java!!!	processingInstruction(in target : String, inout data : XMLString, inout augs : Augmentations) : void
        if (!fInDTD) {
            if (fDocumentHandler != null
            && getState() == STATE_NORMAL_PROCESSING) {
                // we need to change the depth like this so that modifyAugmentations() works
                fDepth++;
                augs = modifyAugmentations(augs);
                fDocumentHandler.processingInstruction(target, data, augs);
                fDepth--;
            }
        }
        else if (fDTDHandler != null) {
            fDTDHandler.processingInstruction(target, data, augs);
        }
!!!5543579.java!!!	startElement(inout element : QName, inout attributes : XMLAttributes, inout augs : Augmentations) : void
        fDepth++;
        setState(getState(fDepth - 1));
        // we process the xml:base attributes regardless of what type of element it is
        processXMLBaseAttributes(attributes);
        
        if (isIncludeElement(element)) {
            boolean success = this.handleIncludeElement(attributes);
            if (success) {
                setState(STATE_IGNORE);
            }
            else {
                setState(STATE_EXPECT_FALLBACK);
            }
        }
        else if (isFallbackElement(element)) {
            this.handleFallbackElement();
        }
        else if (
        fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            augs = modifyAugmentations(augs);
            attributes = processAttributes(attributes);
            fDocumentHandler.startElement(element, attributes, augs);
        }
!!!5543707.java!!!	emptyElement(inout element : QName, inout attributes : XMLAttributes, inout augs : Augmentations) : void
        fDepth++;
        setState(getState(fDepth - 1));
        
        // we process the xml:base attributes regardless of what type of element it is
        processXMLBaseAttributes(attributes);
        
        if (isIncludeElement(element)) {
            boolean success = this.handleIncludeElement(attributes);
            if (success) {
                setState(STATE_IGNORE);
            }
            else {
                reportFatalError("NoFallback");
            }
        }
        else if (isFallbackElement(element)) {
            this.handleFallbackElement();
        }
        else if (hasXIncludeNamespace(element)) {
            if (getSawInclude(fDepth - 1)) {
                reportFatalError(
                "IncludeChild",
                new Object[] { element.rawname });
            }
        }
        else if (
        fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            augs = modifyAugmentations(augs);
            attributes = processAttributes(attributes);
            fDocumentHandler.emptyElement(element, attributes, augs);
        }
        // reset the out of scope stack elements
        setSawFallback(fDepth + 1, false);
        setSawInclude(fDepth + 1, false);
        
        // check if an xml:base has gone out of scope
        if (baseURIScope.size() > 0 && fDepth == baseURIScope.peek()) {
            // pop the values from the stack
            restoreBaseURI();
        }
        fDepth--;
!!!5543835.java!!!	endElement(inout element : QName, inout augs : Augmentations) : void
        
        if (isIncludeElement(element)) {
            // if we're ending an include element, and we were expecting a fallback
            // we check to see if the children of this include element contained a fallback
            if (getState() == STATE_EXPECT_FALLBACK
            && !getSawFallback(fDepth + 1)) {
                reportFatalError("NoFallback");
            }
        }
        if (isFallbackElement(element)) {
            // the state would have been set to normal processing if we were expecting the fallback element
            // now that we're done processing it, we should ignore all the other children of the include element
            if (getState() == STATE_NORMAL_PROCESSING) {
                setState(STATE_IGNORE);
            }
        }
        else if (
        fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            fDocumentHandler.endElement(element, augs);
        }
        
        // reset the out of scope stack elements
        setSawFallback(fDepth + 1, false);
        setSawInclude(fDepth + 1, false);
        
        // check if an xml:base has gone out of scope
        if (baseURIScope.size() > 0 && fDepth == baseURIScope.peek()) {
            // pop the values from the stack
            restoreBaseURI();
        }
        fDepth--;
!!!5543963.java!!!	startGeneralEntity(in name : String, inout resId : XMLResourceIdentifier, in encoding : String, inout augs : Augmentations) : void
        if (fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            fDocumentHandler.startGeneralEntity(name, resId, encoding, augs);
        }
!!!5544091.java!!!	textDecl(in version : String, in encoding : String, inout augs : Augmentations) : void
        if (fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            fDocumentHandler.textDecl(version, encoding, augs);
        }
!!!5544219.java!!!	endGeneralEntity(in name : String, inout augs : Augmentations) : void
        if (fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            fDocumentHandler.endGeneralEntity(name, augs);
        }
!!!5544347.java!!!	characters(inout text : XMLString, inout augs : Augmentations) : void
        if (fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            // we need to change the depth like this so that modifyAugmentations() works
            fDepth++;
            augs = modifyAugmentations(augs);
            fDocumentHandler.characters(text, augs);
            fDepth--;
        }
!!!5544475.java!!!	ignorableWhitespace(inout text : XMLString, inout augs : Augmentations) : void
        if (fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            fDocumentHandler.ignorableWhitespace(text, augs);
        }
!!!5544603.java!!!	startCDATA(inout augs : Augmentations) : void
        if (fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            fDocumentHandler.startCDATA(augs);
        }
!!!5544731.java!!!	endCDATA(inout augs : Augmentations) : void
        if (fDocumentHandler != null
        && getState() == STATE_NORMAL_PROCESSING) {
            fDocumentHandler.endCDATA(augs);
        }
!!!5544859.java!!!	endDocument(inout augs : Augmentations) : void
        if (isRootDocument() && fDocumentHandler != null) {
            fDocumentHandler.endDocument(augs);
        }
!!!5544987.java!!!	setDocumentSource(inout source : XMLDocumentSource) : void
        fDocumentSource = source;
!!!5545115.java!!!	getDocumentSource() : XMLDocumentSource
        return fDocumentSource;
!!!5545243.java!!!	attributeDecl(in elementName : String, in attributeName : String, in type : String, in enumeration : String, in defaultType : String, inout defaultValue : XMLString, inout nonNormalizedDefaultValue : XMLString, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.attributeDecl(
            elementName,
            attributeName,
            type,
            enumeration,
            defaultType,
            defaultValue,
            nonNormalizedDefaultValue,
            augmentations);
        }
!!!5545371.java!!!	elementDecl(in name : String, in contentModel : String, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.elementDecl(name, contentModel, augmentations);
        }
!!!5545499.java!!!	endAttlist(inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.endAttlist(augmentations);
        }
!!!5545627.java!!!	endConditional(inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.endConditional(augmentations);
        }
!!!5545755.java!!!	endDTD(inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.endDTD(augmentations);
        }
        fInDTD = false;
!!!5545883.java!!!	endExternalSubset(inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.endExternalSubset(augmentations);
        }
!!!5546011.java!!!	endParameterEntity(in name : String, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.endParameterEntity(name, augmentations);
        }
!!!5546139.java!!!	externalEntityDecl(in name : String, inout identifier : XMLResourceIdentifier, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.externalEntityDecl(name, identifier, augmentations);
        }
!!!5546267.java!!!	getDTDSource() : XMLDTDSource
        return fDTDSource;
!!!5546395.java!!!	ignoredCharacters(inout text : XMLString, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.ignoredCharacters(text, augmentations);
        }
!!!5546523.java!!!	internalEntityDecl(in name : String, inout text : XMLString, inout nonNormalizedText : XMLString, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.internalEntityDecl(
            name,
            text,
            nonNormalizedText,
            augmentations);
        }
!!!5546651.java!!!	notationDecl(in name : String, inout identifier : XMLResourceIdentifier, inout augmentations : Augmentations) : void
        this.addNotation(name, identifier, augmentations);
        if (fDTDHandler != null) {
            fDTDHandler.notationDecl(name, identifier, augmentations);
        }
!!!5546779.java!!!	setDTDSource(inout source : XMLDTDSource) : void
        fDTDSource = source;
!!!5546907.java!!!	startAttlist(in elementName : String, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.startAttlist(elementName, augmentations);
        }
!!!5547035.java!!!	startConditional(in type : short, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.startConditional(type, augmentations);
        }
!!!5547163.java!!!	startDTD(inout locator : XMLLocator, inout augmentations : Augmentations) : void
        fInDTD = true;
        if (fDTDHandler != null) {
            fDTDHandler.startDTD(locator, augmentations);
        }
!!!5547291.java!!!	startExternalSubset(inout identifier : XMLResourceIdentifier, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.startExternalSubset(identifier, augmentations);
        }
!!!5547419.java!!!	startParameterEntity(in name : String, inout identifier : XMLResourceIdentifier, in encoding : String, inout augmentations : Augmentations) : void
        if (fDTDHandler != null) {
            fDTDHandler.startParameterEntity(
            name,
            identifier,
            encoding,
            augmentations);
        }
!!!5547547.java!!!	unparsedEntityDecl(in name : String, inout identifier : XMLResourceIdentifier, in notation : String, inout augmentations : Augmentations) : void
        this.addUnparsedEntity(name, identifier, notation, augmentations);
        if (fDTDHandler != null) {
            fDTDHandler.unparsedEntityDecl(
            name,
            identifier,
            notation,
            augmentations);
        }
!!!5547675.java!!!	getDTDHandler() : XMLDTDHandler
        return fDTDHandler;
!!!5547803.java!!!	setDTDHandler(inout handler : XMLDTDHandler) : void
        fDTDHandler = handler;
!!!5547931.java!!!	setErrorReporter(inout reporter : XMLErrorReporter) : void
        fErrorReporter = reporter;
        if (fErrorReporter != null) {
            fErrorReporter.putMessageFormatter(
            XIncludeMessageFormatter.XINCLUDE_DOMAIN,
            new XIncludeMessageFormatter());
            // this ensures the proper location is displayed in error messages
            if (fDocLocation != null) {
                fErrorReporter.setDocumentLocator(fDocLocation);
            }
        }
!!!5548059.java!!!	handleFallbackElement() : void
        setSawInclude(fDepth, false);
        fNamespaceContext.setContextInvalid();
        if (!getSawInclude(fDepth - 1)) {
            reportFatalError("FallbackParent");
        }
        
        if (getSawFallback(fDepth)) {
            reportFatalError("MultipleFallbacks");
        }
        else {
            setSawFallback(fDepth, true);
        }
        
        // Either the state is STATE_EXPECT_FALLBACK or it's STATE_IGNORE.
        // If we're ignoring, we want to stay ignoring. But if we're expecting this fallback element,
        // we want to signal that we should process the children.
        if (getState() == STATE_EXPECT_FALLBACK) {
            setState(STATE_NORMAL_PROCESSING);
        }
!!!5548187.java!!!	handleIncludeElement(inout attributes : XMLAttributes) : boolean
        setSawInclude(fDepth, true);
        fNamespaceContext.setContextInvalid();
        if (getSawInclude(fDepth - 1)) {
            reportFatalError("IncludeChild", new Object[] { XINCLUDE_INCLUDE });
        }
        if (getState() == STATE_IGNORE)
            return true;
        
        // TODO: does Java use IURIs by default?
        //       [Definition: An internationalized URI reference, or IURI, is a URI reference that directly uses [Unicode] characters.]
        // TODO: figure out what section 4.1.1 of the XInclude spec is talking about
        //       has to do with disallowed ASCII character escaping
        //       this ties in with the above IURI section, but I suspect Java already does it
        
        String href = attributes.getValue(XINCLUDE_ATTR_HREF);
        String parse = attributes.getValue(XINCLUDE_ATTR_PARSE);
        String xpointerPart =  attributes.getValue(XPOINTER);
        String accept = attributes.getValue(XINCLUDE_ATTR_ACCEPT);
        String acceptLanguage = attributes.getValue(XINCLUDE_ATTR_ACCEPT_LANGUAGE);
        
        if (href == null && xpointerPart == null) {
            reportFatalError("XpointerMissing");
        }
        if (parse == null) {
            parse = XINCLUDE_PARSE_XML;
        }
        
        boolean xpointer = false;
        String parserName = null;
        
        //Ignore fragment identifiers, implementation specific as per spec.
        
        if( href.indexOf("#")!=-1 )
            href =  href.substring(0,href.indexOf("#"));
        
        if ( xpointerPart != null && parse.equals(XINCLUDE_PARSE_XML))
            xpointer = true;
        
        // Verify that if an accept and/or an accept-language attribute exist
        // that the value(s) don't contain disallowed characters.
        if (accept != null && !isValidInHTTPHeader(accept)) {
            reportFatalError("AcceptMalformed", null);
        }
        if (acceptLanguage != null && !isValidInHTTPHeader(acceptLanguage)) {
            reportFatalError("AcceptLanguageMalformed", null);
        }
        
        XMLInputSource includedSource = null;
        if (fEntityResolver != null) {
            try {
                XMLResourceIdentifier resourceIdentifier =
                new XMLResourceIdentifierImpl(
                null,
                href,
                fCurrentBaseURI.getExpandedSystemId(),
                XMLEntityManager.expandSystemId(
                href,
                fCurrentBaseURI.getExpandedSystemId(),
                false));
                
                includedSource =
                fEntityResolver.resolveEntity(resourceIdentifier);
            } catch (IOException e) {
                reportResourceError(
                "XMLResourceError",
                new Object[] { href, e.getMessage()});
                return false;
            }
        }
        
        if (includedSource == null) {
            includedSource =
            new XIncludeInputSource(
            null,
            href,
            fCurrentBaseURI.getExpandedSystemId());
        }
        
        if(parse.equals(XINCLUDE_PARSE_XML) && xpointer ){
            if(fXPointerFramework == null){
                fXPointerFramework = new XPointerFramework();
                fXPointerFramework.setXPointerSchema(fXPointerSchema);
            }else{
                fXPointerFramework.reset();
                fXPointerFramework.setXPointerSchema(fXPointerSchema);
            }
            parserName = XPOINTER_DEFAULT_CONFIGURATION;
            fChildConfig = createXPointerParser();
            fXPointerFramework.setSchemaPointer(xpointerPart);
            // we don't want a schema validator on the new pipeline,
            // so we set it to false, regardless of what was copied above
           /* fChildConfig.setFeature(
            Constants.XERCES_FEATURE_PREFIX
            + Constants.SCHEMA_VALIDATION_FEATURE,
            false);*/
           	//-Revisit and clean up this piece of unclean code. 
            XPointerSchema fXPointerSchemaS;
            
            if((fXPointerSchemaS = fXPointerFramework.getNextXPointerSchema()) == null && fXPointerFramework.getSchemaCount() == 0){
                fNamespaceContext.pushScope();
                fXPointerSchemaS = fXPointerFramework.getDefaultSchema();
                fXPointerSchemaS.setXPointerSchemaPointer(xpointerPart);
                processSchema(fXPointerSchemaS,includedSource);
                /*
                 Object sch = null;
                if(!fXPointerFramework.fSchemaNotAvailable.empty())
                    sch = fXPointerFramework.fSchemaNotAvailable.pop();
                reportFatalError("NO_XPointerSchema",  new Object[] {sch});
                 */
            }else {
                try {
                    fNamespaceContext.pushScope();
                    if(fXPointerSchemaS != null && processSchema(fXPointerSchemaS,includedSource)){
                        ;
                    }else{
                        for (int i=fXPointerFramework.getCurrentPointer(); i <=fXPointerFramework.getSchemaCount();i++){
                            fXPointerSchemaS = fXPointerFramework.getNextXPointerSchema();
                            if(fXPointerSchemaS != null && processSchema(fXPointerSchemaS,includedSource)){
                                break;
                            }
                        }
                    }
                }
                catch (XNIException e) {
                    reportFatalError("XMLParseError");
                }
                finally {
                    fNamespaceContext.popScope();
                }
            }
            
        }
        else if (parse.equals(XINCLUDE_PARSE_XML)) {
            // Instead of always creating a new configuration, the first one can be reused
            //if (fChildConfig == null) {
            parserName = XINCLUDE_DEFAULT_CONFIGURATION;
            
            fChildConfig =
            (XMLParserConfiguration)ObjectFactory.newInstance(
            parserName,
            ObjectFactory.findClassLoader(),
            true);
            // use the same error reporter, entity resolver, and security manager.
            if (fErrorReporter != null) fChildConfig.setProperty(ERROR_REPORTER, fErrorReporter);
            if (fEntityResolver != null) fChildConfig.setProperty(ENTITY_RESOLVER, fEntityResolver);
            if (fSecurityManager != null) fChildConfig.setProperty(SECURITY_MANAGER, fSecurityManager);
            
            // use the same namespace context
            fChildConfig.setProperty(
            Constants.XERCES_PROPERTY_PREFIX
            + Constants.NAMESPACE_CONTEXT_PROPERTY,
            fNamespaceContext);
            
            XIncludeHandler newHandler =
            (XIncludeHandler)fChildConfig.getProperty(
            Constants.XERCES_PROPERTY_PREFIX
            + Constants.XINCLUDE_HANDLER_PROPERTY);
            newHandler.setParent(this);
            newHandler.setDocumentHandler(this.getDocumentHandler());
            //}
            
            // set all features on parserConfig to match this parser configuration
            copyFeatures(fSettings, fChildConfig);
            // we don't want a schema validator on the new pipeline,
            // so we set it to false, regardless of what was copied above
            fChildConfig.setFeature(
            Constants.XERCES_FEATURE_PREFIX
            + Constants.SCHEMA_VALIDATION_FEATURE,
            false);
            fChildConfig.setFeature(
            Constants.XERCES_FEATURE_PREFIX
            + Constants.XINCLUDE_AWARE,
            true);
            
            try {
                fNamespaceContext.pushScope();
                includedSource = setHttpProperties(includedSource,attributes);
                fChildConfig.parse(includedSource);
                // necessary to make sure proper location is reported in errors
                if (fErrorReporter != null) {
                    fErrorReporter.setDocumentLocator(fDocLocation);
                }
            }
            catch (XNIException e) {
                // necessary to make sure proper location is reported in errors
                if (fErrorReporter != null) {
                    fErrorReporter.setDocumentLocator(fDocLocation);
                }
                reportFatalError("XMLParseError", new Object[] { href });
            }
            catch (IOException e) {
                // necessary to make sure proper location is reported in errors
                if (fErrorReporter != null) {
                    fErrorReporter.setDocumentLocator(fDocLocation);
                }
                // An IOException indicates that we had trouble reading the file, not
                // that it was an invalid XML file.  So we send a resource error, not a
                // fatal error.
                reportResourceError(
                "XMLResourceError",
                new Object[] { href, e.getMessage()});
                return false;
            }
            finally {
                fNamespaceContext.popScope();
            }
        }
        else if (parse.equals(XINCLUDE_PARSE_TEXT)) {
            // we only care about encoding for parse="text"
            String encoding = attributes.getValue(XINCLUDE_ATTR_ENCODING);
            includedSource.setEncoding(encoding);
            
            XIncludeTextReader reader = null;
            try {
                if (fIsXML11) {
                    reader = new XInclude11TextReader(includedSource, this);
                }
                else {
                    reader = new XIncludeTextReader(includedSource, this);
                }
                if (includedSource.getCharacterStream() == null
                && includedSource.getByteStream() == null) {
                    reader.setHttpProperties(accept, acceptLanguage);
                }
                reader.setErrorReporter(fErrorReporter);
                reader.parse();
            }
            // encoding errors
            catch (MalformedByteSequenceException ex) {
                fErrorReporter.reportError(ex.getDomain(), ex.getKey(),
                ex.getArguments(), XMLErrorReporter.SEVERITY_FATAL_ERROR);
            }
            catch (CharConversionException e) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                "CharConversionFailure", null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
            }
            catch (IOException e) {
                reportResourceError(
                "TextResourceError",
                new Object[] { href, e.getMessage()});
                return false;
            }
            finally {
                if (reader != null) {
                    try {
                        reader.close();
                    }
                    catch (IOException e) {
                        reportResourceError(
                        "TextResourceError",
                        new Object[] { href, e.getMessage()});
                        return false;
                    }
                }
            }
        }
        else {
            reportFatalError("InvalidParseValue", new Object[] { parse });
        }
        return true;
!!!5548315.java!!!	hasXIncludeNamespace(inout element : QName) : boolean
        // REVISIT: The namespace of this element should be bound
        // already. Why are we looking it up from the namespace
        // context? -- mrglavas
        return element.uri == XINCLUDE_NS_URI
        || fNamespaceContext.getURI(element.prefix) == XINCLUDE_NS_URI;
!!!5548443.java!!!	isIncludeElement(inout element : QName) : boolean
        return element.localpart.equals(XINCLUDE_INCLUDE) &&
        hasXIncludeNamespace(element);
!!!5548571.java!!!	isFallbackElement(inout element : QName) : boolean
        return element.localpart.equals(XINCLUDE_FALLBACK) &&
        hasXIncludeNamespace(element);
!!!5548699.java!!!	sameBaseURIAsIncludeParent() : boolean
        String parentBaseURI = getIncludeParentBaseURI();
        String baseURI = fCurrentBaseURI.getExpandedSystemId();
        // REVISIT: should we use File#sameFile() ?
        //          I think the benefit of using it is that it resolves host names
        //          instead of just doing a string comparison.
        // TODO: [base URI] is still an open issue with the working group.
        //       They're deciding if xml:base should be added if the [base URI] is different in terms
        //       of resolving relative references, or if it should be added if they are different at all.
        //       Revisit this after a final decision has been made.
        //       The decision also affects whether we output the file name of the URI, or just the path.
        return parentBaseURI != null && parentBaseURI.equals(baseURI);
!!!5548827.java!!!	searchForRecursiveIncludes(inout includedSource : XMLLocator) : boolean
        String includedSystemId = includedSource.getExpandedSystemId();
        
        if (includedSystemId == null) {
            try {
                includedSystemId =
                XMLEntityManager.expandSystemId(
                includedSource.getLiteralSystemId(),
                includedSource.getBaseSystemId(),
                false);
            }
            catch (MalformedURIException e) {
                reportFatalError("ExpandedSystemId");
            }
        }
        
        if (includedSystemId.equals(fCurrentBaseURI.getExpandedSystemId())) {
            return true;
        }
        
        if (fParentXIncludeHandler == null) {
            return false;
        }
        return fParentXIncludeHandler.searchForRecursiveIncludes(
        includedSource);
!!!5548955.java!!!	isTopLevelIncludedItem() : boolean
        return isTopLevelIncludedItemViaInclude()
        || isTopLevelIncludedItemViaFallback();
!!!5549083.java!!!	isTopLevelIncludedItemViaInclude() : boolean
        return fDepth == 1 && !isRootDocument();
!!!5549211.java!!!	isTopLevelIncludedItemViaFallback() : boolean
        // Technically, this doesn't check if the parent was a fallback, it also
        // would return true if any of the parent's sibling elements were fallbacks.
        // However, this doesn't matter, since we will always be ignoring elements
        // whose parent's siblings were fallbacks.
        return getSawFallback(fDepth - 1);
!!!5549339.java!!!	processAttributes(inout attributes : XMLAttributes) : XMLAttributes
        if (isTopLevelIncludedItem()) {
            // Modify attributes to fix the base URI (spec 4.5.5).
            // We only do it to top level included elements, which have a different
            // base URI than their include parent.
            if (!sameBaseURIAsIncludeParent()) {
                if (attributes == null) {
                    attributes = new XMLAttributesImpl();
                }
                
                // This causes errors with schema validation, if the schema doesn't
                // specify that these elements can have an xml:base attribute
                // TODO: add a user option to turn this off?
                String uri = null;
                try {
                    uri = this.getRelativeBaseURI();
                }
                catch (MalformedURIException e) {
                    // this shouldn't ever happen, since by definition, we had to traverse
                    // the same URIs to even get to this place
                    uri = fCurrentBaseURI.getExpandedSystemId();
                }
                int index =
                attributes.addAttribute(
                XML_BASE_QNAME,
                XMLSymbols.fCDATASymbol,
                uri);
                attributes.setSpecified(index, true);
            }
            
            // Modify attributes of included items to do namespace-fixup. (spec 4.5.4)
            Enumeration inscopeNS = fNamespaceContext.getAllPrefixes();
            while (inscopeNS.hasMoreElements()) {
                String prefix = (String)inscopeNS.nextElement();
                String parentURI =
                fNamespaceContext.getURIFromIncludeParent(prefix);
                String uri = fNamespaceContext.getURI(prefix);
                if (parentURI != uri && attributes != null) {
                    if (prefix == XMLSymbols.EMPTY_STRING) {
                        if (attributes
                        .getValue(
                        NamespaceContext.XMLNS_URI,
                        XMLSymbols.PREFIX_XMLNS)
                        == null) {
                            if (attributes == null) {
                                attributes = new XMLAttributesImpl();
                            }
                            
                            QName ns = (QName)NEW_NS_ATTR_QNAME.clone();
                            ns.localpart = XMLSymbols.PREFIX_XMLNS;
                            ns.rawname = XMLSymbols.PREFIX_XMLNS;
                            attributes.addAttribute(
                            ns,
                            XMLSymbols.fCDATASymbol,
                            uri);
                        }
                    }
                    else if (
                    attributes.getValue(NamespaceContext.XMLNS_URI, prefix)
                    == null) {
                        if (attributes == null) {
                            attributes = new XMLAttributesImpl();
                        }
                        
                        QName ns = (QName)NEW_NS_ATTR_QNAME.clone();
                        ns.localpart = prefix;
                        ns.rawname += prefix;
                        attributes.addAttribute(
                        ns,
                        XMLSymbols.fCDATASymbol,
                        uri);
                    }
                }
            }
        }
        
        if (attributes != null) {
            int length = attributes.getLength();
            for (int i = 0; i < length; i++) {
                String type = attributes.getType(i);
                String value = attributes.getValue(i);
                if (type == XMLSymbols.fENTITYSymbol) {
                    this.checkUnparsedEntity(value);
                }
                if (type == XMLSymbols.fENTITIESSymbol) {
                    // 4.5.1 - Unparsed Entities
                    StringTokenizer st = new StringTokenizer(value);
                    while (st.hasMoreTokens()) {
                        String entName = st.nextToken();
                        this.checkUnparsedEntity(entName);
                    }
                }
                else if (type == XMLSymbols.fNOTATIONSymbol) {
                    // 4.5.2 - Notations
                    this.checkNotation(value);
                }
                /* We actually don't need to do anything for 4.5.3, because at this stage the
                 * value of the attribute is just a string. It will be taken care of later
                 * in the pipeline, when the IDREFs are actually resolved against IDs.
                 *
                 * if (type == XMLSymbols.fIDREFSymbol || type == XMLSymbols.fIDREFSSymbol) { }
                 */
            }
        }
        
        return attributes;
!!!5549467.java!!!	getRelativeBaseURI() : String
        int includeParentDepth = getIncludeParentDepth();
        String relativeURI = this.getRelativeURI(includeParentDepth);
        if (isRootDocument()) {
            return relativeURI;
        }
        else {
            if (relativeURI.equals("")) {
                relativeURI = fCurrentBaseURI.getLiteralSystemId();
            }
            
            if (includeParentDepth == 0) {
                if (fParentRelativeURI == null) {
                    fParentRelativeURI =
                    fParentXIncludeHandler.getRelativeBaseURI();
                }
                if (fParentRelativeURI.equals("")) {
                    return relativeURI;
                }
                URI uri = new URI("file", fParentRelativeURI);
                uri = new URI(uri, relativeURI);
                return uri.getPath();
            }
            else {
                return relativeURI;
            }
        }
!!!5549595.java!!!	getIncludeParentBaseURI() : String
        int depth = getIncludeParentDepth();
        if (!isRootDocument() && depth == 0) {
            return fParentXIncludeHandler.getIncludeParentBaseURI();
        }
        else {
            return this.getBaseURI(depth);
        }
!!!5549723.java!!!	getIncludeParentDepth() : int
        // We don't start at fDepth, since it is either the top level included item,
        // or an include element, when this method is called.
        for (int i = fDepth - 1; i >= 0; i--) {
            // This technically might not always return the first non-include/fallback
            // element that it comes to, since sawFallback() returns true if a fallback
            // was ever encountered at that depth.  However, if a fallback was encountered
            // at that depth, and it wasn't the direct descendant of the current element
            // then we can't be in a situation where we're calling this method (because
            // we'll always be in STATE_IGNORE)
            if (!getSawInclude(i) && !getSawFallback(i)) {
                return i;
            }
        }
        // shouldn't get here, since depth 0 should never have an include element or
        // a fallback element
        return 0;
!!!5549851.java!!!	modifyAugmentations(inout augs : Augmentations) : Augmentations
        return modifyAugmentations(augs, false);
!!!5549979.java!!!	modifyAugmentations(inout augs : Augmentations, inout force : boolean) : Augmentations
        if (force || isTopLevelIncludedItem()) {
            if (augs == null) {
                augs = new AugmentationsImpl();
            }
            augs.putItem(XINCLUDE_INCLUDED, Boolean.TRUE);
        }
        return augs;
!!!5550107.java!!!	getState(in depth : int) : int
        return fState[depth];
!!!5550235.java!!!	getState() : int
        return fState[fDepth];
!!!5550363.java!!!	setState(in state : int) : void
        if (fDepth >= fState.length) {
            int[] newarray = new int[fDepth * 2];
            System.arraycopy(fState, 0, newarray, 0, fState.length);
            fState = newarray;
        }
        fState[fDepth] = state;
!!!5550491.java!!!	setSawFallback(in depth : int, inout val : boolean) : void
        if (depth >= fSawFallback.length) {
            boolean[] newarray = new boolean[depth * 2];
            System.arraycopy(fSawFallback, 0, newarray, 0, fSawFallback.length);
            fSawFallback = newarray;
        }
        fSawFallback[depth] = val;
!!!5550619.java!!!	getSawFallback(in depth : int) : boolean
        if (depth >= fSawFallback.length) {
            return false;
        }
        return fSawFallback[depth];
!!!5550747.java!!!	setSawInclude(in depth : int, inout val : boolean) : void
        if (depth >= fSawInclude.length) {
            boolean[] newarray = new boolean[depth * 2];
            System.arraycopy(fSawInclude, 0, newarray, 0, fSawInclude.length);
            fSawInclude = newarray;
        }
        fSawInclude[depth] = val;
!!!5550875.java!!!	getSawInclude(in depth : int) : boolean
        if (depth >= fSawInclude.length) {
            return false;
        }
        return fSawInclude[depth];
!!!5551003.java!!!	reportResourceError(in key : String) : void
        this.reportFatalError(key, null);
!!!5551131.java!!!	reportResourceError(in key : String, inout args : Object) : void
        this.reportError(key, args, XMLErrorReporter.SEVERITY_WARNING);
!!!5551259.java!!!	reportFatalError(in key : String) : void
        this.reportFatalError(key, null);
!!!5551387.java!!!	reportFatalError(in key : String, inout args : Object) : void
        this.reportError(key, args, XMLErrorReporter.SEVERITY_FATAL_ERROR);
!!!5551515.java!!!	reportError(in key : String, inout args : Object, in severity : short) : void
        if (fErrorReporter != null) {
            fErrorReporter.reportError(
            XIncludeMessageFormatter.XINCLUDE_DOMAIN,
            key,
            args,
            severity);
        }
        // we won't worry about when error reporter is null, since there should always be
        // at least the default error reporter
!!!5551643.java!!!	setParent(inout parent : XIncludeHandler) : void
        fParentXIncludeHandler = parent;
!!!5551771.java!!!	isRootDocument() : boolean
        return fParentXIncludeHandler == null;
!!!5551899.java!!!	addUnparsedEntity(in name : String, inout identifier : XMLResourceIdentifier, in notation : String, inout augmentations : Augmentations) : void
        UnparsedEntity ent = new UnparsedEntity();
        ent.name = name;
        ent.systemId = identifier.getLiteralSystemId();
        ent.publicId = identifier.getPublicId();
        ent.baseURI = identifier.getBaseSystemId();
        ent.notation = notation;
        ent.augmentations = augmentations;
        fUnparsedEntities.add(ent);
!!!5552027.java!!!	addNotation(in name : String, inout identifier : XMLResourceIdentifier, inout augmentations : Augmentations) : void
        Notation not = new Notation();
        not.name = name;
        not.systemId = identifier.getLiteralSystemId();
        not.publicId = identifier.getPublicId();
        not.baseURI = identifier.getBaseSystemId();
        not.augmentations = augmentations;
        fNotations.add(not);
!!!5552155.java!!!	checkUnparsedEntity(in entName : String) : void
        UnparsedEntity ent = new UnparsedEntity();
        ent.name = entName;
        int index = fUnparsedEntities.indexOf(ent);
        if (index != -1) {
            ent = (UnparsedEntity)fUnparsedEntities.get(index);
            // first check the notation of the unparsed entity
            checkNotation(ent.notation);
            checkAndSendUnparsedEntity(ent);
        }
!!!5552283.java!!!	checkNotation(in notName : String) : void
        Notation not = new Notation();
        not.name = notName;
        int index = fNotations.indexOf(not);
        if (index != -1) {
            not = (Notation)fNotations.get(index);
            checkAndSendNotation(not);
        }
!!!5552411.java!!!	checkAndSendUnparsedEntity(inout ent : UnparsedEntity) : void
        if (isRootDocument()) {
            int index = fUnparsedEntities.indexOf(ent);
            if (index == -1) {
                // There is no unparsed entity with the same name that we have sent.
                // Calling unparsedEntityDecl() will add the entity to our local store,
                // and also send the unparsed entity to the DTDHandler
                XMLResourceIdentifier id =
                new XMLResourceIdentifierImpl(
                ent.publicId,
                ent.systemId,
                ent.baseURI,
                null);
                this.addUnparsedEntity(
                ent.name,
                id,
                ent.notation,
                ent.augmentations);
                if (fSendUEAndNotationEvents && fDTDHandler != null) {
                    fDTDHandler.unparsedEntityDecl(
                    ent.name,
                    id,
                    ent.notation,
                    ent.augmentations);
                }
            }
            else {
                UnparsedEntity localEntity =
                (UnparsedEntity)fUnparsedEntities.get(index);
                if (!ent.isDuplicate(localEntity)) {
                    reportFatalError(
                    "NonDuplicateUnparsedEntity",
                    new Object[] { ent.name });
                }
            }
        }
        else {
            fParentXIncludeHandler.checkAndSendUnparsedEntity(ent);
        }
!!!5552539.java!!!	checkAndSendNotation(inout not : Notation) : void
        if (isRootDocument()) {
            int index = fNotations.indexOf(not);
            if (index == -1) {
                // There is no notation with the same name that we have sent.
                XMLResourceIdentifier id =
                new XMLResourceIdentifierImpl(
                not.publicId,
                not.systemId,
                not.baseURI,
                null);
                this.addNotation(not.name, id, not.augmentations);
                if (fSendUEAndNotationEvents && fDTDHandler != null) {
                    fDTDHandler.notationDecl(not.name, id, not.augmentations);
                }
            }
            else {
                Notation localNotation = (Notation)fNotations.get(index);
                if (!not.isDuplicate(localNotation)) {
                    reportFatalError(
                    "NonDuplicateNotation",
                    new Object[] { not.name });
                }
            }
        }
        else {
            fParentXIncludeHandler.checkAndSendNotation(not);
        }
!!!5552667.java!!!	copyFeatures(inout from : XMLComponentManager, inout to : ParserConfigurationSettings) : void
        Enumeration features = Constants.getXercesFeatures();
        copyFeatures1(features, Constants.XERCES_FEATURE_PREFIX, from, to);
        features = Constants.getSAXFeatures();
        copyFeatures1(features, Constants.SAX_FEATURE_PREFIX, from, to);
!!!5552795.java!!!	copyFeatures(inout from : XMLComponentManager, inout to : XMLParserConfiguration) : void
        Enumeration features = Constants.getXercesFeatures();
        copyFeatures1(features, Constants.XERCES_FEATURE_PREFIX, from, to);
        features = Constants.getSAXFeatures();
        copyFeatures1(features, Constants.SAX_FEATURE_PREFIX, from, to);
!!!5552923.java!!!	copyFeatures1(inout features : Enumeration, in featurePrefix : String, inout from : XMLComponentManager, inout to : ParserConfigurationSettings) : void
        while (features.hasMoreElements()) {
            String featureId = featurePrefix + (String)features.nextElement();
            
            to.addRecognizedFeatures(new String[] { featureId });
            
            try {
                to.setFeature(featureId, from.getFeature(featureId));
            }
            catch (XMLConfigurationException e) {
                // componentManager doesn't support this feature,
                // so we won't worry about it
            }
        }
!!!5553051.java!!!	copyFeatures1(inout features : Enumeration, in featurePrefix : String, inout from : XMLComponentManager, inout to : XMLParserConfiguration) : void
        while (features.hasMoreElements()) {
            String featureId = featurePrefix + (String)features.nextElement();
            boolean value = from.getFeature(featureId);
            
            try {
                to.setFeature(featureId, value);
            }
            catch (XMLConfigurationException e) {
                // componentManager doesn't support this feature,
                // so we won't worry about it
            }
        }
!!!5553691.java!!!	saveBaseURI() : void
        baseURIScope.push(fDepth);
        baseURI.push(fCurrentBaseURI.getBaseSystemId());
        literalSystemID.push(fCurrentBaseURI.getLiteralSystemId());
        expandedSystemID.push(fCurrentBaseURI.getExpandedSystemId());
!!!5553819.java!!!	restoreBaseURI() : void
        baseURI.pop();
        literalSystemID.pop();
        expandedSystemID.pop();
        baseURIScope.pop();
        fCurrentBaseURI.setBaseSystemId((String)baseURI.peek());
        fCurrentBaseURI.setLiteralSystemId((String)literalSystemID.peek());
        fCurrentBaseURI.setExpandedSystemId((String)expandedSystemID.peek());
!!!5553947.java!!!	getBaseURI(in depth : int) : String
        int scope = scopeOf(depth);
        return (String)expandedSystemID.elementAt(scope);
!!!5554075.java!!!	getRelativeURI(in depth : int) : String
        // The literal system id at the location given by "start" is *in focus* at
        // the given depth. So we need to adjust it to the next scope, so that we
        // only process out of focus literal system ids
        int start = scopeOf(depth) + 1;
        if (start == baseURIScope.size()) {
            // If that is the last system id, then we don't need a relative URI
            return "";
        }
        URI uri = new URI("file", (String)literalSystemID.elementAt(start));
        for (int i = start + 1; i < baseURIScope.size(); i++) {
            uri = new URI(uri, (String)literalSystemID.elementAt(i));
        }
        return uri.getPath();
!!!5554203.java!!!	scopeOf(in depth : int) : int
        for (int i = baseURIScope.size() - 1; i >= 0; i--) {
            if (baseURIScope.elementAt(i) <= depth)
                return i;
        }
        
        // we should never get here, because 0 was put on the stack in startDocument()
        return -1;
!!!5554331.java!!!	processXMLBaseAttributes(inout attributes : XMLAttributes) : void
        String baseURIValue =
        attributes.getValue(NamespaceContext.XML_URI, "base");
        if (baseURIValue != null) {
            try {
                String expandedValue =
                XMLEntityManager.expandSystemId(
                baseURIValue,
                fCurrentBaseURI.getExpandedSystemId(),
                false);
                fCurrentBaseURI.setLiteralSystemId(baseURIValue);
                fCurrentBaseURI.setBaseSystemId(
                fCurrentBaseURI.getExpandedSystemId());
                fCurrentBaseURI.setExpandedSystemId(expandedValue);
                
                // push the new values on the stack
                saveBaseURI();
            }
            catch (MalformedURIException e) {
                // REVISIT: throw error here
            }
        }
!!!5554459.java!!!	setHttpProperties(inout source : XMLInputSource, inout attributes : XMLAttributes) : XMLInputSource
        String httpAcceptLang = attributes.getValue(HTTP_ACCEPT_LANGUAGE);
        String httpAccept = attributes.getValue(HTTP_ACCEPT);
        String httpAcceptchar = attributes.getValue(HTTP_ACCEPT_CHARSET);
        if (source.getCharacterStream() == null && source.getByteStream() == null) {
            XIncludeInputSource includeSource = new XIncludeInputSource(source.getPublicId(),source.getSystemId(),source.getBaseSystemId(), source.getByteStream(),source.getEncoding());
            includeSource.setProperty(XINCLUDE_ATTR_ACCEPT,attributes.getValue(XINCLUDE_ATTR_ACCEPT));
            includeSource.setProperty(XINCLUDE_ATTR_ACCEPT_CHARSET,attributes.getValue(XINCLUDE_ATTR_ACCEPT_CHARSET));
            includeSource.setProperty(XINCLUDE_ATTR_ACCEPT_LANGUAGE,attributes.getValue(XINCLUDE_ATTR_ACCEPT_LANGUAGE));
        }
        return source;
!!!5554587.java!!!	processSchema(inout fXPointerSchemaS : XPointerSchema, inout includedSource : XMLInputSource) : boolean
        try{
            fChildConfig = createXPointerParser();//for now -Revisit and change this.
            fChildConfig.setProperty(Constants.XERCES_PROPERTY_PREFIX
            + Constants.XINCLUDE_HANDLER_PROPERTY,
            fXPointerSchemaS);
            fXPointerSchemaS.setParent(this);
            fXPointerSchemaS.setDocumentHandler(this.getDocumentHandler());
            fChildConfig.parse(includedSource);
        }
        catch (Exception e) {
            //Venu For now do this.
            reportResourceError(
            "XMLResourceError",
            new Object[] { null, e.getMessage()});
        }
        return fXPointerSchemaS.isSubResourceIndentified();
!!!5554715.java!!!	isValidInHTTPHeader(in value : String) : boolean
        char ch;
        for (int i = value.length() - 1; i >= 0; --i) {
            ch = value.charAt(i);
            if (ch < 0x20 || ch > 0x7E) {
                return false;
            }
        }
        return true;
!!!5554843.java!!!	createXPointerParser() : XMLParserConfiguration
        XMLParserConfiguration childConfig =
        (XMLParserConfiguration)ObjectFactory.newInstance(
        XPOINTER_DEFAULT_CONFIGURATION,
        ObjectFactory.findClassLoader(),
        true);
        childConfig.setProperty(ERROR_REPORTER, fErrorReporter);
        childConfig.setProperty(
        Constants.XERCES_PROPERTY_PREFIX
        + Constants.NAMESPACE_CONTEXT_PROPERTY,
        fNamespaceContext);
        copyFeatures(fSettings, childConfig);
        return childConfig;
