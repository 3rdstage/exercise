class BasicTreeUI
!!!2878747.java!!!	createUI(inout x : JComponent) : ComponentUI
	return new BasicTreeUI();
!!!2878875.java!!!	loadActionMap(inout map : LazyActionMap) : void
	map.put(new Actions(Actions.SELECT_PREVIOUS));
        map.put(new Actions(Actions.SELECT_PREVIOUS_CHANGE_LEAD));
	map.put(new Actions(Actions.SELECT_PREVIOUS_EXTEND_SELECTION));

	map.put(new Actions(Actions.SELECT_NEXT));
	map.put(new Actions(Actions.SELECT_NEXT_CHANGE_LEAD));
	map.put(new Actions(Actions.SELECT_NEXT_EXTEND_SELECTION));

	map.put(new Actions(Actions.SELECT_CHILD));
	map.put(new Actions(Actions.SELECT_CHILD_CHANGE_LEAD));

	map.put(new Actions(Actions.SELECT_PARENT));
	map.put(new Actions(Actions.SELECT_PARENT_CHANGE_LEAD));

	map.put(new Actions(Actions.SCROLL_UP_CHANGE_SELECTION));
	map.put(new Actions(Actions.SCROLL_UP_CHANGE_LEAD));
	map.put(new Actions(Actions.SCROLL_UP_EXTEND_SELECTION));

	map.put(new Actions(Actions.SCROLL_DOWN_CHANGE_SELECTION));
	map.put(new Actions(Actions.SCROLL_DOWN_EXTEND_SELECTION));
	map.put(new Actions(Actions.SCROLL_DOWN_CHANGE_LEAD));

	map.put(new Actions(Actions.SELECT_FIRST));
	map.put(new Actions(Actions.SELECT_FIRST_CHANGE_LEAD));
	map.put(new Actions(Actions.SELECT_FIRST_EXTEND_SELECTION));

	map.put(new Actions(Actions.SELECT_LAST));
	map.put(new Actions(Actions.SELECT_LAST_CHANGE_LEAD));
	map.put(new Actions(Actions.SELECT_LAST_EXTEND_SELECTION));

	map.put(new Actions(Actions.TOGGLE));

	map.put(new Actions(Actions.CANCEL_EDITING));

	map.put(new Actions(Actions.START_EDITING));

	map.put(new Actions(Actions.SELECT_ALL));

	map.put(new Actions(Actions.CLEAR_SELECTION));

	map.put(new Actions(Actions.SCROLL_LEFT));
	map.put(new Actions(Actions.SCROLL_RIGHT));

	map.put(new Actions(Actions.SCROLL_LEFT_EXTEND_SELECTION));
	map.put(new Actions(Actions.SCROLL_RIGHT_EXTEND_SELECTION));

	map.put(new Actions(Actions.SCROLL_RIGHT_CHANGE_LEAD));
	map.put(new Actions(Actions.SCROLL_LEFT_CHANGE_LEAD));

        map.put(new Actions(Actions.EXPAND));
        map.put(new Actions(Actions.COLLAPSE));
        map.put(new Actions(Actions.MOVE_SELECTION_TO_PARENT));

        map.put(new Actions(Actions.ADD_TO_SELECTION));
        map.put(new Actions(Actions.TOGGLE_AND_ANCHOR));
        map.put(new Actions(Actions.EXTEND_TO));
        map.put(new Actions(Actions.MOVE_SELECTION_TO));

        map.put(TransferHandler.getCutAction());
        map.put(TransferHandler.getCopyAction());
        map.put(TransferHandler.getPasteAction());
!!!2879003.java!!!	BasicTreeUI()
	super();
!!!2879131.java!!!	getHashColor() : Color
        return hashColor;
!!!2879259.java!!!	setHashColor(inout color : Color) : void
        hashColor = color;
!!!2879387.java!!!	setLeftChildIndent(in newAmount : int) : void
	leftChildIndent = newAmount;
	totalChildIndent = leftChildIndent + rightChildIndent;
	if(treeState != null)
	    treeState.invalidateSizes();
	updateSize();
!!!2879515.java!!!	getLeftChildIndent() : int
	return leftChildIndent;
!!!2879643.java!!!	setRightChildIndent(in newAmount : int) : void
	rightChildIndent = newAmount;
	totalChildIndent = leftChildIndent + rightChildIndent;
	if(treeState != null)
	    treeState.invalidateSizes();
	updateSize();
!!!2879771.java!!!	getRightChildIndent() : int
	return rightChildIndent;
!!!2879899.java!!!	setExpandedIcon(inout newG : Icon) : void
	expandedIcon = newG;
!!!2880027.java!!!	getExpandedIcon() : Icon
	return expandedIcon;
!!!2880155.java!!!	setCollapsedIcon(inout newG : Icon) : void
	collapsedIcon = newG;
!!!2880283.java!!!	getCollapsedIcon() : Icon
	return collapsedIcon;
!!!2880411.java!!!	setLargeModel(inout largeModel : boolean) : void
	if(getRowHeight() < 1)
	    largeModel = false;
	if(this.largeModel != largeModel) {
	    completeEditing();
	    this.largeModel = largeModel;
	    treeState = createLayoutCache();
	    configureLayoutCache();
	    updateLayoutCacheExpandedNodes();
	    updateSize();
	}
!!!2880539.java!!!	isLargeModel() : boolean
	return largeModel;
!!!2880667.java!!!	setRowHeight(in rowHeight : int) : void
	completeEditing();
	if(treeState != null) {
	    setLargeModel(tree.isLargeModel());
	    treeState.setRowHeight(rowHeight);
	    updateSize();
	}
!!!2880795.java!!!	getRowHeight() : int
	return (tree == null) ? -1 : tree.getRowHeight();
!!!2880923.java!!!	setCellRenderer(inout tcr : TreeCellRenderer) : void
	completeEditing();
	updateRenderer();
	if(treeState != null) {
	    treeState.invalidateSizes();
	    updateSize();
	}
!!!2881051.java!!!	getCellRenderer() : TreeCellRenderer
	return currentCellRenderer;
!!!2881179.java!!!	setModel(inout model : TreeModel) : void
	completeEditing();
	if(treeModel != null && treeModelListener != null)
	    treeModel.removeTreeModelListener(treeModelListener);
	treeModel = model;
	if(treeModel != null) {
	    if(treeModelListener != null)
		treeModel.addTreeModelListener(treeModelListener);
	}
	if(treeState != null) {
	    treeState.setModel(model);
	    updateLayoutCacheExpandedNodes();
	    updateSize();
	}
!!!2881307.java!!!	getModel() : TreeModel
	return treeModel;
!!!2881435.java!!!	setRootVisible(inout newValue : boolean) : void
	completeEditing();
	updateDepthOffset();
	if(treeState != null) {
	    treeState.setRootVisible(newValue);
	    treeState.invalidateSizes();
	    updateSize();
	}
!!!2881563.java!!!	isRootVisible() : boolean
	return (tree != null) ? tree.isRootVisible() : false;
!!!2881691.java!!!	setShowsRootHandles(inout newValue : boolean) : void
	completeEditing();
	updateDepthOffset();
	if(treeState != null) {
	    treeState.invalidateSizes();
	    updateSize();
	}
!!!2881819.java!!!	getShowsRootHandles() : boolean
	return (tree != null) ? tree.getShowsRootHandles() : false;
!!!2881947.java!!!	setCellEditor(inout editor : TreeCellEditor) : void
	updateCellEditor();
!!!2882075.java!!!	getCellEditor() : TreeCellEditor
	return (tree != null) ? tree.getCellEditor() : null;
!!!2882203.java!!!	setEditable(inout newValue : boolean) : void
	updateCellEditor();
!!!2882331.java!!!	isEditable() : boolean
	return (tree != null) ? tree.isEditable() : false;
!!!2882459.java!!!	setSelectionModel(inout newLSM : TreeSelectionModel) : void
	completeEditing();
	if(selectionModelPropertyChangeListener != null &&
	   treeSelectionModel != null)
	    treeSelectionModel.removePropertyChangeListener
		              (selectionModelPropertyChangeListener);
	if(treeSelectionListener != null && treeSelectionModel != null)
	    treeSelectionModel.removeTreeSelectionListener
		               (treeSelectionListener);
	treeSelectionModel = newLSM;
	if(treeSelectionModel != null) {
	    if(selectionModelPropertyChangeListener != null)
		treeSelectionModel.addPropertyChangeListener
		              (selectionModelPropertyChangeListener);
	    if(treeSelectionListener != null)
		treeSelectionModel.addTreeSelectionListener
		                   (treeSelectionListener);
	    if(treeState != null)
		treeState.setSelectionModel(treeSelectionModel);
	}
	else if(treeState != null)
	    treeState.setSelectionModel(null);
	if(tree != null)
	    tree.repaint();
!!!2882587.java!!!	getSelectionModel() : TreeSelectionModel
	return treeSelectionModel;
!!!2882715.java!!!	getPathBounds(inout tree : JTree, inout path : TreePath) : Rectangle
	if(tree != null && treeState != null) {
	    Insets           i = tree.getInsets();
	    Rectangle        bounds = treeState.getBounds(path, null);

	    if(bounds != null && i != null) {
		bounds.x += i.left;
		bounds.y += i.top;
	    }
	    return bounds;
	}
	return null;
!!!2882843.java!!!	getPathForRow(inout tree : JTree, in row : int) : TreePath
	return (treeState != null) ? treeState.getPathForRow(row) : null;
!!!2882971.java!!!	getRowForPath(inout tree : JTree, inout path : TreePath) : int
	return (treeState != null) ? treeState.getRowForPath(path) : -1;
!!!2883099.java!!!	getRowCount(inout tree : JTree) : int
	return (treeState != null) ? treeState.getRowCount() : 0;
!!!2883227.java!!!	getClosestPathForLocation(inout tree : JTree, in x : int, in y : int) : TreePath
	if(tree != null && treeState != null) {
	    Insets          i = tree.getInsets();

	    if(i == null)
		i = EMPTY_INSETS;

	    return treeState.getPathClosestTo(x - i.left, y - i.top);
	}
	return null;
!!!2883355.java!!!	isEditing(inout tree : JTree) : boolean
	return (editingComponent != null);
!!!2883483.java!!!	stopEditing(inout tree : JTree) : boolean
	if(editingComponent != null && cellEditor.stopCellEditing()) {
	    completeEditing(false, false, true);
	    return true;
	}
	return false;
!!!2883611.java!!!	cancelEditing(inout tree : JTree) : void
	if(editingComponent != null) {
	    completeEditing(false, true, false);
	}
!!!2883739.java!!!	startEditingAtPath(inout tree : JTree, inout path : TreePath) : void
	tree.scrollPathToVisible(path);
	if(path != null && tree.isVisible(path))
	    startEditing(path, null);
!!!2883867.java!!!	getEditingPath(inout tree : JTree) : TreePath
	return editingPath;
!!!2883995.java!!!	installUI(inout c : JComponent) : void
        if ( c == null ) {
	    throw new NullPointerException( "null component passed to BasicTreeUI.installUI()" );
        }

	tree = (JTree)c;

	prepareForUIInstall();

	// Boilerplate install block
	installDefaults();
	installKeyboardActions();
	installComponents();
	installListeners();

	completeUIInstall();
!!!2884123.java!!!	prepareForUIInstall() : void
	drawingCache = new Hashtable<TreePath,Boolean>(7);

	// Data member initializations
	leftToRight = BasicGraphicsUtils.isLeftToRight(tree);
	lastWidth = tree.getWidth();
	stopEditingInCompleteEditing = true;
	lastSelectedRow = -1;
	leadRow = -1;
	preferredSize = new Dimension();

	largeModel = tree.isLargeModel();
	if(getRowHeight() <= 0)
	    largeModel = false;
	setModel(tree.getModel());
!!!2884251.java!!!	completeUIInstall() : void
	// Custom install code

	this.setShowsRootHandles(tree.getShowsRootHandles());

	updateRenderer();

	updateDepthOffset();

	setSelectionModel(tree.getSelectionModel());

	// Create, if necessary, the TreeState instance.
	treeState = createLayoutCache();
	configureLayoutCache();

	updateSize();
!!!2884379.java!!!	installDefaults() : void
	if(tree.getBackground() == null ||
	   tree.getBackground() instanceof UIResource) {
	    tree.setBackground(UIManager.getColor("Tree.background"));
	} 
	if(getHashColor() == null || getHashColor() instanceof UIResource) {
	    setHashColor(UIManager.getColor("Tree.hash"));
	}
	if (tree.getFont() == null || tree.getFont() instanceof UIResource)
	    tree.setFont( UIManager.getFont("Tree.font") );
        // JTree's original row height is 16.  To correctly display the
        // contents on Linux we should have set it to 18, Windows 19 and
        // Solaris 20.  As these values vary so much it's too hard to
        // be backward compatable and try to update the row height, we're
        // therefor NOT going to adjust the row height based on font.  If the
        // developer changes the font, it's there responsibility to update
        // the row height.

	setExpandedIcon( (Icon)UIManager.get( "Tree.expandedIcon" ) );
	setCollapsedIcon( (Icon)UIManager.get( "Tree.collapsedIcon" ) );

	setLeftChildIndent(((Integer)UIManager.get("Tree.leftChildIndent")).
			   intValue());
	setRightChildIndent(((Integer)UIManager.get("Tree.rightChildIndent")).
			   intValue());

	LookAndFeel.installProperty(tree, "rowHeight",
				    UIManager.get("Tree.rowHeight"));

        largeModel = (tree.isLargeModel() && tree.getRowHeight() > 0);

	Object scrollsOnExpand = UIManager.get("Tree.scrollsOnExpand");
	if (scrollsOnExpand != null) {
	    LookAndFeel.installProperty(tree, "scrollsOnExpand", scrollsOnExpand);
	}

	paintLines = UIManager.getBoolean("Tree.paintLines");
	lineTypeDashed = UIManager.getBoolean("Tree.lineTypeDashed");
	
 	Long l = (Long)UIManager.get("Tree.timeFactor");
 	timeFactor = (l!=null) ? l.longValue() : 1000L;
        
        Object showsRootHandles = UIManager.get("Tree.showsRootHandles");
        if (showsRootHandles != null) {
            LookAndFeel.installProperty(tree, 
                    JTree.SHOWS_ROOT_HANDLES_PROPERTY, showsRootHandles);
        }
!!!2884507.java!!!	installListeners() : void
        if ( (propertyChangeListener = createPropertyChangeListener())
	     != null ) {
	    tree.addPropertyChangeListener(propertyChangeListener);
	}
        if (!DRAG_FIX) {
            tree.addMouseListener(defaultDragRecognizer);
            tree.addMouseMotionListener(defaultDragRecognizer);
        }
        if ( (mouseListener = createMouseListener()) != null ) {
	    tree.addMouseListener(mouseListener);
	    if (mouseListener instanceof MouseMotionListener) {
		tree.addMouseMotionListener((MouseMotionListener)mouseListener);
	    }
	}
        if ((focusListener = createFocusListener()) != null ) {
	    tree.addFocusListener(focusListener);
	}
        if ((keyListener = createKeyListener()) != null) {
	    tree.addKeyListener(keyListener);
	}
	if((treeExpansionListener = createTreeExpansionListener()) != null) {
	    tree.addTreeExpansionListener(treeExpansionListener);
	}
	if((treeModelListener = createTreeModelListener()) != null &&
	   treeModel != null) {
	    treeModel.addTreeModelListener(treeModelListener);
	}
	if((selectionModelPropertyChangeListener =
	    createSelectionModelPropertyChangeListener()) != null &&
	   treeSelectionModel != null) {
	    treeSelectionModel.addPropertyChangeListener
		(selectionModelPropertyChangeListener);
	}
	if((treeSelectionListener = createTreeSelectionListener()) != null &&
	   treeSelectionModel != null) {
	    treeSelectionModel.addTreeSelectionListener(treeSelectionListener);
	}

	TransferHandler th = tree.getTransferHandler();
	if (th == null || th instanceof UIResource) {
	    tree.setTransferHandler(defaultTransferHandler);
	}
	DropTarget dropTarget = tree.getDropTarget();
	if (dropTarget instanceof UIResource) {
            if (defaultDropTargetListener == null) {
                defaultDropTargetListener = new TreeDropTargetListener();
            }
	    try {
		dropTarget.addDropTargetListener(defaultDropTargetListener);
	    } catch (TooManyListenersException tmle) {
		// should not happen... swing drop target is multicast
	    }
	}
        LookAndFeel.installProperty(tree, "opaque", Boolean.TRUE);
!!!2884635.java!!!	installKeyboardActions() : void
	InputMap km = getInputMap(JComponent.
				  WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

	SwingUtilities.replaceUIInputMap(tree, JComponent.
					 WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
					 km);
	km = getInputMap(JComponent.WHEN_FOCUSED);
	SwingUtilities.replaceUIInputMap(tree, JComponent.WHEN_FOCUSED, km);

        LazyActionMap.installLazyActionMap(tree, BasicTreeUI.class,
                                           "Tree.actionMap");
!!!2884763.java!!!	getInputMap(in condition : int) : InputMap
	if (condition == JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT) {
	    return (InputMap)DefaultLookup.get(tree, this,
                                               "Tree.ancestorInputMap");
	}
	else if (condition == JComponent.WHEN_FOCUSED) {
	    InputMap keyMap = (InputMap)DefaultLookup.get(tree, this,
                                                      "Tree.focusInputMap");
	    InputMap rtlKeyMap;

	    if (tree.getComponentOrientation().isLeftToRight() ||
		  ((rtlKeyMap = (InputMap)DefaultLookup.get(tree, this,
                  "Tree.focusInputMap.RightToLeft")) == null)) {
		return keyMap;
	    } else {
		rtlKeyMap.setParent(keyMap);
		return rtlKeyMap;
	    }
	}
	return null;
!!!2884891.java!!!	installComponents() : void
	if ((rendererPane = createCellRendererPane()) != null) {
	    tree.add( rendererPane );
	}
!!!2885019.java!!!	createNodeDimensions() : NodeDimensions
	return new NodeDimensionsHandler();
!!!2885147.java!!!	createPropertyChangeListener() : PropertyChangeListener
        return getHandler();
!!!2885275.java!!!	getHandler() : Handler
        if (handler == null) {
            handler = DRAG_FIX ? new DragFixHandler() : new Handler();
        }
        return handler;
!!!2885403.java!!!	createMouseListener() : MouseListener
        return getHandler();
!!!2885531.java!!!	createFocusListener() : FocusListener
        return getHandler();
!!!2885659.java!!!	createKeyListener() : KeyListener
        return getHandler();
!!!2885787.java!!!	createSelectionModelPropertyChangeListener() : PropertyChangeListener
	return getHandler();
!!!2885915.java!!!	createTreeSelectionListener() : TreeSelectionListener
	return getHandler();
!!!2886043.java!!!	createCellEditorListener() : CellEditorListener
	return getHandler();
!!!2886171.java!!!	createComponentListener() : ComponentListener
	return new ComponentHandler();
!!!2886299.java!!!	createTreeExpansionListener() : TreeExpansionListener
	return getHandler();
!!!2886427.java!!!	createLayoutCache() : AbstractLayoutCache
	if(isLargeModel() && getRowHeight() > 0) {
	    return new FixedHeightLayoutCache();
	}
	return new VariableHeightLayoutCache();
!!!2886555.java!!!	createCellRendererPane() : CellRendererPane
        return new CellRendererPane();
!!!2886683.java!!!	createDefaultCellEditor() : TreeCellEditor
	if(currentCellRenderer != null &&
	   (currentCellRenderer instanceof DefaultTreeCellRenderer)) {
	    DefaultTreeCellEditor editor = new DefaultTreeCellEditor
		        (tree, (DefaultTreeCellRenderer)currentCellRenderer);

	    return editor;
	}
	return new DefaultTreeCellEditor(tree, null);
!!!2886811.java!!!	createDefaultCellRenderer() : TreeCellRenderer
	return new DefaultTreeCellRenderer();
!!!2886939.java!!!	createTreeModelListener() : TreeModelListener
	return getHandler();
!!!2887067.java!!!	uninstallUI(inout c : JComponent) : void
	completeEditing();

	prepareForUIUninstall();

	uninstallDefaults();
	uninstallListeners();
	uninstallKeyboardActions();
	uninstallComponents();

	completeUIUninstall();
!!!2887323.java!!!	completeUIUninstall() : void
	if(createdRenderer) {
	    tree.setCellRenderer(null);
	}
	if(createdCellEditor) {
	    tree.setCellEditor(null);
	}
	cellEditor = null;
	currentCellRenderer = null;
	rendererPane = null;
        componentListener = null;
	propertyChangeListener = null;
	mouseListener = null;
	focusListener = null;
	keyListener = null;
	setSelectionModel(null);
	treeState = null;
	drawingCache = null;
	selectionModelPropertyChangeListener = null;
	tree = null;
	treeModel = null;
	treeSelectionModel = null;
	treeSelectionListener = null;
	treeExpansionListener = null;
!!!2887451.java!!!	uninstallDefaults() : void
	if (tree.getTransferHandler() instanceof UIResource) {
	    tree.setTransferHandler(null);
	}
!!!2887579.java!!!	uninstallListeners() : void
	if(componentListener != null) {
	    tree.removeComponentListener(componentListener);
	}
        if (propertyChangeListener != null) {
	    tree.removePropertyChangeListener(propertyChangeListener);
	}
        if (!DRAG_FIX) {
            tree.removeMouseListener(defaultDragRecognizer);
            tree.removeMouseMotionListener(defaultDragRecognizer);
        }
        if (mouseListener != null) {
	    tree.removeMouseListener(mouseListener);
	    if (mouseListener instanceof MouseMotionListener) {
		tree.removeMouseMotionListener((MouseMotionListener)mouseListener);
	    }
	}
        if (focusListener != null) {
	    tree.removeFocusListener(focusListener);
	}
        if (keyListener != null) {
	    tree.removeKeyListener(keyListener);
	}
	if(treeExpansionListener != null) {
	    tree.removeTreeExpansionListener(treeExpansionListener);
	}
	if(treeModel != null && treeModelListener != null) {
	    treeModel.removeTreeModelListener(treeModelListener);
	}
	if(selectionModelPropertyChangeListener != null &&
	   treeSelectionModel != null) {
	    treeSelectionModel.removePropertyChangeListener
		(selectionModelPropertyChangeListener);
	}
	if(treeSelectionListener != null && treeSelectionModel != null) {
	    treeSelectionModel.removeTreeSelectionListener
		               (treeSelectionListener);
	}
        handler = null;
!!!2887707.java!!!	uninstallKeyboardActions() : void
	SwingUtilities.replaceUIActionMap(tree, null);
	SwingUtilities.replaceUIInputMap(tree, JComponent.
					 WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
					 null);
	SwingUtilities.replaceUIInputMap(tree, JComponent.WHEN_FOCUSED, null);
!!!2887835.java!!!	uninstallComponents() : void
	if(rendererPane != null) {
	    tree.remove(rendererPane);
	}
!!!2887963.java!!!	redoTheLayout() : void
	if (treeState != null) {
	    treeState.invalidateSizes();
	}
!!!2888091.java!!!	paint(inout g : Graphics, inout c : JComponent) : void
	if (tree != c) {
	    throw new InternalError("incorrect component");
	}

	// Should never happen if installed for a UI
	if(treeState == null) {
	    return;
	}

	// Update the lastWidth if necessary.
	// This should really come from a ComponentListener installed on
	// the JTree, but for the time being it is here.
	int              width = tree.getWidth();

	if (width != lastWidth) {
	    lastWidth = width;
	    if (!leftToRight) {
		// For RTL when the size changes, we have to refresh the
		// cache as the X position is based off the width.
		redoTheLayout();
		updateSize();
	    }
	}

	Rectangle        paintBounds = g.getClipBounds();
	Insets           insets = tree.getInsets();

	if(insets == null)
	    insets = EMPTY_INSETS;

	TreePath         initialPath = getClosestPathForLocation
	                               (tree, 0, paintBounds.y);
	Enumeration      paintingEnumerator = treeState.getVisiblePathsFrom
	                                      (initialPath);
	int              row = treeState.getRowForPath(initialPath);
	int              endY = paintBounds.y + paintBounds.height;

	drawingCache.clear();

	if(initialPath != null && paintingEnumerator != null) {
	    TreePath   parentPath = initialPath;

	    // Draw the lines, knobs, and rows

	    // Find each parent and have them draw a line to their last child
	    parentPath = parentPath.getParentPath();
	    while(parentPath != null) {
		paintVerticalPartOfLeg(g, paintBounds, insets, parentPath);
		drawingCache.put(parentPath, Boolean.TRUE);
		parentPath = parentPath.getParentPath();
	    }

	    boolean         done = false;
	    // Information for the node being rendered.
	    boolean         isExpanded;
	    boolean         hasBeenExpanded;
	    boolean         isLeaf;
	    Rectangle       boundsBuffer = new Rectangle();
	    Rectangle       bounds;
	    TreePath        path;
	    boolean         rootVisible = isRootVisible();

	    while(!done && paintingEnumerator.hasMoreElements()) {
		path = (TreePath)paintingEnumerator.nextElement();
		if(path != null) {
		    isLeaf = treeModel.isLeaf(path.getLastPathComponent());
		    if(isLeaf)
			isExpanded = hasBeenExpanded = false;
		    else {
			isExpanded = treeState.getExpandedState(path);
			hasBeenExpanded = tree.hasBeenExpanded(path);
		    }
		    bounds = treeState.getBounds(path, boundsBuffer);
		    if(bounds == null)
			// This will only happen if the model changes out
			// from under us (usually in another thread).
			// Swing isn't multithreaded, but I'll put this
			// check in anyway.
			return;
		    bounds.x += insets.left;
		    bounds.y += insets.top;
		    // See if the vertical line to the parent has been drawn.
		    parentPath = path.getParentPath();
		    if(parentPath != null) {
			if(drawingCache.get(parentPath) == null) {
			    paintVerticalPartOfLeg(g, paintBounds,
						   insets, parentPath);
			    drawingCache.put(parentPath, Boolean.TRUE);
			}
			paintHorizontalPartOfLeg(g, paintBounds, insets,
						 bounds, path, row,
						 isExpanded,
						 hasBeenExpanded, isLeaf);
		    }
		    else if(rootVisible && row == 0) {
			paintHorizontalPartOfLeg(g, paintBounds, insets,
						 bounds, path, row,
						 isExpanded,
						 hasBeenExpanded, isLeaf);
		    }
		    if(shouldPaintExpandControl(path, row, isExpanded,
						hasBeenExpanded, isLeaf)) {
			paintExpandControl(g, paintBounds, insets, bounds,
					   path, row, isExpanded,
					   hasBeenExpanded, isLeaf);
		    }
                    //This is the quick fix for bug 4259260.  Somewhere we
                    //are out by 4 pixels in the RTL layout.  Its probably
                    //due to built in right-side padding in some icons.  Rather
                    //than ferret out problem at the source, this compensates. 
            	    if (!leftToRight) {
                        bounds.x +=4;
                    }
		    paintRow(g, paintBounds, insets, bounds, path,
				 row, isExpanded, hasBeenExpanded, isLeaf);
		    if((bounds.y + bounds.height) >= endY)
			done = true;
		}
		else {
		    done = true;
		}
		row++;
	    }
	}
	// Empty out the renderer pane, allowing renderers to be gc'ed.
	rendererPane.removeAll();
!!!2888219.java!!!	paintHorizontalPartOfLeg(inout g : Graphics, inout clipBounds : Rectangle, inout insets : Insets, inout bounds : Rectangle, inout path : TreePath, in row : int, inout isExpanded : boolean, inout hasBeenExpanded : boolean, inout isLeaf : boolean) : void
	if (!paintLines) {
	    return;
	}

        // Don't paint the legs for the root'ish node if the
        int depth = path.getPathCount() - 1;
	if((depth == 0 || (depth == 1 && !isRootVisible())) &&
	   !getShowsRootHandles()) {
	    return;
        }

	int clipLeft = clipBounds.x;
	int clipRight = clipBounds.x + (clipBounds.width - 1);
	int clipTop = clipBounds.y;
	int clipBottom = clipBounds.y + (clipBounds.height - 1);
	int lineY = bounds.y + bounds.height / 2;
	// Offset leftX from parents indent.
	if (leftToRight) {
	    int leftX = bounds.x - getRightChildIndent();
	    int nodeX = bounds.x - getHorizontalLegBuffer();
	
	    if(lineY >= clipTop && lineY <= clipBottom && nodeX >= clipLeft &&
	                                                 leftX <= clipRight ) {
	        leftX = Math.max(Math.max(insets.left, leftX), clipLeft);
		nodeX = Math.min(Math.max(insets.left, nodeX), clipRight);

                if (leftX != nodeX) {
                    g.setColor(getHashColor());
                    paintHorizontalLine(g, tree, lineY, leftX, nodeX);
                }
	    }
	}
	else {
	    int leftX = bounds.x + bounds.width + getRightChildIndent();
	    int nodeX = bounds.x + bounds.width + 
	                                  getHorizontalLegBuffer() - 1;

	    if(lineY >= clipTop && lineY <= clipBottom &&
	       leftX >= clipLeft && nodeX <= clipRight) {
	        leftX = Math.min(leftX, clipRight);
		nodeX = Math.max(nodeX, clipLeft);

		g.setColor(getHashColor());
		paintHorizontalLine(g, tree, lineY, nodeX, leftX);
	    }
	}
!!!2888347.java!!!	paintVerticalPartOfLeg(inout g : Graphics, inout clipBounds : Rectangle, inout insets : Insets, inout path : TreePath) : void
	if (!paintLines) {
	    return;
	}

        int depth = path.getPathCount() - 1;
	if (depth == 0 && !getShowsRootHandles() && !isRootVisible()) {
	    return;
        }
	int lineX = getRowX(-1, depth + 1);
	if (leftToRight) {
            lineX = lineX - getRightChildIndent() + insets.left;
	}
	else {
	    lineX = lastWidth - getRowX(-1, depth) - 9;
	}
	int clipLeft = clipBounds.x;
	int clipRight = clipBounds.x + (clipBounds.width - 1);

	if (lineX >= clipLeft && lineX <= clipRight) {
	    int clipTop = clipBounds.y;
	    int clipBottom = clipBounds.y + clipBounds.height;
	    Rectangle parentBounds = getPathBounds(tree, path);
	    Rectangle lastChildBounds = getPathBounds(tree,
						     getLastChildPath(path));

	    if(lastChildBounds == null)
		// This shouldn't happen, but if the model is modified
		// in another thread it is possible for this to happen.
		// Swing isn't multithreaded, but I'll add this check in
		// anyway.
		return;

	    int       top;

	    if(parentBounds == null) {
		top = Math.max(insets.top + getVerticalLegBuffer(),
			       clipTop);
	    }
	    else
		top = Math.max(parentBounds.y + parentBounds.height +
			       getVerticalLegBuffer(), clipTop);
	    if(depth == 0 && !isRootVisible()) {
		TreeModel      model = getModel();

		if(model != null) {
		    Object        root = model.getRoot();

		    if(model.getChildCount(root) > 0) {
			parentBounds = getPathBounds(tree, path.
				  pathByAddingChild(model.getChild(root, 0)));
			if(parentBounds != null)
			    top = Math.max(insets.top + getVerticalLegBuffer(),
					   parentBounds.y +
					   parentBounds.height / 2);
		    }
		}
	    }

	    int bottom = Math.min(lastChildBounds.y +
				  (lastChildBounds.height / 2), clipBottom);

            if (top <= bottom) {
                g.setColor(getHashColor());
                paintVerticalLine(g, tree, lineX, top, bottom);
            }
	}
!!!2888475.java!!!	paintExpandControl(inout g : Graphics, inout clipBounds : Rectangle, inout insets : Insets, inout bounds : Rectangle, inout path : TreePath, in row : int, inout isExpanded : boolean, inout hasBeenExpanded : boolean, inout isLeaf : boolean) : void
	Object       value = path.getLastPathComponent();

	// Draw icons if not a leaf and either hasn't been loaded,
	// or the model child count is > 0.
	if (!isLeaf && (!hasBeenExpanded ||
			treeModel.getChildCount(value) > 0)) {
	    int middleXOfKnob;
	    if (leftToRight) {
	        middleXOfKnob = bounds.x - (getRightChildIndent() - 1);
	    }
	    else {
	        middleXOfKnob = bounds.x + bounds.width + getRightChildIndent();
	    }
	    int middleYOfKnob = bounds.y + (bounds.height / 2);

	    if (isExpanded) {
		Icon expandedIcon = getExpandedIcon();
		if(expandedIcon != null)
		  drawCentered(tree, g, expandedIcon, middleXOfKnob,
			       middleYOfKnob );
	    }
	    else {
		Icon collapsedIcon = getCollapsedIcon();
		if(collapsedIcon != null)
		  drawCentered(tree, g, collapsedIcon, middleXOfKnob,
			       middleYOfKnob);
	    }
	}
!!!2888603.java!!!	paintRow(inout g : Graphics, inout clipBounds : Rectangle, inout insets : Insets, inout bounds : Rectangle, inout path : TreePath, in row : int, inout isExpanded : boolean, inout hasBeenExpanded : boolean, inout isLeaf : boolean) : void
	// Don't paint the renderer if editing this row.
	if(editingComponent != null && editingRow == row)
	    return;

	int leadIndex;

	if(tree.hasFocus()) {
	    leadIndex = getLeadSelectionRow();
	}
	else
	    leadIndex = -1;

	Component component;

	component = currentCellRenderer.getTreeCellRendererComponent
	              (tree, path.getLastPathComponent(),
		       tree.isRowSelected(row), isExpanded, isLeaf, row,
		       (leadIndex == row));
	
	rendererPane.paintComponent(g, component, tree, bounds.x, bounds.y,
				    bounds.width, bounds.height, true);	
!!!2888731.java!!!	shouldPaintExpandControl(inout path : TreePath, in row : int, inout isExpanded : boolean, inout hasBeenExpanded : boolean, inout isLeaf : boolean) : boolean
	if(isLeaf)
	    return false;

	int              depth = path.getPathCount() - 1;

	if((depth == 0 || (depth == 1 && !isRootVisible())) &&
	   !getShowsRootHandles())
	    return false;
	return true;
!!!2888859.java!!!	paintVerticalLine(inout g : Graphics, inout c : JComponent, in x : int, in top : int, in bottom : int) : void
	if (lineTypeDashed) {
	    drawDashedVerticalLine(g, x, top, bottom);
	} else {
	    g.drawLine(x, top, x, bottom);
	}
!!!2888987.java!!!	paintHorizontalLine(inout g : Graphics, inout c : JComponent, in y : int, in left : int, in right : int) : void
	if (lineTypeDashed) {
	    drawDashedHorizontalLine(g, y, left, right);
	} else {
	    g.drawLine(left, y, right, y);
	}
!!!2889115.java!!!	getVerticalLegBuffer() : int
	return 0;
!!!2889243.java!!!	getHorizontalLegBuffer() : int
	return 0;
!!!2889371.java!!!	drawCentered(inout c : Component, inout graphics : Graphics, inout icon : Icon, in x : int, in y : int) : void
	icon.paintIcon(c, graphics, x - icon.getIconWidth()/2, y -
		       icon.getIconHeight()/2);
!!!2889499.java!!!	drawDashedHorizontalLine(inout g : Graphics, in y : int, in x1 : int, in x2 : int) : void
	// Drawing only even coordinates helps join line segments so they
	// appear as one line.  This can be defeated by translating the
	// Graphics by an odd amount.
	x1 += (x1 % 2);

	for (int x = x1; x <= x2; x+=2) {
	    g.drawLine(x, y, x, y);
	}
!!!2889627.java!!!	drawDashedVerticalLine(inout g : Graphics, in x : int, in y1 : int, in y2 : int) : void
	// Drawing only even coordinates helps join line segments so they
	// appear as one line.  This can be defeated by translating the
	// Graphics by an odd amount.
	y1 += (y1 % 2);

	for (int y = y1; y <= y2; y+=2) {
	    g.drawLine(x, y, x, y);
	}
!!!2889755.java!!!	getRowX(in row : int, in depth : int) : int
        return totalChildIndent * (depth + depthOffset);
!!!2889883.java!!!	updateLayoutCacheExpandedNodes() : void
	if(treeModel != null && treeModel.getRoot() != null)
	    updateExpandedDescendants(new TreePath(treeModel.getRoot()));
!!!2890011.java!!!	updateExpandedDescendants(inout path : TreePath) : void
	completeEditing();
	if(treeState != null) {
	    treeState.setExpandedState(path, true);

	    Enumeration   descendants = tree.getExpandedDescendants(path);

	    if(descendants != null) {
		while(descendants.hasMoreElements()) {
		    path = (TreePath)descendants.nextElement();
		    treeState.setExpandedState(path, true);
		}
	    }
	    updateLeadRow();
	    updateSize();
	}
!!!2890139.java!!!	getLastChildPath(inout parent : TreePath) : TreePath
	if(treeModel != null) {
	    int         childCount = treeModel.getChildCount
		(parent.getLastPathComponent());
	    
	    if(childCount > 0)
		return parent.pathByAddingChild(treeModel.getChild
			   (parent.getLastPathComponent(), childCount - 1));
	}
	return null;
!!!2890267.java!!!	updateDepthOffset() : void
	if(isRootVisible()) {
	    if(getShowsRootHandles())
		depthOffset = 1;
	    else
		depthOffset = 0;
	}
	else if(!getShowsRootHandles())
	    depthOffset = -1;
	else
	    depthOffset = 0;
!!!2890395.java!!!	updateCellEditor() : void
	TreeCellEditor        newEditor;

	completeEditing();
	if(tree == null)
	    newEditor = null;
	else {
	    if(tree.isEditable()) {
		newEditor = tree.getCellEditor();
		if(newEditor == null) {
		    newEditor = createDefaultCellEditor();
		    if(newEditor != null) {
			tree.setCellEditor(newEditor);
			createdCellEditor = true;
		    }
		}
	    }
	    else
		newEditor = null;
	}
	if(newEditor != cellEditor) {
	    if(cellEditor != null && cellEditorListener != null)
		cellEditor.removeCellEditorListener(cellEditorListener);
	    cellEditor = newEditor;
	    if(cellEditorListener == null)
		cellEditorListener = createCellEditorListener();
	    if(newEditor != null && cellEditorListener != null)
		newEditor.addCellEditorListener(cellEditorListener);
	    createdCellEditor = false;
	}
!!!2890523.java!!!	updateRenderer() : void
	if(tree != null) {
	    TreeCellRenderer      newCellRenderer;

	    newCellRenderer = tree.getCellRenderer();
	    if(newCellRenderer == null) {
		tree.setCellRenderer(createDefaultCellRenderer());
		createdRenderer = true;
	    }
	    else {
		createdRenderer = false;
		currentCellRenderer = newCellRenderer;
		if(createdCellEditor) {
		    tree.setCellEditor(null);
		}
	    }
	}
	else {
	    createdRenderer = false;
	    currentCellRenderer = null;
	}
	updateCellEditor();
!!!2890651.java!!!	configureLayoutCache() : void
	if(treeState != null && tree != null) {
	    if(nodeDimensions == null)
		nodeDimensions = createNodeDimensions();
	    treeState.setNodeDimensions(nodeDimensions);
	    treeState.setRootVisible(tree.isRootVisible());
	    treeState.setRowHeight(tree.getRowHeight());
	    treeState.setSelectionModel(getSelectionModel());
	    // Only do this if necessary, may loss state if call with
	    // same model as it currently has.
	    if(treeState.getModel() != tree.getModel())
		treeState.setModel(tree.getModel());
	    updateLayoutCacheExpandedNodes();
	    // Create a listener to update preferred size when bounds
	    // changes, if necessary.
	    if(isLargeModel()) {
		if(componentListener == null) {
		    componentListener = createComponentListener();
		    if(componentListener != null)
			tree.addComponentListener(componentListener);
		}
	    }
	    else if(componentListener != null) {
		tree.removeComponentListener(componentListener);
		componentListener = null;
	    }
	}
	else if(componentListener != null) {
	    tree.removeComponentListener(componentListener);
	    componentListener = null;
	}
!!!2890779.java!!!	updateSize() : void
	validCachedPreferredSize = false;
	tree.treeDidChange();
!!!2890907.java!!!	updateCachedPreferredSize() : void
	if(treeState != null) {
	    Insets               i = tree.getInsets();

	    if(isLargeModel()) {
		Rectangle            visRect = tree.getVisibleRect();

		if(i != null) {
		    visRect.x -= i.left;
		    visRect.y -= i.top;
		}
		if (leftToRight) {
		    preferredSize.width = treeState.getPreferredWidth(visRect);
		}
		else {
		    if (getRowCount(tree) == 0) {
			preferredSize.width = 0;
		    }
		    else {
			preferredSize.width = lastWidth - getMinX(visRect);
		    }
		}
	    }
	    else if (leftToRight) {
		preferredSize.width = treeState.getPreferredWidth(null);
	    }
	    else {
		Rectangle tempRect = null;
		int rowCount = tree.getRowCount();
		int width = 0;
		for (int counter = 0; counter < rowCount; counter++) {
		    tempRect = treeState.getBounds
			       (treeState.getPathForRow(counter), tempRect);
		    if (tempRect != null) {
			width = Math.max(lastWidth - tempRect.x, width);
		    }
		}
		preferredSize.width = width;
	    }
	    preferredSize.height = treeState.getPreferredHeight();
	    if(i != null) {
		preferredSize.width += i.left + i.right;
		preferredSize.height += i.top + i.bottom;
	    }
	}
	validCachedPreferredSize = true;
!!!2891035.java!!!	getMinX(inout bounds : Rectangle) : int
	TreePath      firstPath;
	int           endY;

	if(bounds == null) {
	    firstPath = getPathForRow(tree, 0);
	    endY = Integer.MAX_VALUE;
	}
	else {
	    firstPath = treeState.getPathClosestTo(bounds.x, bounds.y);
	    endY = bounds.height + bounds.y;
	}

	Enumeration   paths = treeState.getVisiblePathsFrom(firstPath);
	int           minX = 0;

	if(paths != null && paths.hasMoreElements()) {
	    Rectangle   pBounds = treeState.getBounds
		                  ((TreePath)paths.nextElement(), null);
	    int         width;

	    if(pBounds != null) {
		minX = pBounds.x + pBounds.width;
		if (pBounds.y >= endY) {
		    return minX;
		}
	    }
	    while (pBounds != null && paths.hasMoreElements()) {
		pBounds = treeState.getBounds((TreePath)paths.nextElement(),
					      pBounds);
		if (pBounds != null && pBounds.y < endY) {
		    minX = Math.min(minX, pBounds.x);
		}
		else {
		    pBounds = null;
		}
	    }
	    return minX;
	}
	return minX;
!!!2891163.java!!!	pathWasExpanded(inout path : TreePath) : void
	if(tree != null) {
	    tree.fireTreeExpanded(path);
	}
!!!2891291.java!!!	pathWasCollapsed(inout path : TreePath) : void
	if(tree != null) {
	    tree.fireTreeCollapsed(path);
	}
!!!2891419.java!!!	ensureRowsAreVisible(in beginRow : int, in endRow : int) : void
	if(tree != null && beginRow >= 0 && endRow < getRowCount(tree)) {
            boolean scrollVert = DefaultLookup.getBoolean(tree, this,
                              "Tree.scrollsHorizontallyAndVertically", false);
	    if(beginRow == endRow) {
		Rectangle     scrollBounds = getPathBounds(tree, getPathForRow
							   (tree, beginRow));

		if(scrollBounds != null) {
                    if (!scrollVert) {
                        scrollBounds.x = tree.getVisibleRect().x;
                        scrollBounds.width = 1;
                    }
		    tree.scrollRectToVisible(scrollBounds);
		}
	    }
	    else {
		Rectangle   beginRect = getPathBounds(tree, getPathForRow
						      (tree, beginRow));
		Rectangle   visRect = tree.getVisibleRect();
		Rectangle   testRect = beginRect;
		int         beginY = beginRect.y;
		int         maxY = beginY + visRect.height;

		for(int counter = beginRow + 1; counter <= endRow; counter++) {
		    testRect = getPathBounds(tree,
					     getPathForRow(tree, counter));
		    if((testRect.y + testRect.height) > maxY)
			counter = endRow;
		}
		tree.scrollRectToVisible(new Rectangle(visRect.x, beginY, 1,
						  testRect.y + testRect.height-
						  beginY));
	    }
	}
!!!2891547.java!!!	setPreferredMinSize(inout newSize : Dimension) : void
	preferredMinSize = newSize;
!!!2891675.java!!!	getPreferredMinSize() : Dimension
	if(preferredMinSize == null)
	    return null;
	return new Dimension(preferredMinSize);
!!!2891803.java!!!	getPreferredSize(inout c : JComponent) : Dimension
	return getPreferredSize(c, true);
!!!2891931.java!!!	getPreferredSize(inout c : JComponent, inout checkConsistancy : boolean) : Dimension
	Dimension       pSize = this.getPreferredMinSize();

	if(!validCachedPreferredSize)
	    updateCachedPreferredSize();
	if(tree != null) {
	    if(pSize != null)
		return new Dimension(Math.max(pSize.width,
					      preferredSize.width),
			      Math.max(pSize.height, preferredSize.height));
	    return new Dimension(preferredSize.width, preferredSize.height);
	}
	else if(pSize != null)
	    return pSize;
	else
	    return new Dimension(0, 0);
!!!2892059.java!!!	getMinimumSize(inout c : JComponent) : Dimension
	if(this.getPreferredMinSize() != null)
	    return this.getPreferredMinSize();
	return new Dimension(0, 0);
!!!2892187.java!!!	getMaximumSize(inout c : JComponent) : Dimension
	if(tree != null)
	    return getPreferredSize(tree);
	if(this.getPreferredMinSize() != null)
	    return this.getPreferredMinSize();
	return new Dimension(0, 0);
!!!2892315.java!!!	completeEditing() : void
	/* If should invoke stopCellEditing, try that */
	if(tree.getInvokesStopCellEditing() &&
	   stopEditingInCompleteEditing && editingComponent != null) {
	    cellEditor.stopCellEditing();
	}
	/* Invoke cancelCellEditing, this will do nothing if stopCellEditing
	   was successful. */
	completeEditing(false, true, false);
!!!2892443.java!!!	completeEditing(inout messageStop : boolean, inout messageCancel : boolean, inout messageTree : boolean) : void
	if(stopEditingInCompleteEditing && editingComponent != null) {
	    Component             oldComponent = editingComponent;
	    TreePath              oldPath = editingPath;
	    TreeCellEditor        oldEditor = cellEditor;
	    Object                newValue = oldEditor.getCellEditorValue();
	    Rectangle             editingBounds = getPathBounds(tree, 
								editingPath);
	    boolean               requestFocus = (tree != null &&
		                   (tree.hasFocus() || SwingUtilities.
				    findFocusOwner(editingComponent) != null));

	    editingComponent = null;
	    editingPath = null;
	    if(messageStop)
		oldEditor.stopCellEditing();
	    else if(messageCancel)
		oldEditor.cancelCellEditing();
	    tree.remove(oldComponent);
	    if(editorHasDifferentSize) {
		treeState.invalidatePathBounds(oldPath);
		updateSize();
	    }
	    else {
		editingBounds.x = 0;
		editingBounds.width = tree.getSize().width;
		tree.repaint(editingBounds);
	    }
	    if(requestFocus)
		tree.requestFocus();
	    if(messageTree)
		treeModel.valueForPathChanged(oldPath, newValue);
	}
!!!2892571.java!!!	startEditingOnRelease(inout path : TreePath, inout event : MouseEvent, inout releaseEvent : MouseEvent) : boolean
        this.releaseEvent = releaseEvent;
        try {
            return startEditing(path, event);
        } finally {
            this.releaseEvent = null;
        }
!!!2892699.java!!!	startEditing(inout path : TreePath, inout event : MouseEvent) : boolean
        if (isEditing(tree) && tree.getInvokesStopCellEditing() &&
                               !stopEditing(tree)) {
            return false;
        }
	completeEditing();
	if(cellEditor != null && tree.isPathEditable(path)) {
	    int           row = getRowForPath(tree, path);

	    if(cellEditor.isCellEditable(event)) {
                editingComponent = cellEditor.getTreeCellEditorComponent
		      (tree, path.getLastPathComponent(),
		       tree.isPathSelected(path), tree.isExpanded(path),
		       treeModel.isLeaf(path.getLastPathComponent()), row);

		Rectangle           nodeBounds = getPathBounds(tree, path);

		editingRow = row;

		Dimension editorSize = editingComponent.getPreferredSize();

		// Only allow odd heights if explicitly set.
		if(editorSize.height != nodeBounds.height &&
		   getRowHeight() > 0)
		    editorSize.height = getRowHeight();

		if(editorSize.width != nodeBounds.width ||
		   editorSize.height != nodeBounds.height) {
		    // Editor wants different width or height, invalidate 
		    // treeState and relayout.
		    editorHasDifferentSize = true;
		    treeState.invalidatePathBounds(path);
		    updateSize();
		}
		else
		    editorHasDifferentSize = false;
		tree.add(editingComponent);
		editingComponent.setBounds(nodeBounds.x, nodeBounds.y,
					   editorSize.width,
					   editorSize.height);
		editingPath = path;
		editingComponent.validate();

		Rectangle              visRect = tree.getVisibleRect();

		tree.paintImmediately(nodeBounds.x, nodeBounds.y,
				      visRect.width + visRect.x - nodeBounds.x,
				      editorSize.height);
		if(cellEditor.shouldSelectCell(event)) {
		    stopEditingInCompleteEditing = false;
		    try {
			tree.setSelectionRow(row);
		    } catch (Exception e) {
			System.err.println("Editing exception: " + e);
		    }
		    stopEditingInCompleteEditing = true;
		}

		Component focusedComponent = BasicLookAndFeel.
		                 compositeRequestFocus(editingComponent);
		boolean selectAll = true;

		if(event != null && event instanceof MouseEvent) {
		    /* Find the component that will get forwarded all the
		       mouse events until mouseReleased. */
		    Point          componentPoint = SwingUtilities.convertPoint
			(tree, new Point(event.getX(), event.getY()),
			 editingComponent);

		    /* Create an instance of BasicTreeMouseListener to handle
		       passing the mouse/motion events to the necessary
		       component. */
		    // We really want similar behavior to getMouseEventTarget,
		    // but it is package private.
		    Component activeComponent = SwingUtilities.
			            getDeepestComponentAt(editingComponent,
				       componentPoint.x, componentPoint.y);
		    if (activeComponent != null) {
                        MouseInputHandler handler =
                            new MouseInputHandler(tree, activeComponent,
                                                  event, focusedComponent);

                        if (releaseEvent != null) {
                            handler.mouseReleased(releaseEvent);
                        }

                        selectAll = false;
		    }
		}
		if (selectAll && focusedComponent instanceof JTextField) {
		    ((JTextField)focusedComponent).selectAll();
		}
		return true;
	    }
	    else
		editingComponent = null;
	}
	return false;
!!!2892827.java!!!	checkForClickInExpandControl(inout path : TreePath, in mouseX : int, in mouseY : int) : void
      if (isLocationInExpandControl(path, mouseX, mouseY)) {
	  handleExpandControlClick(path, mouseX, mouseY);
	}
!!!2892955.java!!!	isLocationInExpandControl(inout path : TreePath, in mouseX : int, in mouseY : int) : boolean
	if(path != null && !treeModel.isLeaf(path.getLastPathComponent())){
	    int                     boxWidth;
	    Insets                  i = tree.getInsets();

	    if(getExpandedIcon() != null)
		boxWidth = getExpandedIcon().getIconWidth();
	    else
		boxWidth = 8;

	    int boxLeftX = getRowX(tree.getRowForPath(path),
                   path.getPathCount() - 1) - getRightChildIndent() -
                   boxWidth / 2;

	    if (leftToRight) {
                boxLeftX += i.left;
	    }
	    else {
	        boxLeftX = i.left + lastWidth - 1 - 
		            ((path.getPathCount() - 2 + depthOffset) *
			     totalChildIndent) - getLeftChildIndent() -
		            boxWidth / 2;
	    }
	    int boxRightX = boxLeftX + boxWidth;

	    return mouseX >= boxLeftX && mouseX <= boxRightX;
	}
	return false;
!!!2893083.java!!!	handleExpandControlClick(inout path : TreePath, in mouseX : int, in mouseY : int) : void
	toggleExpandState(path);
!!!2893211.java!!!	toggleExpandState(inout path : TreePath) : void
	if(!tree.isExpanded(path)) {
	    int       row = getRowForPath(tree, path);

	    tree.expandPath(path);
	    updateSize();
	    if(row != -1) {
		if(tree.getScrollsOnExpand())
		    ensureRowsAreVisible(row, row + treeState.
					 getVisibleChildCount(path));
		else
		    ensureRowsAreVisible(row, row);
	    }
	}
	else {
	    tree.collapsePath(path);
	    updateSize();
	}
!!!2893339.java!!!	isToggleSelectionEvent(inout event : MouseEvent) : boolean
	return (SwingUtilities.isLeftMouseButton(event) &&
		event.isControlDown());
!!!2893467.java!!!	isMultiSelectEvent(inout event : MouseEvent) : boolean
	return (SwingUtilities.isLeftMouseButton(event) &&
		event.isShiftDown());
!!!2893595.java!!!	isToggleEvent(inout event : MouseEvent) : boolean
	if(!SwingUtilities.isLeftMouseButton(event)) {
	    return false;
	}
	int           clickCount = tree.getToggleClickCount();

	if(clickCount <= 0) {
	    return false;
	}
	return ((event.getClickCount() % clickCount) == 0);
!!!2893723.java!!!	selectPathForEvent(inout path : TreePath, inout event : MouseEvent) : void
	/* Adjust from the anchor point. */
	if(isMultiSelectEvent(event)) {
	    TreePath    anchor = getAnchorSelectionPath();
	    int         anchorRow = (anchor == null) ? -1 :
		                    getRowForPath(tree, anchor);

	    if(anchorRow == -1 || tree.getSelectionModel().
                      getSelectionMode() == TreeSelectionModel.
                      SINGLE_TREE_SELECTION) {
		tree.setSelectionPath(path);
	    }
	    else {
		int          row = getRowForPath(tree, path);
		TreePath     lastAnchorPath = anchor;

                if (isToggleSelectionEvent(event)) {
                    if (tree.isRowSelected(anchorRow)) {
                        tree.addSelectionInterval(anchorRow, row);
                    } else {
                        tree.removeSelectionInterval(anchorRow, row);
                        tree.addSelectionInterval(row, row);
                    }
                } else if(row < anchorRow) {
		    tree.setSelectionInterval(row, anchorRow);
                } else {
		    tree.setSelectionInterval(anchorRow, row);
                }
		lastSelectedRow = row;
		setAnchorSelectionPath(lastAnchorPath);
		setLeadSelectionPath(path);
	    }
	}

        // Should this event toggle the selection of this row?
        /* Control toggles just this node. */
        else if(isToggleSelectionEvent(event)) {
            if(tree.isPathSelected(path))
                tree.removeSelectionPath(path);
            else
                tree.addSelectionPath(path);
            lastSelectedRow = getRowForPath(tree, path);
            setAnchorSelectionPath(path);
            setLeadSelectionPath(path);
        }

	/* Otherwise set the selection to just this interval. */
	else if(SwingUtilities.isLeftMouseButton(event)) {
	    tree.setSelectionPath(path);
	    if(isToggleEvent(event)) {
		toggleExpandState(path);
	    }
	}
!!!2893851.java!!!	isLeaf(in row : int) : boolean
	TreePath          path = getPathForRow(tree, row);

	if(path != null)
	    return treeModel.isLeaf(path.getLastPathComponent());
	// Have to return something here...
	return true;
!!!2893979.java!!!	setAnchorSelectionPath(inout newPath : TreePath) : void
	ignoreLAChange = true;
	try {
	    tree.setAnchorSelectionPath(newPath);
	} finally{ 
	    ignoreLAChange = false;
	}
!!!2894107.java!!!	getAnchorSelectionPath() : TreePath
	return tree.getAnchorSelectionPath();
!!!2894235.java!!!	setLeadSelectionPath(inout newPath : TreePath) : void
	setLeadSelectionPath(newPath, false);
!!!2894363.java!!!	setLeadSelectionPath(inout newPath : TreePath, inout repaint : boolean) : void
	Rectangle       bounds = repaint ?
	                    getPathBounds(tree, getLeadSelectionPath()) : null;

	ignoreLAChange = true;
	try {
	    tree.setLeadSelectionPath(newPath);
	} finally {
	    ignoreLAChange = false;
	}
	leadRow = getRowForPath(tree, newPath);

	if(repaint) {
	    if(bounds != null)
		tree.repaint(bounds);
	    bounds = getPathBounds(tree, newPath);
	    if(bounds != null)
		tree.repaint(bounds);
	}
!!!2894491.java!!!	getLeadSelectionPath() : TreePath
	return tree.getLeadSelectionPath();
!!!2894619.java!!!	updateLeadRow() : void
	leadRow = getRowForPath(tree, getLeadSelectionPath());
!!!2894747.java!!!	getLeadSelectionRow() : int
	return leadRow;
!!!2894875.java!!!	extendSelection(inout newLead : TreePath) : void
	TreePath           aPath = getAnchorSelectionPath();
	int                aRow = (aPath == null) ? -1 :
			          getRowForPath(tree, aPath);
	int                newIndex = getRowForPath(tree, newLead);

	if(aRow == -1) {
	    tree.setSelectionRow(newIndex);
	}
	else {
	    if(aRow < newIndex) {
		tree.setSelectionInterval(aRow, newIndex);
	    }
	    else {
		tree.setSelectionInterval(newIndex, aRow);
	    }
	    setAnchorSelectionPath(aPath);
	    setLeadSelectionPath(newLead);
	}
!!!2895003.java!!!	repaintPath(inout path : TreePath) : void
	if (path != null) {
	    Rectangle bounds = getPathBounds(tree, path);
	    if (bounds != null) {
		tree.repaint(bounds.x, bounds.y, bounds.width, bounds.height);
	    }
	}
