class RunnableCanvas
!!!9296539.java!!!	RunnableCanvas(inout rootPane : JRootPane)
	     super();
	     setBounds(0, 0, 1, 1);

	     /* Remember the mapping from the current thread (and the current
	      * thread group) to this RunnableCanvas.  Note that if a mapping
	      * has already been defined, e.g. this rootPane belongs to an
	      * existing applet, then leave the table alone.  We're assuming that
	      * an applets addNotify method will always run before the addNotify
	      * method in any subsidiary windows the applet creates can run.
	      */
	     if (runnableCanvasTable.get(Thread.currentThread()) == null) {
		 try {
		     runnableCanvasTable.put(Thread.currentThread(), this);
		     runnableCanvasTable.put(getThreadGroupSafely(), this);
		     if (SwingUtilities.isEventDispatchThread()) {
			 isRegistered = true;
		     }
		 }
		 catch(Exception e) {
		     System.err.println("Can't register RunnableCanvas");
		     e.printStackTrace();
		 }
	     }
	     runnableCanvasTable.put(rootPane, this);
	     maybeRegisterEventDispatchThread();
!!!9296667.java!!!	maybeRegisterEventDispatchThread() : void
	     /* Avoid the cost of a synchronized block (or method) in the
	      * common case, since this method is called each time paint is called.
	      */
	     if (!isRegistered) {
		 synchronized(this) {
		     if (!isRegistered && SwingUtilities.isEventDispatchThread()) {
			 Thread currentThread = Thread.currentThread();

			 /* If this event dispatching thread is already mapped to
			  * a runnableCanvas then don't replace the mapping (which
			  * we expect to be generated by the applet).
			  */
			 if (runnableCanvasTable.get(currentThread) != null) {
			     isRegistered = true;
			 }
			 else {
			     runnableCanvasTable.put(currentThread, this);
			     runnableCanvasTable.put(getThreadGroupSafely(), this);
			     isRegistered = true;
			 }
		     }
		 }
	     }
!!!9296795.java!!!	lookup(inout e : RunnableEvent) : RunnableCanvas
	     /* If this is a ComponentWorkRequest, find the components
	      * JRootPane ancestor and use that as the index into the
	      * runnableCanvasTable.  This case occurs when any thread,
	      * other than the event dispatching thead, calls repaint
	      */
	     if (e.doRun instanceof ComponentWorkRequest) {
		 ComponentWorkRequest req = (ComponentWorkRequest)e.doRun;
		 synchronized(req) {
		     JRootPane rootPane = SwingUtilities.getRootPane(req.component);
		     if(rootPane != null) {
			 return (RunnableCanvas)(runnableCanvasTable.get(rootPane));
		     }
		     /* Failure.  There doesn't appear to be a RunnableCanvas to use
		      * so indicate that a new request will need to be queued, see
		      * RepaintManager.queueWorkRequest().
		      */
		     req.isPending = false;
		     return null;
		 }
	     }

	     /* If the current thread is in the runnableCanvasTable
	      * (e.g. we're on the event dispatching thread) we're done.
	      */
	     Object rv = runnableCanvasTable.get(Thread.currentThread());
	     if (rv != null) {
		 return (RunnableCanvas)rv;
	     }

	     /* At this point we're assuming that the calling thread isn't
	      * a system thread (like an image observer thread), so it's safe 
	      * to lookup via the current threads ThreadGroup.
	      */
	     Object threadGroup;
	     try {
		 threadGroup = Thread.currentThread().getThreadGroup();
	     }
	     catch (SecurityException exc) {
		 return null;
	     }
	     RunnableCanvas rc = (RunnableCanvas)runnableCanvasTable.get(threadGroup);
	     
	     /* There's no RunnableCanvas associated with this thread group
	      * (so punt).  Return the first visible RunnableCanvas.
	      */
	     if(rc == null) {
		 Enumeration keys = runnableCanvasTable.keys();
		 if(keys == null) {
		     return null;
		 }
		 while(keys.hasMoreElements()) {
		     Object key = keys.nextElement();
		     if ((key instanceof JRootPane) && ((JRootPane)key).isShowing()) {
			 return (RunnableCanvas)runnableCanvasTable.get(key);
		     }
		 }
	     }

	     return rc;
!!!9296923.java!!!	postRunnableEventToAll(inout e : RunnableEvent) : void
	     // Determine the RunnableCanvas for the current thread. It
	     // may be null.
	     RunnableCanvas currentThreadCanvas;
	     ThreadGroup tg;
	     try {
		 tg = new Thread().getThreadGroup();
	     }
	     catch (SecurityException se) {
		 tg = null;
	     }
	     if(tg != null) {
		 currentThreadCanvas = (RunnableCanvas)runnableCanvasTable.
		                        get(tg);
	     }
	     else
		 currentThreadCanvas = null;

	     // Add the event to all canvases, except the current one.
	     // Presumably the current one is no longer valid and will be
	     // going away shortly.
	     Enumeration keys = runnableCanvasTable.keys();
	     while(keys.hasMoreElements()) {
		 Object key = keys.nextElement();
		 if(key instanceof JRootPane) {
		     Object canvas = runnableCanvasTable.get(key);
		     if(canvas != currentThreadCanvas) {
			 RunnableCanvas rc = (RunnableCanvas)canvas;
			 rc.addRunnableEvent(e);
			 rc.repaint();
		     }
		 }
	     }
!!!9297051.java!!!	remove(inout rootPane : JRootPane) : void
	     RunnableCanvas rc = (RunnableCanvas)(runnableCanvasTable.get(rootPane));
	     if (rc != null) {
		 RunnableCanvas nextCanvas = null;
		 JLayeredPane layeredPane = rootPane.getLayeredPane();
		 layeredPane.remove((Component)rc);

		 Enumeration keys = runnableCanvasTable.keys();
		 while(keys.hasMoreElements()) {
		     Object key = keys.nextElement();
		     Object next = runnableCanvasTable.get(key);
		     if (rc == next) {
			 runnableCanvasTable.remove(key);
		     }
		     else if(nextCanvas == null) {
			 nextCanvas = (RunnableCanvas)next;
		     }
		 }

		 // If there are still events, either move them to another
		 // canvas, or mark the Timer type events as not having
		 // fired.
		 RunnableEvent[] events = rc.getRunnableCanvasEvents();
		 int numEvents = (events == null) ? 0 : events.length;
		 if(numEvents > 0) {
		     if(nextCanvas != null) {
			 for(int counter = 0; counter < numEvents; counter++) {
			     RunnableEvent e = events[counter];
			     if(e.doRun instanceof Timer.DoPostEvent)
				 nextCanvas.addRunnableEvent(e);
			 }
			 nextCanvas.repaint();
		     }
		     else {
			 // Mark all Timer type event as not having fired.
			 for(int counter = 0; counter < numEvents; counter++) {
			     RunnableEvent event = events[counter];
			     if(event.doRun instanceof Timer.DoPostEvent) {
				 ((Timer.DoPostEvent)event.doRun).getTimer().
				                     cancelEvent();
			     }
			 }
		     }
		 }
	     }
!!!9297179.java!!!	isShowing() : boolean
	     return runnableEvents.size() > 0;
!!!9297307.java!!!	getGraphics() : Graphics
	     return nullGraphics;
!!!9297435.java!!!	getPreferredSize() : Dimension
	     return new Dimension(1, 1);
!!!9297563.java!!!	addRunnableEvent(inout e : RunnableEvent) : void
	     runnableEvents.addElement(e);
!!!9297691.java!!!	getRunnableCanvasEvents() : RunnableEvent
	     int n = runnableEvents.size();
	     if (n == 0) {
		 return null;
	     }
	     else {
		 RunnableEvent[] rv = new RunnableEvent[n];
		 for(int i = 0; i < n; i++) {
		     rv[i] = (RunnableEvent)(runnableEvents.elementAt(i));
		 }
		 runnableEvents.removeAllElements();
		 return rv;
	     }
!!!9297819.java!!!	paint(inout g : Graphics) : void
	     maybeRegisterEventDispatchThread();
!!!9297947.java!!!	update(inout g : Graphics) : void
	     RunnableEvent[] events = getRunnableCanvasEvents();
	     if (events != null) {
		 for(int i = 0; i < events.length; i++) {
		     processRunnableEvent(events[i]);
		 }
	     }
