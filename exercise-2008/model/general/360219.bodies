class JComponent
!!!2189083.java!!!	getManagingFocusForwardTraversalKeys() : Set
        if (managingFocusForwardTraversalKeys == null) {
            managingFocusForwardTraversalKeys = new TreeSet();
            managingFocusForwardTraversalKeys.add(
                KeyStroke.getKeyStroke(KeyEvent.VK_TAB, InputEvent.CTRL_MASK));
        }
        return managingFocusForwardTraversalKeys;
!!!2189211.java!!!	getManagingFocusBackwardTraversalKeys() : Set
        if (managingFocusBackwardTraversalKeys == null) {
            managingFocusBackwardTraversalKeys = new TreeSet();
            managingFocusBackwardTraversalKeys.add(
                KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
                                       InputEvent.SHIFT_MASK |
                                       InputEvent.CTRL_MASK));
        }
        return managingFocusBackwardTraversalKeys;
!!!2189339.java!!!	getSuppressDropTarget() : boolean
        if (!checkedSuppressDropSupport) {
            Boolean b = (Boolean)java.security.AccessController.doPrivileged(
                new java.security.PrivilegedAction() {
                    public Object run() {
                        String value = System.getProperty(
                                              "suppressSwingDropSupport");

                        if (value != null) {
                            return Boolean.valueOf(value);
                        }
                        return Boolean.FALSE;
                    }
                }
                );
            suppressDropSupport = b.booleanValue();
            checkedSuppressDropSupport = true;
        }
        return suppressDropSupport;
!!!2189467.java!!!	fetchRectangle() : Rectangle
        synchronized(tempRectangles) {
            Rectangle rect;
            int size = tempRectangles.size();
            if (size > 0) {
                rect = (Rectangle)tempRectangles.remove(size - 1);
            }
            else {
                rect = new Rectangle(0, 0, 0, 0);
            }
            return rect;
        }
!!!2189595.java!!!	recycleRectangle(inout rect : Rectangle) : void
        synchronized(tempRectangles) {
            tempRectangles.add(rect);
        }
!!!2189723.java!!!	setInheritsPopupMenu(inout value : boolean) : void
        setFlag(INHERITS_POPUP_MENU, value);
!!!2189851.java!!!	getInheritsPopupMenu() : boolean
        return getFlag(INHERITS_POPUP_MENU);
!!!2189979.java!!!	setComponentPopupMenu(inout popup : JPopupMenu) : void
        if(popup != null && isLightweight()) {
            enableEvents(AWTEvent.MOUSE_EVENT_MASK);
        }
        this.popupMenu = popup;
!!!2190107.java!!!	getComponentPopupMenu() : JPopupMenu

        if(!getInheritsPopupMenu()) {
            return popupMenu;
        }

        if(popupMenu == null) {
            // Search parents for its popup
            Container parent = getParent();
            while (parent != null) {
                if(parent instanceof JComponent) {
                    return ((JComponent)parent).getComponentPopupMenu();
                }
                if(parent instanceof Window ||
                   parent instanceof Applet) {
                    // Reached toplevel, break and return null
                    break;
                }
                parent = parent.getParent();
            }
            return null;
        }

        return popupMenu;
!!!2190235.java!!!	JComponent()
        super();
	// We enable key events on all JComponents so that accessibility
	// bindings will work everywhere. This is a partial fix to BugID
	// 4282211.
        enableEvents(AWTEvent.KEY_EVENT_MASK);
	if (isManagingFocus()) {
            LookAndFeel.installProperty(this,
                                        "focusTraversalKeysForward", 
				  getManagingFocusForwardTraversalKeys());
            LookAndFeel.installProperty(this,
                                        "focusTraversalKeysBackward", 
				  getManagingFocusBackwardTraversalKeys());
	}

        super.setLocale( JComponent.getDefaultLocale() );
!!!2190491.java!!!	setUI(inout newUI : ComponentUI) : void
        /* We do not check that the UI instance is different
         * before allowing the switch in order to enable the
         * same UI instance *with different default settings*
         * to be installed.
         */
        if (ui != null) {
            ui.uninstallUI(this);
        }
        // aaText shouldn't persist between look and feels, reset it.
        aaText = false;
        ComponentUI oldUI = ui;
        ui = newUI;
        if (ui != null) {
            ui.installUI(this);
        }

        firePropertyChange("UI", oldUI, newUI);
        revalidate();
        repaint();
!!!2190619.java!!!	getUIClassID() : String
        return uiClassID;
!!!2190747.java!!!	getComponentGraphics(inout g : Graphics) : Graphics
        Graphics componentGraphics = g;
        if (ui != null && DEBUG_GRAPHICS_LOADED) {
            if ((DebugGraphics.debugComponentCount() != 0) &&
                    (shouldDebugGraphics() != 0) &&
                    !(g instanceof DebugGraphics)) {
                componentGraphics = new DebugGraphics(g,this);
            }
        }
        componentGraphics.setColor(getForeground());
        componentGraphics.setFont(getFont());

        return componentGraphics;
!!!2190875.java!!!	paintComponent(inout g : Graphics) : void
        if (ui != null) {
            Graphics scratchGraphics = (g == null) ? null : g.create();
            try {
                ui.update(scratchGraphics, this);
            }
            finally {
                scratchGraphics.dispose();
            }
        }
!!!2191003.java!!!	paintChildren(inout g : Graphics) : void
        boolean isJComponent;
	Graphics sg = null;

        try {
            synchronized(getTreeLock()) {
		int i = getComponentCount() - 1;
		if (i < 0) {
		    return;
		}
		sg = (g == null) ? null : g.create();
		// If we are only to paint to a specific child, determine
		// its index.
		if (paintingChild != null &&
		    (paintingChild instanceof JComponent) &&
		    ((JComponent)paintingChild).isOpaque()) {
		    for (; i >= 0; i--) {
			if (getComponent(i) == paintingChild){
			    break;
			}
		    }
		}
                Rectangle tmpRect = fetchRectangle();
		boolean checkSiblings = (!isOptimizedDrawingEnabled() &&
					 checkIfChildObscuredBySibling());
		Rectangle clipBounds = null;
                if (checkSiblings) {
		    clipBounds = sg.getClipBounds();
		    if (clipBounds == null) {
		        clipBounds = new Rectangle(0, 0, getWidth(),
                                                   getHeight());
		    }
                }
		boolean printing = getFlag(IS_PRINTING);
                for (; i >= 0 ; i--) {
                    Component comp = getComponent(i);
                    if (comp != null &&
                        (printing || isLightweightComponent(comp)) && 
                        (comp.isVisible() == true)) {
                        Rectangle cr;
                        isJComponent = (comp instanceof JComponent);

                        cr = comp.getBounds(tmpRect);

			boolean hitClip = g.hitClip(cr.x, cr.y, cr.width, cr.height);

                        if (hitClip) {
			    if (checkSiblings && i > 0) {
				int x = cr.x;
				int y = cr.y;
				int width = cr.width;
				int height = cr.height;
				SwingUtilities.computeIntersection
				     (clipBounds.x, clipBounds.y,
				      clipBounds.width, clipBounds.height, cr);

				if(getObscuredState(i, cr.x, cr.y, cr.width,
                                         cr.height) == COMPLETELY_OBSCURED) {
				    continue;
				}
				cr.x = x;
				cr.y = y;
				cr.width = width;
				cr.height = height;
			    }
                            Graphics cg = sg.create(cr.x, cr.y, cr.width,
                                                    cr.height);
			    cg.setColor(comp.getForeground());
			    cg.setFont(comp.getFont());
                            boolean shouldSetFlagBack = false;
                            try {
                                if(isJComponent) {
                                    if(getFlag(ANCESTOR_USING_BUFFER)) {
                                        ((JComponent)comp).setFlag(ANCESTOR_USING_BUFFER,true);
                                        shouldSetFlagBack = true;
                                    }
                                    if(getFlag(IS_PAINTING_TILE)) {
                                        ((JComponent)comp).setFlag(IS_PAINTING_TILE,true);
                                        shouldSetFlagBack = true;
                                    }
				    if(!printing) {
					((JComponent)comp).paint(cg);
				    }
				    else {
					if (!getFlag(IS_PRINTING_ALL)) {
					    comp.print(cg);
					}
					else {
					    comp.printAll(cg);
					}
				    }
                                } else {
				    if (!printing) {
					comp.paint(cg);
				    }
				    else {
					if (!getFlag(IS_PRINTING_ALL)) {
					    comp.print(cg);
					}
					else {
					    comp.printAll(cg);
					}
				    }
			    }
                            } finally {
                                cg.dispose();
                                if(shouldSetFlagBack) {
                                    ((JComponent)comp).setFlag(ANCESTOR_USING_BUFFER,false);
                                    ((JComponent)comp).setFlag(IS_PAINTING_TILE,false);
                                }
                            }
                        }
                    }

                }
                recycleRectangle(tmpRect);
            }
        } finally {
	    if (sg != null) {
		sg.dispose();
	    }
        }
!!!2191131.java!!!	paintBorder(inout g : Graphics) : void
        Border border = getBorder();
        if (border != null) {
            border.paintBorder(this, g, 0, 0, getWidth(), getHeight());
        }
!!!2191259.java!!!	update(inout g : Graphics) : void
        paint(g);
!!!2191387.java!!!	paint(inout g : Graphics) : void
	boolean shouldClearPaintFlags = false;
	boolean paintCompleted = false;

        if ((getWidth() <= 0) || (getHeight() <= 0)) {
            return;
        }

        Graphics componentGraphics = getComponentGraphics(g);
        Graphics co = (componentGraphics == null) ? null :
                      componentGraphics.create();
        try {
            RepaintManager repaintManager = RepaintManager.currentManager(this);
	    Rectangle clipRect = co.getClipBounds();
            int clipX;
            int clipY;
            int clipW;
            int clipH;
	    if (clipRect == null) {
                clipX = clipY = 0;
		clipW = getWidth();
		clipH = getHeight();
            }
	    else {
	        clipX = clipRect.x;
		clipY = clipRect.y;
		clipW = clipRect.width;
		clipH = clipRect.height;
            }

            if(clipW > getWidth()) {
                clipW = getWidth();
            }
            if(clipH > getHeight()) {
                clipH = getHeight();
            }

            if(getParent() != null && !(getParent() instanceof JComponent)) {
                adjustPaintFlags();
                shouldClearPaintFlags = true;
            }

	    int bw,bh;
	    boolean printing = getFlag(IS_PRINTING);
            if(!printing && repaintManager.isDoubleBufferingEnabled() &&
               !getFlag(ANCESTOR_USING_BUFFER) && isDoubleBuffered()) {

		paintCompleted = paintDoubleBuffered(this, this, co, clipX, clipY, clipW, clipH);
            } 
	    if (!paintCompleted) {
		// Will ocassionaly happen in 1.2, especially when printing.
		if (clipRect == null) {
		    co.setClip(clipX, clipY, clipW, clipH);
		}

                if (!rectangleIsObscured(clipX,clipY,clipW,clipH)) {
		    if (!printing) {
			paintComponent(co);
			paintBorder(co);
		    }
		    else {
			printComponent(co);
			printBorder(co);
		    }
                }
		if (!printing) {
		    paintChildren(co);
		}
		else {
		    printChildren(co);
		}
            }
        } finally {
            co.dispose();
            if(shouldClearPaintFlags) {
                setFlag(ANCESTOR_USING_BUFFER,false);
                setFlag(IS_PAINTING_TILE,false);
                setFlag(IS_PRINTING,false);
                setFlag(IS_PRINTING_ALL,false);
            }
        }
!!!2191515.java!!!	isPainting() : boolean
        Container component = this;
        while (component != null) {
            if (component instanceof JComponent &&
                   ((JComponent)component).getFlag(ANCESTOR_USING_BUFFER)) {
                return true;
            }
            component = component.getParent();
        }
        return false;
!!!2191643.java!!!	adjustPaintFlags() : void
	JComponent jparent = null;
	Container parent;
	for(parent = getParent() ; parent != null ; parent =
	    parent.getParent()) {
	    if(parent instanceof JComponent) {
		jparent = (JComponent) parent;
		if(jparent.getFlag(ANCESTOR_USING_BUFFER))
		  setFlag(ANCESTOR_USING_BUFFER, true);
		if(jparent.getFlag(IS_PAINTING_TILE))
		  setFlag(IS_PAINTING_TILE, true);
		if(jparent.getFlag(IS_PRINTING))
		  setFlag(IS_PRINTING, true);
		if(jparent.getFlag(IS_PRINTING_ALL))
		  setFlag(IS_PRINTING_ALL, true);
		break;
	    }
	}
!!!2191771.java!!!	printAll(inout g : Graphics) : void
	setFlag(IS_PRINTING_ALL, true);
	try {
	    print(g);
	}
	finally {
	    setFlag(IS_PRINTING_ALL, false);
	}
!!!2191899.java!!!	print(inout g : Graphics) : void
	setFlag(IS_PRINTING, true);
	try {
	    paint(g);
	}
	finally {
	    setFlag(IS_PRINTING, false);
	}
!!!2192027.java!!!	printComponent(inout g : Graphics) : void
	paintComponent(g);
!!!2192155.java!!!	printChildren(inout g : Graphics) : void
	paintChildren(g);
!!!2192283.java!!!	printBorder(inout g : Graphics) : void
	paintBorder(g);
!!!2192411.java!!!	isPaintingTile() : boolean
        return getFlag(IS_PAINTING_TILE);
!!!2192539.java!!!	isManagingFocus() : boolean
	return false;
!!!2192667.java!!!	registerNextFocusableComponent() : void
	registerNextFocusableComponent(getNextFocusableComponent());
!!!2192795.java!!!	registerNextFocusableComponent(inout nextFocusableComponent : Component) : void
	if (nextFocusableComponent == null) {
	    return;
	}
  
	Container nearestRoot =
	    (isFocusCycleRoot()) ? this : getFocusCycleRootAncestor();
	FocusTraversalPolicy policy = nearestRoot.getFocusTraversalPolicy();
	if (!(policy instanceof LegacyGlueFocusTraversalPolicy)) {
	    policy = new LegacyGlueFocusTraversalPolicy(policy);
	    nearestRoot.setFocusTraversalPolicy(policy);
	}
	((LegacyGlueFocusTraversalPolicy)policy).
	    setNextFocusableComponent(this, nextFocusableComponent);
!!!2192923.java!!!	deregisterNextFocusableComponent() : void
	Component nextFocusableComponent = getNextFocusableComponent();
	if (nextFocusableComponent == null) {
	    return;
	}

	Container nearestRoot =
	    (isFocusCycleRoot()) ? this : getFocusCycleRootAncestor();
	if (nearestRoot == null) {
	    return;
	}
	FocusTraversalPolicy policy = nearestRoot.getFocusTraversalPolicy();
	if (policy instanceof LegacyGlueFocusTraversalPolicy) {
	    ((LegacyGlueFocusTraversalPolicy)policy).
		unsetNextFocusableComponent(this, nextFocusableComponent);
	}
!!!2193051.java!!!	setNextFocusableComponent(inout aComponent : Component) : void
	boolean displayable = isDisplayable();
	if (displayable) {
	    deregisterNextFocusableComponent();
	}
	putClientProperty(NEXT_FOCUS, aComponent);
	if (displayable) {
	    registerNextFocusableComponent(aComponent);
	}
!!!2193179.java!!!	getNextFocusableComponent() : Component
	return (Component)getClientProperty(NEXT_FOCUS);
!!!2193307.java!!!	setRequestFocusEnabled(inout requestFocusEnabled : boolean) : void
        setFlag(REQUEST_FOCUS_DISABLED, !requestFocusEnabled);
!!!2193435.java!!!	isRequestFocusEnabled() : boolean
        return !getFlag(REQUEST_FOCUS_DISABLED);
!!!2193563.java!!!	runInputVerifier() : boolean
        KeyboardFocusManager kfm = KeyboardFocusManager.getCurrentKeyboardFocusManager();
        boolean inActivation;
        try {
            AccessibleMethod accessibleMethod
                = new AccessibleMethod(KeyboardFocusManager.class,
                                       "isInActivation");
            inActivation = (Boolean) (accessibleMethod.invokeNoChecked(kfm));
        } catch (NoSuchMethodException e) {
            throw new AssertionError(
                "Couldn't locate method KeyboardFocusManager.isInActivation()");
        }

        if (inActivation) {
            // Focus automatically returned back from another window
            // no need to process input verifier again
            return true;
        }

        if (inInputVerifier) {
            // We're already running the InputVerifier, assume the
            // developer knows what they're doing.
            return true;
        }
        Component focusOwner = kfm.getFocusOwner();

        if (focusOwner == null) {
            // If we are moving focus from another window, we should detect
            // what element was in focus in the window that will be focused now.
            // To do this, static package private method 
            // KeyboardFocusManager.getMostRecentFocusOwner() will be called. 
            // We will use AccessController.doPrivileged() to make package 
            // private method accessible. 
            Window window = SwingUtilities.getWindowAncestor(this); 
            if (window != null) { 
                try {
                    AccessibleMethod accessibleMethod
                        = new AccessibleMethod(KeyboardFocusManager.class,
                                               "getMostRecentFocusOwner",
                                               Window.class);
                    focusOwner = (Component) (accessibleMethod.invokeNoChecked(null,
                                                                               window));
                } catch (NoSuchMethodException e) {
                    throw new AssertionError("Couldn't locate method " +
                            "KeyboardFocusManager.getMostRecentFocusOwner()");
                }
            }
        }

        if (focusOwner == this) {
            return true;
        }

	if (!getVerifyInputWhenFocusTarget()) {
	    return true;
	}
  
	if (focusOwner == null || !(focusOwner instanceof JComponent)) {
	    return true;
	}
  
	JComponent jFocusOwner = (JComponent)focusOwner;
	InputVerifier iv = jFocusOwner.getInputVerifier();
	
	if (iv == null) {
	    return true;
	} else {
            inInputVerifier = true;
            try {
                return iv.shouldYieldFocus(jFocusOwner);
            } finally {
                inInputVerifier = false;
            }
	}
!!!2193691.java!!!	requestFocus() : void
        if (runInputVerifier()) {
	    super.requestFocus();
	}
!!!2193819.java!!!	requestFocus(inout temporary : boolean) : boolean
	return (runInputVerifier())
	    ? super.requestFocus(temporary)
	    : false;
!!!2193947.java!!!	requestFocusInWindow() : boolean
	return (runInputVerifier())
	    ? super.requestFocusInWindow()
	    : false;
!!!2194075.java!!!	requestFocusInWindow(inout temporary : boolean) : boolean
	return (runInputVerifier())
	    ? super.requestFocusInWindow(temporary)
	    : false;
!!!2194203.java!!!	grabFocus() : void
	requestFocus();
!!!2194331.java!!!	setVerifyInputWhenFocusTarget(inout verifyInputWhenFocusTarget : boolean) : void
	boolean oldVerifyInputWhenFocusTarget =
	    this.verifyInputWhenFocusTarget;
        this.verifyInputWhenFocusTarget = verifyInputWhenFocusTarget;
	firePropertyChange("verifyInputWhenFocusTarget",
			   oldVerifyInputWhenFocusTarget,
			   verifyInputWhenFocusTarget);
!!!2194459.java!!!	getVerifyInputWhenFocusTarget() : boolean
        return verifyInputWhenFocusTarget;
!!!2194587.java!!!	getFontMetrics(inout font : Font) : FontMetrics
        if (font != null && SwingUtilities2.drawTextAntialiased(aaText)) {
            synchronized(aaFontMap) {
                FontMetrics aaMetrics = aaFontMap.get(font);
                if (aaMetrics == null) {
                    aaMetrics = new FontDesignMetrics(
                             font, SwingUtilities2.AA_FRC);
                    aaFontMap.put(font, aaMetrics);
                }
                return aaMetrics;
            }
        }
        return super.getFontMetrics(font);
!!!2194715.java!!!	setPreferredSize(inout preferredSize : Dimension) : void
        super.setPreferredSize(preferredSize);
!!!2194843.java!!!	getPreferredSize() : Dimension
        if (isPreferredSizeSet()) {
            return super.getPreferredSize();
        }
        Dimension size = null;
        if (ui != null) {
            size = ui.getPreferredSize(this);
        }
        return (size != null) ? size : super.getPreferredSize();
!!!2194971.java!!!	setMaximumSize(inout maximumSize : Dimension) : void
        super.setMaximumSize(maximumSize);
!!!2195099.java!!!	getMaximumSize() : Dimension
        if (isMaximumSizeSet()) {
            return super.getMaximumSize();
        }
        Dimension size = null;
        if (ui != null) {
            size = ui.getMaximumSize(this);
        }
        return (size != null) ? size : super.getMaximumSize();
!!!2195227.java!!!	setMinimumSize(inout minimumSize : Dimension) : void
        super.setMinimumSize(minimumSize);
!!!2195355.java!!!	getMinimumSize() : Dimension
        if (isMinimumSizeSet()) {
            return super.getMinimumSize();
        }
        Dimension size = null;
        if (ui != null) {
            size = ui.getMinimumSize(this);
        }
        return (size != null) ? size : super.getMinimumSize();
!!!2195483.java!!!	contains(in x : int, in y : int) : boolean
        return (ui != null) ? ui.contains(this, x, y) : super.contains(x, y);
!!!2195611.java!!!	setBorder(inout border : Border) : void
        Border         oldBorder = this.border;

        this.border = border;
        firePropertyChange("border", oldBorder, border);
        if (border != oldBorder) {
            if (border == null || oldBorder == null ||
                !(border.getBorderInsets(this).equals(oldBorder.getBorderInsets(this)))) {
                revalidate();
            } 
            repaint();
        }
!!!2195739.java!!!	getBorder() : Border
        return border;
!!!2195867.java!!!	getInsets() : Insets
        if (border != null) {
            return border.getBorderInsets(this);
        }
        return super.getInsets();
!!!2195995.java!!!	getInsets(inout insets : Insets) : Insets
        if (insets == null) {
            insets = new Insets(0, 0, 0, 0);
        }
        if (border != null) {
            if (border instanceof AbstractBorder) {
                return ((AbstractBorder)border).getBorderInsets(this, insets);
            } else {
                // Can't reuse border insets because the Border interface
                // can't be enhanced.
                return border.getBorderInsets(this);
            }
        } else {
            // super.getInsets() always returns an Insets object with
            // all of its value zeroed.  No need for a new object here.
            insets.left = insets.top = insets.right = insets.bottom = 0;
            return insets;
        }
!!!2196123.java!!!	getAlignmentY() : float
        if (isAlignmentYSet) {
            return alignmentY;
        }
        return super.getAlignmentY();
!!!2196251.java!!!	setAlignmentY(in alignmentY : float) : void
        this.alignmentY = alignmentY > 1.0f ? 1.0f : alignmentY < 0.0f ? 0.0f : alignmentY;
        isAlignmentYSet = true;
!!!2196379.java!!!	getAlignmentX() : float
        if (isAlignmentXSet) {
            return alignmentX;
        }
        return super.getAlignmentX();
!!!2196507.java!!!	setAlignmentX(in alignmentX : float) : void
        this.alignmentX = alignmentX > 1.0f ? 1.0f : alignmentX < 0.0f ? 0.0f : alignmentX;
        isAlignmentXSet = true;
!!!2196635.java!!!	setInputVerifier(inout inputVerifier : InputVerifier) : void
	InputVerifier oldInputVerifier = (InputVerifier)getClientProperty(
                                         INPUT_VERIFIER_KEY);
        putClientProperty(INPUT_VERIFIER_KEY, inputVerifier);
	firePropertyChange("inputVerifier", oldInputVerifier, inputVerifier);
!!!2196763.java!!!	getInputVerifier() : InputVerifier
        return (InputVerifier)getClientProperty(INPUT_VERIFIER_KEY);
!!!2196891.java!!!	getGraphics() : Graphics
        if (DEBUG_GRAPHICS_LOADED && shouldDebugGraphics() != 0) {
            DebugGraphics graphics = new DebugGraphics(super.getGraphics(),
                                                       this);
            return graphics;
        }
        return super.getGraphics();
!!!2197019.java!!!	setDebugGraphicsOptions(in debugOptions : int) : void
        DebugGraphics.setDebugOptions(this, debugOptions);
!!!2197147.java!!!	getDebugGraphicsOptions() : int
        return DebugGraphics.getDebugOptions(this);
!!!2197275.java!!!	shouldDebugGraphics() : int
        return DebugGraphics.shouldComponentDebug(this);
!!!2197403.java!!!	registerKeyboardAction(inout anAction : ActionListener, in aCommand : String, inout aKeyStroke : KeyStroke, in aCondition : int) : void

	InputMap inputMap = getInputMap(aCondition, true);

	if (inputMap != null) {
	    ActionMap actionMap = getActionMap(true);
	    ActionStandin action = new ActionStandin(anAction, aCommand);
	    inputMap.put(aKeyStroke, action);
	    if (actionMap != null) {
		actionMap.put(action, action);
	    }
	}
!!!2197531.java!!!	registerWithKeyboardManager(inout onlyIfNew : boolean) : void
	InputMap inputMap = getInputMap(WHEN_IN_FOCUSED_WINDOW, false);
	KeyStroke[] strokes;
	Hashtable registered = (Hashtable)getClientProperty
	                        (WHEN_IN_FOCUSED_WINDOW_BINDINGS);

	if (inputMap != null) {
	    // Push any new KeyStrokes to the KeyboardManager.
	    strokes = inputMap.allKeys();
	    if (strokes != null) {
		for (int counter = strokes.length - 1; counter >= 0;
		     counter--) {
		    if (!onlyIfNew || registered == null ||
			registered.get(strokes[counter]) == null) {
			registerWithKeyboardManager(strokes[counter]);
		    }
		    if (registered != null) {
			registered.remove(strokes[counter]);
		    }
		}
	    }
	}
	else {
	    strokes = null;
	}
	// Remove any old ones.
	if (registered != null && registered.size() > 0) {
	    Enumeration keys = registered.keys();

	    while (keys.hasMoreElements()) {
		KeyStroke ks = (KeyStroke)keys.nextElement();
		unregisterWithKeyboardManager(ks);
	    }
	    registered.clear();
	}
	// Updated the registered Hashtable.
	if (strokes != null && strokes.length > 0) {
	    if (registered == null) {
		registered = new Hashtable(strokes.length);
		putClientProperty(WHEN_IN_FOCUSED_WINDOW_BINDINGS, registered);
	    }
	    for (int counter = strokes.length - 1; counter >= 0; counter--) {
		registered.put(strokes[counter], strokes[counter]);
	    }
	}
	else {
	    putClientProperty(WHEN_IN_FOCUSED_WINDOW_BINDINGS, null);
	}
!!!2197659.java!!!	unregisterWithKeyboardManager() : void
	Hashtable registered = (Hashtable)getClientProperty
	                        (WHEN_IN_FOCUSED_WINDOW_BINDINGS);

	if (registered != null && registered.size() > 0) {
	    Enumeration keys = registered.keys();

	    while (keys.hasMoreElements()) {
		KeyStroke ks = (KeyStroke)keys.nextElement();
		unregisterWithKeyboardManager(ks);
	    }
	}
	putClientProperty(WHEN_IN_FOCUSED_WINDOW_BINDINGS, null);
!!!2197787.java!!!	componentInputMapChanged(inout inputMap : ComponentInputMap) : void
	InputMap km = getInputMap(WHEN_IN_FOCUSED_WINDOW, false);

	while (km != inputMap && km != null) {
	    km = (ComponentInputMap)km.getParent();
	}
	if (km != null) {
	    registerWithKeyboardManager(false);
	}
!!!2197915.java!!!	registerWithKeyboardManager(inout aKeyStroke : KeyStroke) : void
	KeyboardManager.getCurrentManager().registerKeyStroke(aKeyStroke,this);
!!!2198043.java!!!	unregisterWithKeyboardManager(inout aKeyStroke : KeyStroke) : void
	KeyboardManager.getCurrentManager().unregisterKeyStroke(aKeyStroke,
								this);
!!!2198171.java!!!	registerKeyboardAction(inout anAction : ActionListener, inout aKeyStroke : KeyStroke, in aCondition : int) : void
        registerKeyboardAction(anAction,null,aKeyStroke,aCondition);
!!!2198299.java!!!	unregisterKeyboardAction(inout aKeyStroke : KeyStroke) : void
	ActionMap am = getActionMap(false);
	for (int counter = 0; counter < 3; counter++) {
	    InputMap km = getInputMap(counter, false);
	    if (km != null) {
		Object actionID = km.get(aKeyStroke);

		if (am != null && actionID != null) {
		    am.remove(actionID);
		}
		km.remove(aKeyStroke);
	    }
	}
!!!2198427.java!!!	getRegisteredKeyStrokes() : KeyStroke
	int[] counts = new int[3];
	KeyStroke[][] strokes = new KeyStroke[3][];

	for (int counter = 0; counter < 3; counter++) {
	    InputMap km = getInputMap(counter, false);
	    strokes[counter] = (km != null) ? km.allKeys() : null;
	    counts[counter] = (strokes[counter] != null) ?
		               strokes[counter].length : 0;
	}
	KeyStroke[] retValue = new KeyStroke[counts[0] + counts[1] +
					    counts[2]];
	for (int counter = 0, last = 0; counter < 3; counter++) {
	    if (counts[counter] > 0) {
		System.arraycopy(strokes[counter], 0, retValue, last,
				 counts[counter]);
		last += counts[counter];
	    }
	}
	return retValue;
!!!2198555.java!!!	getConditionForKeyStroke(inout aKeyStroke : KeyStroke) : int
	for (int counter = 0; counter < 3; counter++) {
	    InputMap inputMap = getInputMap(counter, false);
	    if (inputMap != null && inputMap.get(aKeyStroke) != null) {
		return counter;
	    }
	}
	return UNDEFINED_CONDITION;
!!!2198683.java!!!	getActionForKeyStroke(inout aKeyStroke : KeyStroke) : ActionListener
	ActionMap am = getActionMap(false);

	if (am == null) {
	    return null;
	}
	for (int counter = 0; counter < 3; counter++) {
	    InputMap inputMap = getInputMap(counter, false);
	    if (inputMap != null) {
		Object actionBinding = inputMap.get(aKeyStroke);

		if (actionBinding != null) {
		    Action action = am.get(actionBinding);
		    if (action instanceof ActionStandin) {
			return ((ActionStandin)action).actionListener;
		    }
		    return action;
		}
	    }
	}
	return null;
!!!2198811.java!!!	resetKeyboardActions() : void
	// Keys
	for (int counter = 0; counter < 3; counter++) {
	    InputMap inputMap = getInputMap(counter, false);

	    if (inputMap != null) {
		inputMap.clear();
	    }
	}

	// Actions
	ActionMap am = getActionMap(false);

	if (am != null) {
	    am.clear();
	}
!!!2198939.java!!!	setInputMap(in condition : int, inout map : InputMap) : void
	switch (condition) {
	case WHEN_IN_FOCUSED_WINDOW:
	    if (map != null && !(map instanceof ComponentInputMap)) {
		throw new IllegalArgumentException("WHEN_IN_FOCUSED_WINDOW InputMaps must be of type ComponentInputMap");
	    }
	    windowInputMap = (ComponentInputMap)map;
	    setFlag(WIF_INPUTMAP_CREATED, true);
	    registerWithKeyboardManager(false);
	    break;
	case WHEN_ANCESTOR_OF_FOCUSED_COMPONENT:
	    ancestorInputMap = map;
	    setFlag(ANCESTOR_INPUTMAP_CREATED, true);
	    break;
	case WHEN_FOCUSED:
	    focusInputMap = map;
	    setFlag(FOCUS_INPUTMAP_CREATED, true);
	    break;
	default:
	    throw new IllegalArgumentException("condition must be one of JComponent.WHEN_IN_FOCUSED_WINDOW, JComponent.WHEN_FOCUSED or JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT");
	}
!!!2199067.java!!!	getInputMap(in condition : int) : InputMap
	return getInputMap(condition, true);
!!!2199195.java!!!	getInputMap() : InputMap
	return getInputMap(WHEN_FOCUSED, true);
!!!2199323.java!!!	setActionMap(inout am : ActionMap) : void
	actionMap = am;
	setFlag(ACTIONMAP_CREATED, true);
!!!2199451.java!!!	getActionMap() : ActionMap
	return getActionMap(true);
!!!2199579.java!!!	getInputMap(in condition : int, inout create : boolean) : InputMap
	switch (condition) {
	case WHEN_FOCUSED:
	    if (getFlag(FOCUS_INPUTMAP_CREATED)) {
		return focusInputMap;
	    }
	    // Hasn't been created yet.
	    if (create) {
		InputMap km = new InputMap();
		setInputMap(condition, km);
		return km;
	    }
	    break;
	case WHEN_ANCESTOR_OF_FOCUSED_COMPONENT:
	    if (getFlag(ANCESTOR_INPUTMAP_CREATED)) {
		return ancestorInputMap;
	    }
	    // Hasn't been created yet.
	    if (create) {
		InputMap km = new InputMap();
		setInputMap(condition, km);
		return km;
	    }
	    break;
	case WHEN_IN_FOCUSED_WINDOW:
	    if (getFlag(WIF_INPUTMAP_CREATED)) {
		return windowInputMap;
	    }
	    // Hasn't been created yet.
	    if (create) {
		ComponentInputMap km = new ComponentInputMap(this);
		setInputMap(condition, km);
		return km;
	    }
	    break;
	default:
	    throw new IllegalArgumentException("condition must be one of JComponent.WHEN_IN_FOCUSED_WINDOW, JComponent.WHEN_FOCUSED or JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT");
	}
	return null;
!!!2199707.java!!!	getActionMap(inout create : boolean) : ActionMap
	if (getFlag(ACTIONMAP_CREATED)) {
	    return actionMap;
	}
	// Hasn't been created.
	if (create) {
	    ActionMap am = new ActionMap();
	    setActionMap(am);
	    return am;
	}
	return null;
!!!2199835.java!!!	requestDefaultFocus() : boolean
	Container nearestRoot =
	    (isFocusCycleRoot()) ? this : getFocusCycleRootAncestor();
	if (nearestRoot == null) {
	    return false;
	}
	Component comp = nearestRoot.getFocusTraversalPolicy().
	    getDefaultComponent(nearestRoot);
	if (comp != null) {
	    comp.requestFocus();
	    return true;
	} else {
	    return false;
	}
!!!2199963.java!!!	setVisible(inout aFlag : boolean) : void
        if(aFlag != isVisible()) {
            super.setVisible(aFlag);
            Container parent = getParent();
            if(parent != null) {
                Rectangle r = getBounds();
                parent.repaint(r.x,r.y,r.width,r.height);
            }
	    // Some (all should) LayoutManagers do not consider components
	    // that are not visible. As such we need to revalidate when the
	    // visible bit changes.
	    revalidate();
        }
!!!2200091.java!!!	setEnabled(inout enabled : boolean) : void
        boolean oldEnabled = isEnabled();
        super.setEnabled(enabled);
        firePropertyChange("enabled", oldEnabled, enabled);
        if (enabled != oldEnabled) {
            repaint();
        }
!!!2200219.java!!!	setForeground(inout fg : Color) : void
        Color oldFg = getForeground();
	super.setForeground(fg);
	if ((oldFg != null) ? !oldFg.equals(fg) : ((fg != null) && !fg.equals(oldFg))) {
	    // foreground already bound in AWT1.2
	    repaint();
	}
!!!2200347.java!!!	setBackground(inout bg : Color) : void
	Color oldBg = getBackground();
	super.setBackground(bg);
	if ((oldBg != null) ? !oldBg.equals(bg) : ((bg != null) && !bg.equals(oldBg))) {
	    // background already bound in AWT1.2
	    repaint();
	}
!!!2200475.java!!!	setFont(inout font : Font) : void
        Font oldFont = getFont();
        super.setFont(font);
        // font already bound in AWT1.2
        if (font != oldFont) {
            revalidate();
	    repaint();
        }
!!!2200603.java!!!	getDefaultLocale() : Locale
        Locale l = (Locale) SwingUtilities.appContextGet(defaultLocale);
        if( l == null ) {
            //REMIND(bcb) choosing the default value is more complicated
            //than this.
            l = Locale.getDefault();
            JComponent.setDefaultLocale( l );
        }
        return l;
!!!2200731.java!!!	setDefaultLocale(inout l : Locale) : void
        SwingUtilities.appContextPut(defaultLocale, l);
!!!2200987.java!!!	processKeyEvent(inout e : KeyEvent) : void
      boolean result;
      boolean shouldProcessKey;

      // This gives the key event listeners a crack at the event
      super.processKeyEvent(e);

      // give the component itself a crack at the event
      if (! e.isConsumed()) {
          processComponentKeyEvent(e);
      }

      shouldProcessKey = KeyboardState.shouldProcess(e);

      if(e.isConsumed()) {
        return;
      }

      if (shouldProcessKey && processKeyBindings(e, e.getID() ==
                                                 KeyEvent.KEY_PRESSED)) {
          e.consume();
      }
!!!2201115.java!!!	processKeyBinding(inout ks : KeyStroke, inout e : KeyEvent, in condition : int, inout pressed : boolean) : boolean
	InputMap map = getInputMap(condition, false);
	ActionMap am = getActionMap(false);

        if(map != null && am != null && isEnabled()) {
	    Object binding = map.get(ks);
	    Action action = (binding == null) ? null : am.get(binding);
	    if (action != null) {
		return SwingUtilities.notifyAction(action, ks, e, this,
						   e.getModifiers());
	    }
	}
        return false;
!!!2201243.java!!!	processKeyBindings(inout e : KeyEvent, inout pressed : boolean) : boolean
      if (!SwingUtilities.isValidKeyEventForKeyBindings(e)) {
          return false;
      }
      // Get the KeyStroke
      KeyStroke ks;

      if (e.getID() == KeyEvent.KEY_TYPED) {
          ks = KeyStroke.getKeyStroke(e.getKeyChar());
      }
      else {
	  ks = KeyStroke.getKeyStroke(e.getKeyCode(),e.getModifiers(),
				    (pressed ? false:true));
      }

      /* Do we have a key binding for e? */
      if(processKeyBinding(ks, e, WHEN_FOCUSED, pressed))
	  return true;

      /* We have no key binding. Let's try the path from our parent to the
       * window excluded. We store the path components so we can avoid
       * asking the same component twice.
       */
      Container parent = this;
      while (parent != null && !(parent instanceof Window) &&
	     !(parent instanceof Applet)) {
	  if(parent instanceof JComponent) {
	      if(((JComponent)parent).processKeyBinding(ks, e,
			       WHEN_ANCESTOR_OF_FOCUSED_COMPONENT, pressed))
		  return true;
	  }
	  // This is done so that the children of a JInternalFrame are
	  // given precedence for WHEN_IN_FOCUSED_WINDOW bindings before
	  // other components WHEN_IN_FOCUSED_WINDOW bindings. This also gives
	  // more precedence to the WHEN_IN_FOCUSED_WINDOW bindings of the
	  // JInternalFrame's children vs the
	  // WHEN_ANCESTOR_OF_FOCUSED_COMPONENT bindings of the parents.
	  // maybe generalize from JInternalFrame (like isFocusCycleRoot).
	  if ((parent instanceof JInternalFrame) &&
	      JComponent.processKeyBindingsForAllComponents(e,parent,pressed)){
	      return true;
	  }
	  parent = parent.getParent();
      }

      /* No components between the focused component and the window is
       * actually interested by the key event. Let's try the other
       * JComponent in this window.
       */
      if(parent != null) {
        return JComponent.processKeyBindingsForAllComponents(e,parent,pressed);
      }
      return false;
!!!2201371.java!!!	processKeyBindingsForAllComponents(inout e : KeyEvent, inout container : Container, inout pressed : boolean) : boolean
        while (true) {
            if (KeyboardManager.getCurrentManager().fireKeyboardAction(
                                e, pressed, container)) {
                return true;
            }
            if (container instanceof Popup.HeavyWeightWindow) {
                container = ((Window)container).getOwner();
            }
            else {
                return false;
            }
        }
!!!2201499.java!!!	setToolTipText(in text : String) : void
        String oldText = getToolTipText();
        putClientProperty(TOOL_TIP_TEXT_KEY, text);
        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
        if (text != null) {
	    if (oldText == null) {
                toolTipManager.registerComponent(this);
	    }
        } else {
            toolTipManager.unregisterComponent(this);
        }
!!!2201627.java!!!	getToolTipText() : String
        return (String)getClientProperty(TOOL_TIP_TEXT_KEY);
!!!2201755.java!!!	getToolTipText(inout event : MouseEvent) : String
        return getToolTipText();
!!!2201883.java!!!	getToolTipLocation(inout event : MouseEvent) : Point
        return null;
!!!2202011.java!!!	getPopupLocation(inout event : MouseEvent) : Point
        return null;
!!!2202139.java!!!	createToolTip() : JToolTip
        JToolTip tip = new JToolTip();
        tip.setComponent(this);
        return tip;
!!!2202267.java!!!	scrollRectToVisible(inout aRect : Rectangle) : void
        Container parent;
        int dx = getX(), dy = getY();

        for (parent = getParent();
                 !(parent == null) &&
                 !(parent instanceof JComponent) &&
                 !(parent instanceof CellRendererPane);
             parent = parent.getParent()) {
             Rectangle bounds = parent.getBounds();

             dx += bounds.x;
             dy += bounds.y;
        }

        if (!(parent == null) && !(parent instanceof CellRendererPane)) {
            aRect.x += dx;
            aRect.y += dy;

            ((JComponent)parent).scrollRectToVisible(aRect);
            aRect.x -= dx;
            aRect.y -= dy;
        }
!!!2202395.java!!!	setAutoscrolls(inout autoscrolls : boolean) : void
        setFlag(AUTOSCROLLS_SET, true);
        if (this.autoscrolls != autoscrolls) {
            this.autoscrolls = autoscrolls;
            if (autoscrolls) {
                enableEvents(AWTEvent.MOUSE_EVENT_MASK);
                enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);
            }
            else {
                Autoscroller.stop(this);
            }
        }
!!!2202523.java!!!	getAutoscrolls() : boolean
        return autoscrolls;
!!!2202651.java!!!	setTransferHandler(inout newHandler : TransferHandler) : void
	TransferHandler oldHandler = (TransferHandler)getClientProperty(
                                      TRANSFER_HANDLER_KEY);
        putClientProperty(TRANSFER_HANDLER_KEY, newHandler);

	if (! getSuppressDropTarget()) {
	    DropTarget dropHandler = getDropTarget();
	    if ((dropHandler == null) || (dropHandler instanceof UIResource)) {
		if (newHandler == null) {
		    setDropTarget(null);
		} else if (!GraphicsEnvironment.isHeadless()) {
		    setDropTarget(new TransferHandler.SwingDropTarget(this));
		}
	    }
	}
        firePropertyChange("transferHandler", oldHandler, newHandler);
!!!2202779.java!!!	getTransferHandler() : TransferHandler
	return (TransferHandler)getClientProperty(TRANSFER_HANDLER_KEY);
!!!2202907.java!!!	processMouseEvent(inout e : MouseEvent) : void
        if (autoscrolls && e.getID() == MouseEvent.MOUSE_RELEASED) {
            Autoscroller.stop(this);
        }
        super.processMouseEvent(e);
!!!2203035.java!!!	processMouseMotionEvent(inout e : MouseEvent) : void
        boolean dispatch = true;
        if (autoscrolls && e.getID() == MouseEvent.MOUSE_DRAGGED) {
            // We don't want to do the drags when the mouse moves if we're
            // autoscrolling.  It makes it feel spastic.
            dispatch = !Autoscroller.isRunning(this);
            Autoscroller.processMouseDragged(e);
        }
        if (dispatch) {
            super.processMouseMotionEvent(e);
        }
!!!2203163.java!!!	superProcessMouseMotionEvent(inout e : MouseEvent) : void
        super.processMouseMotionEvent(e);
!!!2203291.java!!!	setCreatedDoubleBuffer(inout newValue : boolean) : void
	setFlag(CREATED_DOUBLE_BUFFER, newValue);
!!!2203419.java!!!	getCreatedDoubleBuffer() : boolean
	return getFlag(CREATED_DOUBLE_BUFFER);
!!!2206619.java!!!	enable() : void
        if (isEnabled() != true) {
            super.enable();
            if (accessibleContext != null) {
                accessibleContext.firePropertyChange(
                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY, 
                    null, AccessibleState.ENABLED);
            }
        }
!!!2206747.java!!!	disable() : void
        if (isEnabled() != false) {
            super.disable();
            if (accessibleContext != null) {
                accessibleContext.firePropertyChange(
                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY, 
                    AccessibleState.ENABLED, null);
            }
        }
!!!2206875.java!!!	getAccessibleContext() : AccessibleContext
        return accessibleContext;
